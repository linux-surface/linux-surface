name: Sync Kernel with Upstream

on:
  # Manual trigger
  workflow_dispatch:

  # Automatic daily sync at 7:30 AM UTC
  schedule:
    - cron: '30 7 * * *'

jobs:
  sync:
    name: Sync with upstream
    runs-on: ubuntu-latest

    steps:
      - name: Cache kernel repository
        uses: actions/cache@v4
        with:
          path: kernel/.git
          key: kernel-git-${{ github.run_number }}
          restore-keys: |
            kernel-git-

      - name: Clean up old caches
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Cleaning up old kernel-git caches (keeping only the latest)..."
          gh cache list --repo ${{ github.repository }} --key kernel-git- --json id,key,createdAt --limit 100 | \
            jq -r 'sort_by(.createdAt) | reverse | .[1:] | .[].id' | \
            xargs -I {} gh cache delete {} --repo ${{ github.repository }} || true

      - name: Checkout linux-surface repo
        uses: actions/checkout@v6
        with:
          repository: linux-surface/linux-surface
          path: linux-surface
          token: ${{ secrets.LINUX_SURFACE_BOT_TOKEN }}

      - name: Checkout kernel repository
        uses: actions/checkout@v6
        with:
          repository: linux-surface/kernel
          path: kernel
          fetch-depth: 0
          token: ${{ secrets.LINUX_SURFACE_BOT_TOKEN }}

      - name: Setup git identity
        run: |
          git config --global user.name "surfacebot"
          git config --global user.email "surfacebot@users.noreply.github.com"

      - name: Sync with upstream
        id: sync
        working-directory: kernel
        run: |
          echo "Getting current origin tags..."
          git ls-remote --tags origin | awk '{print $2}' | sed 's|refs/tags/||' | grep -v '\^{}' | sort > /tmp/origin-tags.txt

          echo "Adding upstream remote..."
          git remote add upstream https://github.com/gregkh/linux || true

          echo "Fetching from upstream..."
          git fetch upstream --tags

          echo "Counting new tags..."
          # Get tags that exist in upstream but not in origin
          git ls-remote --tags upstream | awk '{print $2}' | sed 's|refs/tags/||' | grep -v '\^{}' | sort > /tmp/upstream-tags.txt
          NEW_TAGS=$(comm -13 /tmp/origin-tags.txt /tmp/upstream-tags.txt | wc -l)

          echo "new_tags=${NEW_TAGS}" >> "${GITHUB_OUTPUT}"
          echo "Found ${NEW_TAGS} new tags"

          # Save new tags list for later processing
          comm -13 /tmp/origin-tags.txt /tmp/upstream-tags.txt > /tmp/new-tags.txt

          # Show some of the new tags (first 10)
          echo "Sample of new tags:"
          cat /tmp/new-tags.txt | head -10

          echo "Updating master branch..."
          git checkout -B master origin/master
          git merge --ff-only upstream/master || {
            echo "ERROR: Cannot fast-forward master branch"
            echo "Manual intervention may be required"
            exit 1
          }

          echo "master_updated=true" >> "${GITHUB_OUTPUT}"

      - name: Push changes
        if: steps.sync.outputs.new_tags != '0' || steps.sync.outputs.master_updated == 'true'
        working-directory: kernel
        run: |
          echo "Pushing new tags..."
          git push origin --tags

          echo "Pushing master branch..."
          git push origin master

      - name: Check for maintained branch updates
        id: check_maintained
        if: steps.sync.outputs.new_tags != '0'
        run: |
          CONFIG_FILE="${GITHUB_WORKSPACE}/linux-surface/.github/data/autoupdate/maintained-branches.conf"

          echo "Reading maintained branches from ${CONFIG_FILE}..."

          # Read config file, skip comments and empty lines
          BRANCHES_TO_REBASE=""

          while IFS=: read -r BRANCH VERSION; do
            # Skip comments and empty lines
            [[ "$BRANCH" =~ ^#.*$ ]] && continue
            [[ -z "$BRANCH" ]] && continue

            echo "Checking for version ${VERSION} (branch: ${BRANCH})..."

            # Check if any new tags match this version (e.g., v6.18.*, excluding -rc)
            MATCHING_TAGS=$(grep -E "^v${VERSION}\.[0-9]+$" /tmp/new-tags.txt || true)

            if [ -n "$MATCHING_TAGS" ]; then
              LATEST_TAG=$(echo "$MATCHING_TAGS" | sort -V | tail -1)
              echo "  ✓ Found new release for ${BRANCH}: ${LATEST_TAG}"
              BRANCHES_TO_REBASE="${BRANCHES_TO_REBASE}${BRANCH}:${LATEST_TAG},"
            else
              echo "  - No new releases for ${BRANCH}"
            fi
          done < "$CONFIG_FILE"

          # Remove trailing comma
          BRANCHES_TO_REBASE="${BRANCHES_TO_REBASE%,}"

          echo "branches_to_rebase=${BRANCHES_TO_REBASE}" >> "${GITHUB_OUTPUT}"

          if [ -n "$BRANCHES_TO_REBASE" ]; then
            echo ""
            echo "Branches to rebase: ${BRANCHES_TO_REBASE}"
          else
            echo ""
            echo "No maintained branches need rebasing"
          fi

      - name: Trigger rebase workflows
        if: steps.check_maintained.outputs.branches_to_rebase != ''
        env:
          GH_TOKEN: ${{ secrets.LINUX_SURFACE_BOT_TOKEN }}
          BRANCHES_TO_REBASE: ${{ steps.check_maintained.outputs.branches_to_rebase }}
        run: |
          echo "Triggering rebase workflows for updated branches..."
          echo ""

          IFS=',' read -ra BRANCH_PAIRS <<< "$BRANCHES_TO_REBASE"
          for pair in "${BRANCH_PAIRS[@]}"; do
            BRANCH=$(echo "$pair" | cut -d: -f1)
            TAG=$(echo "$pair" | cut -d: -f2)

            echo "Triggering rebase for ${BRANCH} to ${TAG}..."
            gh workflow run rebase-kernel.yml \
              --repo ${{ github.repository }} \
              --field branch="${BRANCH}" \
              --field target_tag="${TAG}" \
              --field build=true \
              --field dry_run=false

            echo "  ✓ Triggered"
            echo ""
          done

      - name: Generate summary
        if: always()
        env:
          NEW_TAGS: ${{ steps.sync.outputs.new_tags }}
          MASTER_UPDATED: ${{ steps.sync.outputs.master_updated }}
          BRANCHES_TO_REBASE: ${{ steps.check_maintained.outputs.branches_to_rebase }}
        run: |
          echo "## Kernel Upstream Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${MASTER_UPDATED}" = "true" ]; then
            echo "✅ **Status:** Success" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **New tags:** ${NEW_TAGS:-0}" >> $GITHUB_STEP_SUMMARY
            echo "- **Master branch:** Updated" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ -n "${BRANCHES_TO_REBASE}" ]; then
              echo "### Automatic Rebases Triggered" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "The following branches will be automatically rebased:" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY

              IFS=',' read -ra BRANCH_PAIRS <<< "$BRANCHES_TO_REBASE"
              for pair in "${BRANCH_PAIRS[@]}"; do
                BRANCH=$(echo "$pair" | cut -d: -f1)
                TAG=$(echo "$pair" | cut -d: -f2)
                echo "- **${BRANCH}** → ${TAG}" >> $GITHUB_STEP_SUMMARY
              done

              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Check the [Rebase and Build Kernel workflow runs](../../actions/workflows/rebase-kernel.yml) for progress." >> $GITHUB_STEP_SUMMARY
            elif [ "${NEW_TAGS:-0}" -gt 0 ]; then
              echo "### New Tags" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "New tags were synced, but none match maintained branch versions." >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "To update maintained branches, edit \`.github/data/autoupdate/maintained-branches.txt\`" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "ℹ️ **Status:** No changes" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Repository is already up-to-date with upstream." >> $GITHUB_STEP_SUMMARY
          fi
