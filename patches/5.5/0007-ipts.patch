From 3e83aa79daed3c26b4b525cb0a4314f9a3ef6035 Mon Sep 17 00:00:00 2001
From: Dorian Stoll <dorian.stoll@tmsp.io>
Date: Mon, 27 Jan 2020 21:16:20 +0100
Subject: [PATCH 7/7] ipts

---
 drivers/input/touchscreen/Kconfig             |   2 +
 drivers/input/touchscreen/Makefile            |   1 +
 drivers/input/touchscreen/ipts/Kconfig        |  16 ++
 drivers/input/touchscreen/ipts/Makefile       |  16 ++
 drivers/input/touchscreen/ipts/context.h      |  61 ++++
 drivers/input/touchscreen/ipts/control.c      |  93 ++++++
 drivers/input/touchscreen/ipts/control.h      |  18 ++
 drivers/input/touchscreen/ipts/devices.c      |  46 +++
 drivers/input/touchscreen/ipts/devices.h      |  33 +++
 drivers/input/touchscreen/ipts/hid.c          | 122 ++++++++
 drivers/input/touchscreen/ipts/hid.h          |  17 ++
 drivers/input/touchscreen/ipts/init.c         |  93 ++++++
 drivers/input/touchscreen/ipts/math.c         | 103 +++++++
 drivers/input/touchscreen/ipts/math.h         |  21 ++
 drivers/input/touchscreen/ipts/params.c       |  27 ++
 drivers/input/touchscreen/ipts/params.h       |  15 +
 .../touchscreen/ipts/protocol/commands.h      |  55 ++++
 .../input/touchscreen/ipts/protocol/enums.h   |  59 ++++
 .../input/touchscreen/ipts/protocol/events.h  |  29 ++
 .../touchscreen/ipts/protocol/responses.h     |  40 +++
 .../input/touchscreen/ipts/protocol/touch.h   |  62 ++++
 drivers/input/touchscreen/ipts/receiver.c     | 266 ++++++++++++++++++
 drivers/input/touchscreen/ipts/receiver.h     |   8 +
 drivers/input/touchscreen/ipts/resources.c    | 131 +++++++++
 drivers/input/touchscreen/ipts/resources.h    |  11 +
 drivers/input/touchscreen/ipts/singletouch.c  |  56 ++++
 drivers/input/touchscreen/ipts/singletouch.h  |  13 +
 drivers/input/touchscreen/ipts/stylus.c       | 159 +++++++++++
 drivers/input/touchscreen/ipts/stylus.h       |  13 +
 drivers/misc/mei/hw-me-regs.h                 |   2 +
 drivers/misc/mei/pci-me.c                     |   2 +
 include/uapi/linux/input.h                    |   1 +
 32 files changed, 1591 insertions(+)
 create mode 100644 drivers/input/touchscreen/ipts/Kconfig
 create mode 100644 drivers/input/touchscreen/ipts/Makefile
 create mode 100644 drivers/input/touchscreen/ipts/context.h
 create mode 100644 drivers/input/touchscreen/ipts/control.c
 create mode 100644 drivers/input/touchscreen/ipts/control.h
 create mode 100644 drivers/input/touchscreen/ipts/devices.c
 create mode 100644 drivers/input/touchscreen/ipts/devices.h
 create mode 100644 drivers/input/touchscreen/ipts/hid.c
 create mode 100644 drivers/input/touchscreen/ipts/hid.h
 create mode 100644 drivers/input/touchscreen/ipts/init.c
 create mode 100644 drivers/input/touchscreen/ipts/math.c
 create mode 100644 drivers/input/touchscreen/ipts/math.h
 create mode 100644 drivers/input/touchscreen/ipts/params.c
 create mode 100644 drivers/input/touchscreen/ipts/params.h
 create mode 100644 drivers/input/touchscreen/ipts/protocol/commands.h
 create mode 100644 drivers/input/touchscreen/ipts/protocol/enums.h
 create mode 100644 drivers/input/touchscreen/ipts/protocol/events.h
 create mode 100644 drivers/input/touchscreen/ipts/protocol/responses.h
 create mode 100644 drivers/input/touchscreen/ipts/protocol/touch.h
 create mode 100644 drivers/input/touchscreen/ipts/receiver.c
 create mode 100644 drivers/input/touchscreen/ipts/receiver.h
 create mode 100644 drivers/input/touchscreen/ipts/resources.c
 create mode 100644 drivers/input/touchscreen/ipts/resources.h
 create mode 100644 drivers/input/touchscreen/ipts/singletouch.c
 create mode 100644 drivers/input/touchscreen/ipts/singletouch.h
 create mode 100644 drivers/input/touchscreen/ipts/stylus.c
 create mode 100644 drivers/input/touchscreen/ipts/stylus.h

diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index c071f7c407b6..028ff55d779d 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1310,4 +1310,6 @@ config TOUCHSCREEN_IQS5XX
 	  To compile this driver as a module, choose M here: the
 	  module will be called iqs5xx.
 
+source "drivers/input/touchscreen/ipts/Kconfig"
+
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 94c6162409b3..864f0e092ab6 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -45,6 +45,7 @@ obj-$(CONFIG_TOUCHSCREEN_EXC3000)	+= exc3000.o
 obj-$(CONFIG_TOUCHSCREEN_FUJITSU)	+= fujitsu_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GOODIX)	+= goodix.o
 obj-$(CONFIG_TOUCHSCREEN_HIDEEP)	+= hideep.o
+obj-$(CONFIG_TOUCHSCREEN_IPTS)		+= ipts/
 obj-$(CONFIG_TOUCHSCREEN_ILI210X)	+= ili210x.o
 obj-$(CONFIG_TOUCHSCREEN_IMX6UL_TSC)	+= imx6ul_tsc.o
 obj-$(CONFIG_TOUCHSCREEN_INEXIO)	+= inexio.o
diff --git a/drivers/input/touchscreen/ipts/Kconfig b/drivers/input/touchscreen/ipts/Kconfig
new file mode 100644
index 000000000000..d3c530dafa94
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/Kconfig
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+config TOUCHSCREEN_IPTS
+	tristate "Intel Precise Touch & Stylus"
+	select INTEL_MEI
+	depends on X86
+	depends on PCI
+	depends on HID
+	help
+	  Say Y here if your system has a touchscreen using Intels
+	  Precise Touch & Stylus (IPTS).
+
+	  If unsure say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ipts.
diff --git a/drivers/input/touchscreen/ipts/Makefile b/drivers/input/touchscreen/ipts/Makefile
new file mode 100644
index 000000000000..d80808175788
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/Makefile
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# Makefile for the IPTS touchscreen driver
+#
+
+obj-$(CONFIG_TOUCHSCREEN_IPTS) += ipts.o
+ipts-objs := control.o
+ipts-objs += devices.o
+ipts-objs += hid.o
+ipts-objs += init.o
+ipts-objs += math.o
+ipts-objs += params.o
+ipts-objs += receiver.o
+ipts-objs += resources.o
+ipts-objs += singletouch.o
+ipts-objs += stylus.o
diff --git a/drivers/input/touchscreen/ipts/context.h b/drivers/input/touchscreen/ipts/context.h
new file mode 100644
index 000000000000..97a6e13c30c5
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/context.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_CONTEXT_H_
+#define _IPTS_CONTEXT_H_
+
+#include <linux/kthread.h>
+#include <linux/input.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/types.h>
+
+#include "devices.h"
+#include "protocol/enums.h"
+#include "protocol/responses.h"
+
+/*
+ * IPTS driver states
+ */
+enum ipts_host_status {
+	IPTS_HOST_STATUS_NONE,
+	IPTS_HOST_STATUS_INIT,
+	IPTS_HOST_STATUS_RESOURCE_READY,
+	IPTS_HOST_STATUS_STARTED,
+	IPTS_HOST_STATUS_STOPPING,
+	IPTS_HOST_STATUS_RESTARTING
+};
+
+struct ipts_buffer_info {
+	u32 size;
+	u8 *address;
+	dma_addr_t dma_address;
+};
+
+struct ipts_context {
+	struct mei_cl_device *client_dev;
+	struct device *dev;
+	struct ipts_device_info device_info;
+	struct ipts_device_config device_cfg;
+
+	enum ipts_host_status status;
+	enum ipts_sensor_mode mode;
+
+	struct ipts_buffer_info touch_data[16];
+	struct ipts_buffer_info feedback[16];
+	struct ipts_buffer_info doorbell;
+
+	/*
+	 * These buffers are not actually used by anything, but they need
+	 * to be allocated and passed to the ME to get proper functionality.
+	 */
+	struct ipts_buffer_info workqueue;
+	struct ipts_buffer_info host2me;
+
+	struct task_struct *receiver_loop;
+	struct task_struct *hid_loop;
+
+	struct input_dev *stylus;
+	struct input_dev *singletouch;
+	u16 stylus_tool;
+};
+
+#endif /* _IPTS_CONTEXT_H_ */
diff --git a/drivers/input/touchscreen/ipts/control.c b/drivers/input/touchscreen/ipts/control.c
new file mode 100644
index 000000000000..66ccea1b0a74
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/control.c
@@ -0,0 +1,93 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/mei_cl_bus.h>
+#include <linux/types.h>
+
+#include "context.h"
+#include "params.h"
+#include "protocol/commands.h"
+#include "protocol/enums.h"
+#include "protocol/events.h"
+#include "protocol/touch.h"
+#include "resources.h"
+
+int ipts_control_send(struct ipts_context *ipts,
+		u32 cmd, void *data, u32 size)
+{
+	int ret;
+	struct ipts_command msg;
+
+	memset(&msg, 0, sizeof(struct ipts_command));
+	msg.code = cmd;
+
+	// Copy message payload
+	if (data && size > 0)
+		memcpy(&msg.data, data, size);
+
+	ret = mei_cldev_send(ipts->client_dev, (u8 *)&msg,
+			sizeof(msg.code) + size);
+	if (ret < 0) {
+		dev_err(ipts->dev, "%s: error 0x%X:%d\n", __func__, cmd, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int ipts_control_send_feedback(struct ipts_context *ipts,
+		u32 buffer, u32 transaction)
+{
+	struct ipts_buffer_info feedback_buffer;
+	struct ipts_feedback *feedback;
+	struct ipts_feedback_cmd cmd;
+
+	feedback_buffer = ipts->feedback[buffer];
+	feedback = (struct ipts_feedback *)feedback_buffer.address;
+
+	memset(feedback, 0, sizeof(struct ipts_feedback));
+	memset(&cmd, 0, sizeof(struct ipts_feedback_cmd));
+
+	feedback->type = IPTS_FEEDBACK_TYPE_NONE;
+	feedback->transaction = transaction;
+
+	cmd.buffer = buffer;
+	cmd.transaction = transaction;
+
+	return ipts_control_send(ipts, IPTS_CMD(FEEDBACK),
+			&cmd, sizeof(struct ipts_feedback_cmd));
+}
+
+int ipts_control_start(struct ipts_context *ipts)
+{
+	ipts->status = IPTS_HOST_STATUS_INIT;
+
+	if (ipts_params.singletouch)
+		ipts->mode = IPTS_SENSOR_MODE_SINGLETOUCH;
+	else
+		ipts->mode = IPTS_SENSOR_MODE_MULTITOUCH;
+
+	return ipts_control_send(ipts, IPTS_CMD(NOTIFY_DEV_READY), NULL, 0);
+}
+
+void ipts_control_stop(struct ipts_context *ipts)
+{
+	enum ipts_host_status old_status = ipts->status;
+
+	ipts->status = IPTS_HOST_STATUS_STOPPING;
+	ipts_control_send(ipts, IPTS_CMD(QUIESCE_IO), NULL, 0);
+	ipts_control_send(ipts, IPTS_CMD(CLEAR_MEM_WINDOW), NULL, 0);
+
+	if (old_status < IPTS_HOST_STATUS_RESOURCE_READY)
+		return;
+
+	ipts_resources_free(ipts);
+}
+
+int ipts_control_restart(struct ipts_context *ipts)
+{
+	dev_info(ipts->dev, "Restarting IPTS\n");
+	ipts_control_stop(ipts);
+
+	ipts->status = IPTS_HOST_STATUS_RESTARTING;
+	return ipts_control_send(ipts, IPTS_CMD(QUIESCE_IO), NULL, 0);
+}
diff --git a/drivers/input/touchscreen/ipts/control.h b/drivers/input/touchscreen/ipts/control.h
new file mode 100644
index 000000000000..e57609c85d62
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/control.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_CONTROL_H_
+#define _IPTS_CONTROL_H_
+
+#include <linux/types.h>
+
+#include "context.h"
+
+int ipts_control_start(struct ipts_context *ipts);
+void ipts_control_stop(struct ipts_context *ipts);
+int ipts_control_restart(struct ipts_context *ipts);
+int ipts_control_send(struct ipts_context *ipts,
+		u32 cmd, void *data, u32 size);
+int ipts_control_send_feedback(struct ipts_context *ipts,
+		u32 buffer, u32 transaction);
+
+#endif /* _IPTS_CONTROL_H_ */
diff --git a/drivers/input/touchscreen/ipts/devices.c b/drivers/input/touchscreen/ipts/devices.c
new file mode 100644
index 000000000000..10593a85e083
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/devices.c
@@ -0,0 +1,46 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#include "devices.h"
+
+static const struct ipts_device_config ipts_devices[] = {
+	{
+		.vendor_id = 0x1B96,
+		.device_id = 0x006A,
+		.max_stylus_pressure = 1024,
+		.stylus_protocol = IPTS_STYLUS_PROTOCOL_GEN1,
+	},
+	{
+		.vendor_id = 0x1B96,
+		.device_id = 0x005e,
+		.max_stylus_pressure = 1024,
+		.stylus_protocol = IPTS_STYLUS_PROTOCOL_GEN1,
+	},
+};
+
+struct ipts_device_config ipts_devices_get_config(u32 vendor, u32 device)
+{
+	int i;
+	struct ipts_device_config cfg;
+
+	for (i = 0; i < ARRAY_SIZE(ipts_devices); i++) {
+		cfg = ipts_devices[i];
+
+		if (cfg.vendor_id != vendor)
+			continue;
+		if (cfg.device_id != device)
+			continue;
+
+		return cfg;
+	}
+
+	// No device was found, so return a default config
+	cfg.vendor_id = vendor;
+	cfg.device_id = device;
+	cfg.max_stylus_pressure = 4096;
+	cfg.stylus_protocol = IPTS_STYLUS_PROTOCOL_GEN2;
+
+	return cfg;
+}
diff --git a/drivers/input/touchscreen/ipts/devices.h b/drivers/input/touchscreen/ipts/devices.h
new file mode 100644
index 000000000000..9bf8da9fbfab
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/devices.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_DEVICES_H_
+#define _IPTS_DEVICES_H_
+
+#include <linux/types.h>
+
+/*
+ * These names describe the different iterations of the IPTS stylus protocol.
+ *
+ * IPTS_STYLUS_PROTOCOL_GEN1 can be found on devices that don't have
+ * support for tilt, and only 1024 pressure levels. (Using NTRIG digitizers)
+ *
+ * IPTS_STYLUS_PROTOCOL_GEN2 can be found on devices that support tilting
+ * the stylus, with 4096 levels of pressure. (Using MS digitizers)
+ *
+ * New generations have to be added as they are discovered.
+ */
+enum ipts_stylus_protocol {
+	IPTS_STYLUS_PROTOCOL_GEN1,
+	IPTS_STYLUS_PROTOCOL_GEN2
+};
+
+struct ipts_device_config {
+	u32 vendor_id;
+	u32 device_id;
+	u32 max_stylus_pressure;
+	enum ipts_stylus_protocol stylus_protocol;
+};
+
+struct ipts_device_config ipts_devices_get_config(u32 vendor, u32 device);
+
+#endif /* _IPTS_DEVICES_H_ */
diff --git a/drivers/input/touchscreen/ipts/hid.c b/drivers/input/touchscreen/ipts/hid.c
new file mode 100644
index 000000000000..c9f27b0e3b75
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/hid.c
@@ -0,0 +1,122 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/kthread.h>
+#include <linux/ktime.h>
+
+#include "context.h"
+#include "control.h"
+#include "hid.h"
+#include "params.h"
+#include "protocol/enums.h"
+#include "protocol/touch.h"
+#include "singletouch.h"
+#include "stylus.h"
+
+static enum ipts_report_type ipts_hid_parse_report_type(
+		struct ipts_context *ipts, struct ipts_touch_data *data)
+{
+	// If the buffer contains HID data, we are in single touch mode
+	if (data->type == IPTS_TOUCH_DATA_TYPE_HID_REPORT)
+		return IPTS_REPORT_TYPE_SINGLETOUCH;
+
+	// If the buffer doesn't contain touch data
+	// we don't care about it
+	if (data->type != IPTS_TOUCH_DATA_TYPE_FRAME)
+		return IPTS_REPORT_TYPE_MAX;
+
+	// If the number 0x6 is written at offset 14,
+	// the report describes a stylus
+	if (data->data[14] == 0x6)
+		return IPTS_REPORT_TYPE_STYLUS;
+
+	return IPTS_REPORT_TYPE_MAX;
+}
+
+static void ipts_hid_handle_input(struct ipts_context *ipts, int buffer_id)
+{
+	struct ipts_buffer_info buffer;
+	struct ipts_touch_data *data;
+
+	buffer = ipts->touch_data[buffer_id];
+	data = (struct ipts_touch_data *)buffer.address;
+
+	if (ipts_params.debug) {
+		dev_info(ipts->dev, "Buffer %d\n", buffer_id);
+		print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 32, 1,
+				data->data, data->size, false);
+	}
+
+	switch (ipts_hid_parse_report_type(ipts, data)) {
+	case IPTS_REPORT_TYPE_STYLUS:
+		ipts_stylus_parse_report(ipts, data);
+		break;
+	case IPTS_REPORT_TYPE_SINGLETOUCH:
+		ipts_singletouch_parse_report(ipts, data);
+		break;
+	case IPTS_REPORT_TYPE_MAX:
+		// ignore
+		break;
+	}
+
+	ipts_control_send_feedback(ipts, buffer_id, data->transaction);
+}
+
+int ipts_hid_loop(void *data)
+{
+	time64_t ll_timeout;
+	u32 doorbell, last_doorbell;
+	struct ipts_context *ipts;
+
+	ll_timeout = ktime_get_seconds() + 5;
+	ipts = (struct ipts_context *)data;
+	last_doorbell = 0;
+	doorbell = 0;
+
+	dev_info(ipts->dev, "Starting input loop\n");
+
+	while (!kthread_should_stop()) {
+		if (ipts->status != IPTS_HOST_STATUS_STARTED) {
+			msleep(1000);
+			continue;
+		}
+
+		// IPTS will increment the doorbell after it filled up
+		// all of the touch data buffers. If the doorbell didn't
+		// change, there is no work for us to do.
+		doorbell = *(u32 *)ipts->doorbell.address;
+		if (doorbell == last_doorbell)
+			goto sleep;
+
+		ll_timeout = ktime_get_seconds() + 5;
+
+		while (last_doorbell != doorbell) {
+			ipts_hid_handle_input(ipts, last_doorbell % 16);
+			last_doorbell++;
+		}
+sleep:
+		if (ll_timeout > ktime_get_seconds())
+			usleep_range(5000, 30000);
+		else
+			msleep(200);
+	}
+
+	dev_info(ipts->dev, "Stopping input loop\n");
+	return 0;
+}
+
+int ipts_hid_init(struct ipts_context *ipts)
+{
+	int ret;
+
+	ret = ipts_stylus_init(ipts);
+	if (ret)
+		return ret;
+
+	ret = ipts_singletouch_init(ipts);
+	if (ret)
+		return ret;
+
+	return 0;
+}
diff --git a/drivers/input/touchscreen/ipts/hid.h b/drivers/input/touchscreen/ipts/hid.h
new file mode 100644
index 000000000000..c6f2ca814c2f
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/hid.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_HID_H_
+#define _IPTS_HID_H_
+
+#include "context.h"
+
+enum ipts_report_type {
+	IPTS_REPORT_TYPE_STYLUS,
+	IPTS_REPORT_TYPE_SINGLETOUCH,
+	IPTS_REPORT_TYPE_MAX
+};
+
+int ipts_hid_init(struct ipts_context *ipts);
+int ipts_hid_loop(void *data);
+
+#endif /* _IPTS_HID_H_ */
diff --git a/drivers/input/touchscreen/ipts/init.c b/drivers/input/touchscreen/ipts/init.c
new file mode 100644
index 000000000000..46f7c7ed1534
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/init.c
@@ -0,0 +1,93 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/dma-mapping.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+
+#include "context.h"
+#include "control.h"
+#include "hid.h"
+#include "receiver.h"
+
+#define IPTS_MEI_UUID UUID_LE(0x3e8d0870, 0x271a, 0x4208, \
+	0x8e, 0xb5, 0x9a, 0xcb, 0x94, 0x02, 0xae, 0x04)
+
+static int ipts_init_probe(struct mei_cl_device *cldev,
+		const struct mei_cl_device_id *id)
+{
+	int ret;
+	struct ipts_context *ipts = NULL;
+
+	dev_info(&cldev->dev, "Probing IPTS\n");
+
+	// Setup the DMA bit mask
+	if (!dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(64))) {
+		dev_info(&cldev->dev, "IPTS using DMA_BIT_MASK(64)\n");
+	} else if (!dma_coerce_mask_and_coherent(&cldev->dev,
+			DMA_BIT_MASK(32))) {
+		dev_info(&cldev->dev, "IPTS using DMA_BIT_MASK(32)");
+	} else {
+		dev_err(&cldev->dev, "No suitable DMA for IPTS available\n");
+		return -EFAULT;
+	}
+
+	ret = mei_cldev_enable(cldev);
+	if (ret) {
+		dev_err(&cldev->dev, "Cannot enable IPTS\n");
+		return ret;
+	}
+
+	ipts = devm_kzalloc(&cldev->dev,
+			sizeof(struct ipts_context), GFP_KERNEL);
+	if (!ipts) {
+		mei_cldev_disable(cldev);
+		return -ENOMEM;
+	}
+
+	ipts->client_dev = cldev;
+	ipts->dev = &cldev->dev;
+
+	mei_cldev_set_drvdata(cldev, ipts);
+
+	ipts->receiver_loop = kthread_run(ipts_receiver_loop, (void *)ipts,
+			"ipts_receiver_loop");
+	ipts->hid_loop = kthread_run(ipts_hid_loop, (void *)ipts,
+			"ipts_hid_loop");
+
+	ipts_control_start(ipts);
+
+	return 0;
+}
+
+static int ipts_init_remove(struct mei_cl_device *cldev)
+{
+	struct ipts_context *ipts = mei_cldev_get_drvdata(cldev);
+
+	dev_info(&cldev->dev, "Removing IPTS\n");
+
+	ipts_control_stop(ipts);
+	mei_cldev_disable(cldev);
+	kthread_stop(ipts->receiver_loop);
+	kthread_stop(ipts->hid_loop);
+
+	return 0;
+}
+
+static struct mei_cl_device_id ipts_device_id[] = {
+	{ "", IPTS_MEI_UUID, MEI_CL_VERSION_ANY },
+	{ },
+};
+MODULE_DEVICE_TABLE(mei, ipts_device_id);
+
+static struct mei_cl_driver ipts_driver = {
+	.id_table = ipts_device_id,
+	.name = "ipts",
+	.probe = ipts_init_probe,
+	.remove = ipts_init_remove,
+};
+module_mei_cl_driver(ipts_driver);
+
+MODULE_DESCRIPTION("IPTS touchscreen driver");
+MODULE_AUTHOR("Dorian Stoll <dorian.stoll@tmsp.io>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/ipts/math.c b/drivers/input/touchscreen/ipts/math.c
new file mode 100644
index 000000000000..df956e5447e0
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/math.c
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/bug.h>
+#include <linux/fixp-arith.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#include "math.h"
+
+/*
+ * Since we need to work with [-pi, pi] in the atan functions, we are using
+ * 1 << 29 for the fixed point numbers. This allows us to store numbers from
+ * [-4, 4] using the full 32-bit signed integer range.
+ *
+ * Some constants such as PI have been already converted to the fixed-point
+ * format and are defined in math.h.
+ */
+
+static inline s32 ipts_math_mul(s32 x, s32 y)
+{
+	return (x * (s64)y) >> 29;
+}
+
+static inline s32 ipts_math_div(s32 x, s32 y)
+{
+	return ((s64)x << 29) / y;
+}
+
+static s32 ipts_math_atan(s32 x)
+{
+	s32 tmp = ipts_math_mul(
+			ipts_math_mul(x, (abs(x) - (1 << 29))),
+			CONST_2447 + ipts_math_mul(CONST_0663, abs(x)));
+
+	return ipts_math_mul(M_PI_4, x) - tmp;
+}
+
+static s32 ipts_math_atan2(s32 y, s32 x)
+{
+	s32 z;
+
+	if (x != 0) {
+		if (abs(x) > abs(y)) {
+			z = ipts_math_div(y, x);
+			if (x > 0)
+				return ipts_math_atan(z);
+			else if (y >= 0)
+				return ipts_math_atan(z) + M_PI;
+			else
+				return ipts_math_atan(z) - M_PI;
+		} else {
+			z = ipts_math_div(x, y);
+			if (y > 0)
+				return -ipts_math_atan(z) + M_PI_2;
+			else
+				return -ipts_math_atan(z) - M_PI_2;
+		}
+	} else {
+		if (y > 0)
+			return M_PI_2;
+		else if (y < 0)
+			return -M_PI_2;
+	}
+
+	return 0;
+}
+
+/*
+ * Convert altitude in range [0, 9000] and azimuth in range [0, 36000]
+ * to x-/y-tilt in range [-9000, 9000]. Azimuth is given
+ * counter-clockwise, starting with zero on the right. Altitude is
+ * given as angle between stylus and z-axis.
+ */
+void ipts_math_altitude_azimuth_to_tilt(s32 alt, s32 azm, s32 *tx, s32 *ty)
+{
+	s32 sin_alt, cos_alt;
+	s32 sin_azm, cos_azm;
+
+	s32 x, y, z;
+	s64 atan_x, atan_y;
+
+	sin_alt = fixp_sin32_rad(alt, 36000) / 4;
+	sin_azm = fixp_sin32_rad(azm, 36000) / 4;
+
+	cos_alt = fixp_cos32_rad(alt, 36000) / 4;
+	cos_azm = fixp_cos32_rad(azm, 36000) / 4;
+
+	x = ipts_math_mul(sin_alt, cos_azm);
+	y = ipts_math_mul(sin_alt, sin_azm);
+	z = cos_alt;
+
+	atan_x = ipts_math_atan2(z, x);
+	atan_y = ipts_math_atan2(z, y);
+
+	atan_x = atan_x * 4500;
+	atan_y = atan_y * 4500;
+
+	atan_x = atan_x / M_PI_4;
+	atan_y = atan_y / M_PI_4;
+
+	*tx = 9000 - atan_x;
+	*ty = atan_y - 9000;
+}
diff --git a/drivers/input/touchscreen/ipts/math.h b/drivers/input/touchscreen/ipts/math.h
new file mode 100644
index 000000000000..8e831074ab60
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/math.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_MATH_H_
+#define _IPTS_MATH_H_
+
+#include <linux/types.h>
+
+/* (pi / 4) * (1 << 29) */
+#define M_PI_4 421657428
+#define M_PI_2 (M_PI_4 * 2)
+#define M_PI   (M_PI_2 * 2)
+
+/* 0.2447 * (1 << 29) */
+#define CONST_2447 131372312
+
+/* 0.0663 * (1 << 29) */
+#define CONST_0663 35594541
+
+void ipts_math_altitude_azimuth_to_tilt(s32 alt, s32 azm, s32 *tx, s32 *ty);
+
+#endif /* _IPTS_MATH_H_ */
diff --git a/drivers/input/touchscreen/ipts/params.c b/drivers/input/touchscreen/ipts/params.c
new file mode 100644
index 000000000000..6aa3f5cf1d76
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/params.c
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/moduleparam.h>
+#include <linux/types.h>
+
+#include "params.h"
+
+#define IPTS_PARM(NAME, TYPE, PERM) \
+	module_param_named(NAME, ipts_params.NAME, TYPE, PERM)
+
+#define IPTS_DESC(NAME, DESC) \
+	MODULE_PARM_DESC(NAME, DESC)
+
+struct ipts_modparams ipts_params = {
+	.debug = false,
+	.singletouch = false,
+};
+
+IPTS_PARM(debug, bool, 0400);
+IPTS_DESC(debug,
+	"Enable additional debugging in the IPTS driver (default: false)"
+);
+
+IPTS_PARM(singletouch, bool, 0400);
+IPTS_DESC(singletouch,
+	"Enables IPTS single touch mode (disables stylus) (default: false)"
+);
diff --git a/drivers/input/touchscreen/ipts/params.h b/drivers/input/touchscreen/ipts/params.h
new file mode 100644
index 000000000000..1f992a3bc21b
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/params.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_PARAMS_H_
+#define _IPTS_PARAMS_H_
+
+#include <linux/types.h>
+
+struct ipts_modparams {
+	bool debug;
+	bool singletouch;
+};
+
+extern struct ipts_modparams ipts_params;
+
+#endif /* _IPTS_PARAMS_H_ */
diff --git a/drivers/input/touchscreen/ipts/protocol/commands.h b/drivers/input/touchscreen/ipts/protocol/commands.h
new file mode 100644
index 000000000000..919a83264d05
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/protocol/commands.h
@@ -0,0 +1,55 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_PROTOCOL_COMMANDS_H_
+#define _IPTS_PROTOCOL_COMMANDS_H_
+
+#include <linux/build_bug.h>
+#include <linux/types.h>
+
+struct ipts_set_mode_cmd {
+	u32 sensor_mode;
+	u8 reserved[12];
+} __packed;
+
+struct ipts_set_mem_window_cmd {
+	u32 touch_data_buffer_addr_lower[16];
+	u32 touch_data_buffer_addr_upper[16];
+	u32 workqueue_addr_lower;
+	u32 workqueue_addr_upper;
+	u32 doorbell_addr_lower;
+	u32 doorbell_addr_upper;
+	u32 feedback_buffer_addr_lower[16];
+	u32 feedback_buffer_addr_upper[16];
+	u32 host2me_addr_lower;
+	u32 host2me_addr_upper;
+	u32 host2me_size;
+	u8 reserved1;
+	u8 workqueue_item_size;
+	u16 workqueue_size;
+	u8 reserved[32];
+} __packed;
+
+struct ipts_feedback_cmd {
+	u32 buffer;
+	u32 transaction;
+	u8 reserved[8];
+} __packed;
+
+/*
+ * Commands are sent from the host to the ME
+ */
+struct ipts_command {
+	u32 code;
+	union {
+		struct ipts_set_mode_cmd set_mode;
+		struct ipts_set_mem_window_cmd set_mem_window;
+		struct ipts_feedback_cmd feedback;
+	} data;
+} __packed;
+
+static_assert(sizeof(struct ipts_set_mode_cmd) == 16);
+static_assert(sizeof(struct ipts_set_mem_window_cmd) == 320);
+static_assert(sizeof(struct ipts_feedback_cmd) == 16);
+static_assert(sizeof(struct ipts_command) == 324);
+
+#endif /* _IPTS_PROTOCOL_COMMANDS_H_ */
diff --git a/drivers/input/touchscreen/ipts/protocol/enums.h b/drivers/input/touchscreen/ipts/protocol/enums.h
new file mode 100644
index 000000000000..ae952c4cf83c
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/protocol/enums.h
@@ -0,0 +1,59 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_PROTOCOL_ENUMS_H_
+#define _IPTS_PROTOCOL_ENUMS_H_
+
+/*
+ * IPTS ME state
+ */
+enum ipts_me_status {
+	IPTS_ME_STATUS_SUCCESS = 0,
+	IPTS_ME_STATUS_INVALID_PARAMS,
+	IPTS_ME_STATUS_ACCESS_DENIED,
+	IPTS_ME_STATUS_CMD_SIZE_ERROR,
+	IPTS_ME_STATUS_NOT_READY,
+	IPTS_ME_STATUS_REQUEST_OUTSTANDING,
+	IPTS_ME_STATUS_NO_SENSOR_FOUND,
+	IPTS_ME_STATUS_OUT_OF_MEMORY,
+	IPTS_ME_STATUS_INTERNAL_ERROR,
+	IPTS_ME_STATUS_SENSOR_DISABLED,
+	IPTS_ME_STATUS_COMPAT_CHECK_FAIL,
+	IPTS_ME_STATUS_SENSOR_EXPECTED_RESET,
+	IPTS_ME_STATUS_SENSOR_UNEXPECTED_RESET,
+	IPTS_ME_STATUS_RESET_FAILED,
+	IPTS_ME_STATUS_TIMEOUT,
+	IPTS_ME_STATUS_TEST_MODE_FAIL,
+	IPTS_ME_STATUS_SENSOR_FAIL_FATAL,
+	IPTS_ME_STATUS_SENSOR_FAIL_NONFATAL,
+	IPTS_ME_STATUS_INVALID_DEVICE_CAPS,
+	IPTS_ME_STATUS_QUIESCE_IO_IN_PROGRESS,
+	IPTS_ME_STATUS_MAX
+};
+
+enum ipts_sensor_mode {
+	IPTS_SENSOR_MODE_SINGLETOUCH = 0,
+	IPTS_SENSOR_MODE_MULTITOUCH,
+	IPTS_SENSOR_MODE_MAX
+};
+
+enum ipts_touch_data_type {
+	IPTS_TOUCH_DATA_TYPE_FRAME = 0,
+	IPTS_TOUCH_DATA_TYPE_ERROR,
+	IPTS_TOUCH_DATA_TYPE_VENDOR_DATA,
+	IPTS_TOUCH_DATA_TYPE_HID_REPORT,
+	IPTS_TOUCH_DATA_TYPE_GET_FEATURES,
+	IPTS_TOUCH_DATA_TYPE_MAX
+};
+
+enum ipts_feedback_type {
+	IPTS_FEEDBACK_TYPE_NONE = 0,
+	IPTS_FEEDBACK_TYPE_SOFT_RESET,
+	IPTS_FEEDBACK_TYPE_GOTO_ARMED,
+	IPTS_FEEDBACK_TYPE_GOTO_SENSING,
+	IPTS_FEEDBACK_TYPE_GOTO_SLEEP,
+	IPTS_FEEDBACK_TYPE_GOTO_DOZE,
+	IPTS_FEEDBACK_TYPE_HARD_RESET,
+	IPTS_FEEDBACK_TYPE_MAX
+};
+
+#endif /* _IPTS_PROTOCOL_ENUMS_H_ */
diff --git a/drivers/input/touchscreen/ipts/protocol/events.h b/drivers/input/touchscreen/ipts/protocol/events.h
new file mode 100644
index 000000000000..f8b771f90bd2
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/protocol/events.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_PROTOCOL_EVENTS_H_
+#define _IPTS_PROTOCOL_EVENTS_H_
+
+/*
+ * Helpers to avoid writing boilerplate code.
+ * The response to a command code is always 0x8000000x, where x
+ * is the command code itself. Instead of writing two definitions,
+ * we use macros to calculate the value on the fly instead.
+ */
+#define IPTS_CMD(COMMAND) IPTS_EVT_##COMMAND
+#define IPTS_RSP(COMMAND) (IPTS_CMD(COMMAND) + 0x80000000)
+
+/*
+ * Events that can be sent to / received from the ME
+ */
+enum ipts_evt_code {
+	IPTS_EVT_GET_DEVICE_INFO = 1,
+	IPTS_EVT_SET_MODE,
+	IPTS_EVT_SET_MEM_WINDOW,
+	IPTS_EVT_QUIESCE_IO,
+	IPTS_EVT_READY_FOR_DATA,
+	IPTS_EVT_FEEDBACK,
+	IPTS_EVT_CLEAR_MEM_WINDOW,
+	IPTS_EVT_NOTIFY_DEV_READY,
+};
+
+#endif /* _IPTS_PROTOCOL_EVENTS_H_ */
diff --git a/drivers/input/touchscreen/ipts/protocol/responses.h b/drivers/input/touchscreen/ipts/protocol/responses.h
new file mode 100644
index 000000000000..7f8902a1486b
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/protocol/responses.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_PROTOCOL_RESPONSES_H_
+#define _IPTS_PROTOCOL_RESPONSES_H_
+
+#include <linux/build_bug.h>
+#include <linux/types.h>
+
+#include "enums.h"
+
+struct ipts_device_info {
+	u16 vendor_id;
+	u16 device_id;
+	u32 hw_rev;
+	u32 fw_rev;
+
+	/* Required size of one touch data buffer */
+	u32 frame_size;
+
+	/* Required size of one feedback buffer */
+	u32 feedback_size;
+	u8 reserved[24];
+} __packed;
+
+/*
+ * Responses are sent from the ME to the host, reacting to a command.
+ */
+struct ipts_response {
+	u32 code;
+	u32 status;
+	union {
+		struct ipts_device_info device_info;
+		u8 reserved[80];
+	} data;
+} __packed;
+
+static_assert(sizeof(struct ipts_device_info) == 44);
+static_assert(sizeof(struct ipts_response) == 88);
+
+#endif /* _IPTS_PROTOCOL_RESPONSES_H_ */
diff --git a/drivers/input/touchscreen/ipts/protocol/touch.h b/drivers/input/touchscreen/ipts/protocol/touch.h
new file mode 100644
index 000000000000..86248c015a2e
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/protocol/touch.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_PROTOCOL_TOUCH_H_
+#define _IPTS_PROTOCOL_TOUCH_H_
+
+#include <linux/types.h>
+
+struct ipts_touch_data {
+	u32 type;
+	u32 size;
+	u32 buffer;
+	u8 reserved1[20];
+	u8 transaction;
+	u8 reserved2[31];
+	u8 data[];
+} __packed;
+
+struct ipts_feedback {
+	u32 type;
+	u32 size;
+	u32 transaction;
+	u8 reserved[52];
+	u8 data[];
+} __packed;
+
+struct ipts_stylus_report {
+	u16 timestamp;
+	u16 mode;
+	u16 x;
+	u16 y;
+	u16 pressure;
+	u16 altitude;
+	u16 azimuth;
+	u16 reserved;
+} __packed;
+
+struct ipts_stylus_report_gen1 {
+	u8 mode;
+	u16 x;
+	u16 y;
+	u16 pressure;
+	u8 reserved[5];
+} __packed;
+
+struct ipts_singletouch_report {
+	u8 touch;
+	u16 x;
+	u16 y;
+} __packed;
+
+#define IPTS_STYLUS_REPORT_MODE_PROXIMITY	BIT(0)
+#define IPTS_STYLUS_REPORT_MODE_TOUCH		BIT(1)
+#define IPTS_STYLUS_REPORT_MODE_BUTTON		BIT(2)
+#define IPTS_STYLUS_REPORT_MODE_RUBBER		BIT(3)
+
+static_assert(sizeof(struct ipts_touch_data) == 64);
+static_assert(sizeof(struct ipts_feedback) == 64);
+static_assert(sizeof(struct ipts_stylus_report) == 16);
+static_assert(sizeof(struct ipts_stylus_report_gen1) == 12);
+static_assert(sizeof(struct ipts_singletouch_report) == 5);
+
+#endif /* _IPTS_PROTOCOL_TOUCH_H_ */
diff --git a/drivers/input/touchscreen/ipts/receiver.c b/drivers/input/touchscreen/ipts/receiver.c
new file mode 100644
index 000000000000..06f4509ff1c4
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/receiver.c
@@ -0,0 +1,266 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/types.h>
+
+#include "context.h"
+#include "control.h"
+#include "hid.h"
+#include "protocol/commands.h"
+#include "protocol/enums.h"
+#include "protocol/events.h"
+#include "protocol/responses.h"
+#include "resources.h"
+
+static void ipts_receiver_handle_notify_dev_ready(struct ipts_context *ipts,
+		struct ipts_response *msg, int *cmd_status)
+{
+	if (msg->status != IPTS_ME_STATUS_SENSOR_FAIL_NONFATAL &&
+			msg->status != IPTS_ME_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "0x%08x failed - status = %d\n",
+				msg->code, msg->status);
+		return;
+	}
+
+	*cmd_status = ipts_control_send(ipts,
+			IPTS_CMD(GET_DEVICE_INFO), NULL, 0);
+}
+
+static void ipts_receiver_handle_get_device_info(struct ipts_context *ipts,
+		struct ipts_response *msg, int *cmd_status)
+{
+	if (msg->status != IPTS_ME_STATUS_COMPAT_CHECK_FAIL &&
+			msg->status != IPTS_ME_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "0x%08x failed - status = %d\n",
+				msg->code, msg->status);
+		return;
+	}
+
+	memcpy(&ipts->device_info, &msg->data.device_info,
+			sizeof(struct ipts_device_info));
+
+	dev_info(ipts->dev, "Device %04hX:%04hX found\n",
+			ipts->device_info.vendor_id,
+			ipts->device_info.device_id);
+
+	ipts->device_cfg = ipts_devices_get_config(ipts->device_info.vendor_id,
+			ipts->device_info.device_id);
+
+	if (ipts_hid_init(ipts))
+		return;
+
+	*cmd_status = ipts_control_send(ipts,
+			IPTS_CMD(CLEAR_MEM_WINDOW), NULL, 0);
+}
+
+static void ipts_receiver_handle_clear_mem_window(struct ipts_context *ipts,
+		struct ipts_response *msg, int *cmd_status, int *ret)
+{
+	struct ipts_set_mode_cmd sensor_mode_cmd;
+
+	if (msg->status != IPTS_ME_STATUS_TIMEOUT &&
+			msg->status != IPTS_ME_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "0x%08x failed - status = %d\n",
+				msg->code, msg->status);
+		return;
+	}
+
+	if (ipts->status == IPTS_HOST_STATUS_STOPPING)
+		return;
+
+	if (ipts_resources_init(ipts))
+		return;
+
+	ipts->status = IPTS_HOST_STATUS_RESOURCE_READY;
+
+	memset(&sensor_mode_cmd, 0, sizeof(struct ipts_set_mode_cmd));
+	sensor_mode_cmd.sensor_mode = ipts->mode;
+
+	*cmd_status = ipts_control_send(ipts, IPTS_CMD(SET_MODE),
+			&sensor_mode_cmd, sizeof(struct ipts_set_mode_cmd));
+}
+
+static void ipts_receiver_handle_set_mode(struct ipts_context *ipts,
+		struct ipts_response *msg, int *cmd_status)
+{
+	int i;
+	struct ipts_set_mem_window_cmd cmd;
+
+	if (msg->status != IPTS_ME_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "0x%08x failed - status = %d\n",
+				msg->code, msg->status);
+		return;
+	}
+
+	memset(&cmd, 0, sizeof(struct ipts_set_mem_window_cmd));
+
+	for (i = 0; i < 16; i++) {
+		cmd.touch_data_buffer_addr_lower[i] =
+			lower_32_bits(ipts->touch_data[i].dma_address);
+
+		cmd.touch_data_buffer_addr_upper[i] =
+			upper_32_bits(ipts->touch_data[i].dma_address);
+
+		cmd.feedback_buffer_addr_lower[i] =
+			lower_32_bits(ipts->feedback[i].dma_address);
+
+		cmd.feedback_buffer_addr_upper[i] =
+			upper_32_bits(ipts->feedback[i].dma_address);
+	}
+
+	cmd.workqueue_addr_lower = lower_32_bits(ipts->workqueue.dma_address);
+	cmd.workqueue_addr_upper = upper_32_bits(ipts->workqueue.dma_address);
+
+	cmd.doorbell_addr_lower = lower_32_bits(ipts->doorbell.dma_address);
+	cmd.doorbell_addr_upper = upper_32_bits(ipts->doorbell.dma_address);
+
+	cmd.host2me_addr_lower = lower_32_bits(ipts->host2me.dma_address);
+	cmd.host2me_addr_upper = upper_32_bits(ipts->host2me.dma_address);
+	cmd.host2me_size = ipts->device_info.frame_size;
+
+	cmd.workqueue_size = 8192;
+	cmd.workqueue_item_size = 16;
+
+	*cmd_status = ipts_control_send(ipts, IPTS_CMD(SET_MEM_WINDOW),
+			&cmd, sizeof(struct ipts_set_mem_window_cmd));
+}
+
+static void ipts_receiver_handle_set_mem_window(struct ipts_context *ipts,
+		struct ipts_response *msg, int *cmd_status)
+{
+	if (msg->status != IPTS_ME_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "0x%08x failed - status = %d\n",
+				msg->code, msg->status);
+		return;
+	}
+
+	*cmd_status = ipts_control_send(ipts,
+			IPTS_CMD(READY_FOR_DATA), NULL, 0);
+	if (*cmd_status)
+		return;
+
+	ipts->status = IPTS_HOST_STATUS_STARTED;
+	dev_info(ipts->dev, "IPTS enabled\n");
+}
+
+static void ipts_receiver_handle_ready_for_data(struct ipts_context *ipts,
+		struct ipts_response *msg)
+{
+	if (msg->status != IPTS_ME_STATUS_SENSOR_DISABLED &&
+			msg->status != IPTS_ME_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "0x%08x failed - status = %d\n",
+				msg->code, msg->status);
+		return;
+	}
+
+	if (ipts->mode != IPTS_SENSOR_MODE_SINGLETOUCH ||
+			ipts->status != IPTS_HOST_STATUS_STARTED)
+		return;
+
+	// Increment the doorbell manually to indicate that a new buffer
+	// filled with touch data is available
+	*((u32 *)ipts->doorbell.address) += 1;
+}
+
+static void ipts_recever_handle_feedback(struct ipts_context *ipts,
+		struct ipts_response *msg, int *cmd_status)
+{
+	if (msg->status != IPTS_ME_STATUS_COMPAT_CHECK_FAIL &&
+			msg->status != IPTS_ME_STATUS_SUCCESS &&
+			msg->status != IPTS_ME_STATUS_INVALID_PARAMS) {
+		dev_err(ipts->dev, "0x%08x failed - status = %d\n",
+				msg->code, msg->status);
+		return;
+	}
+
+	if (ipts->mode != IPTS_SENSOR_MODE_SINGLETOUCH)
+		return;
+
+	*cmd_status = ipts_control_send(ipts,
+			IPTS_CMD(READY_FOR_DATA), NULL, 0);
+}
+
+static void ipts_receiver_handle_quiesce_io(struct ipts_context *ipts,
+		struct ipts_response *msg)
+{
+	if (msg->status != IPTS_ME_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "0x%08x failed - status = %d\n",
+				msg->code, msg->status);
+		return;
+	}
+
+	if (ipts->status == IPTS_HOST_STATUS_RESTARTING)
+		ipts_control_start(ipts);
+}
+
+
+static int ipts_receiver_handle_response(struct ipts_context *ipts,
+		struct ipts_response *msg, u32 msg_len)
+{
+	int cmd_status = 0;
+	int ret = 0;
+
+	switch (msg->code) {
+	case IPTS_RSP(NOTIFY_DEV_READY):
+		ipts_receiver_handle_notify_dev_ready(ipts, msg, &cmd_status);
+		break;
+	case IPTS_RSP(GET_DEVICE_INFO):
+		ipts_receiver_handle_get_device_info(ipts, msg, &cmd_status);
+		break;
+	case IPTS_RSP(CLEAR_MEM_WINDOW):
+		ipts_receiver_handle_clear_mem_window(ipts, msg,
+				&cmd_status, &ret);
+		break;
+	case IPTS_RSP(SET_MODE):
+		ipts_receiver_handle_set_mode(ipts, msg, &cmd_status);
+		break;
+	case IPTS_RSP(SET_MEM_WINDOW):
+		ipts_receiver_handle_set_mem_window(ipts, msg, &cmd_status);
+		break;
+	case IPTS_RSP(READY_FOR_DATA):
+		ipts_receiver_handle_ready_for_data(ipts, msg);
+		break;
+	case IPTS_RSP(FEEDBACK):
+		ipts_recever_handle_feedback(ipts, msg, &cmd_status);
+		break;
+	case IPTS_RSP(QUIESCE_IO):
+		ipts_receiver_handle_quiesce_io(ipts, msg);
+		break;
+	}
+
+	if (msg->status == IPTS_ME_STATUS_SENSOR_UNEXPECTED_RESET ||
+			msg->status == IPTS_ME_STATUS_SENSOR_EXPECTED_RESET) {
+		dev_info(ipts->dev, "Sensor has been reset: %d\n", msg->status);
+		ipts_control_restart(ipts);
+	}
+
+	if (cmd_status)
+		ipts_control_restart(ipts);
+
+	return ret;
+}
+
+int ipts_receiver_loop(void *data)
+{
+	u32 msg_len;
+	struct ipts_context *ipts;
+	struct ipts_response msg;
+
+	ipts = (struct ipts_context *)data;
+	dev_info(ipts->dev, "Starting receive loop\n");
+
+	while (!kthread_should_stop()) {
+		msg_len = mei_cldev_recv(ipts->client_dev,
+			(u8 *)&msg, sizeof(msg));
+
+		if (msg_len <= 0) {
+			dev_err(ipts->dev, "Error in reading ME message\n");
+			continue;
+		}
+
+		if (ipts_receiver_handle_response(ipts, &msg, msg_len))
+			dev_err(ipts->dev, "Error in handling ME message\n");
+	}
+
+	dev_info(ipts->dev, "Stopping receive loop\n");
+	return 0;
+}
diff --git a/drivers/input/touchscreen/ipts/receiver.h b/drivers/input/touchscreen/ipts/receiver.h
new file mode 100644
index 000000000000..4d413a0abd4c
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/receiver.h
@@ -0,0 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_RECEIVER_H_
+#define _IPTS_RECEIVER_H_
+
+int ipts_receiver_loop(void *data);
+
+#endif /* _IPTS_RECEIVER_H_ */
diff --git a/drivers/input/touchscreen/ipts/resources.c b/drivers/input/touchscreen/ipts/resources.c
new file mode 100644
index 000000000000..b4bec3cb63fd
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/resources.c
@@ -0,0 +1,131 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/dma-mapping.h>
+
+#include "context.h"
+
+void ipts_resources_free(struct ipts_context *ipts)
+{
+	int i;
+	u32 touch_buffer_size;
+	u32 feedback_buffer_size;
+	struct ipts_buffer_info *buffers;
+
+	touch_buffer_size = ipts->device_info.frame_size;
+	feedback_buffer_size = ipts->device_info.feedback_size;
+
+	buffers = ipts->touch_data;
+	for (i = 0; i < 16; i++) {
+		if (!buffers[i].address)
+			continue;
+
+		dmam_free_coherent(ipts->dev, touch_buffer_size,
+				buffers[i].address, buffers[i].dma_address);
+
+		buffers[i].address = 0;
+		buffers[i].dma_address = 0;
+	}
+
+	buffers = ipts->feedback;
+	for (i = 0; i < 16; i++) {
+		if (!buffers[i].address)
+			continue;
+
+		dmam_free_coherent(ipts->dev, feedback_buffer_size,
+				buffers[i].address, buffers[i].dma_address);
+
+		buffers[i].address = 0;
+		buffers[i].dma_address = 0;
+	}
+
+	if (ipts->doorbell.address) {
+		dmam_free_coherent(ipts->dev, sizeof(u32),
+				ipts->doorbell.address,
+				ipts->doorbell.dma_address);
+
+		ipts->doorbell.address = 0;
+		ipts->doorbell.dma_address = 0;
+	}
+
+	if (ipts->workqueue.address) {
+		dmam_free_coherent(ipts->dev, sizeof(u32),
+				ipts->workqueue.address,
+				ipts->workqueue.dma_address);
+
+		ipts->workqueue.address = 0;
+		ipts->workqueue.dma_address = 0;
+	}
+
+	if (ipts->host2me.address) {
+		dmam_free_coherent(ipts->dev, touch_buffer_size,
+				ipts->host2me.address,
+				ipts->host2me.dma_address);
+
+		ipts->host2me.address = 0;
+		ipts->host2me.dma_address = 0;
+	}
+}
+
+int ipts_resources_init(struct ipts_context *ipts)
+{
+	int i;
+	u32 touch_buffer_size;
+	u32 feedback_buffer_size;
+	struct ipts_buffer_info *buffers;
+
+	touch_buffer_size = ipts->device_info.frame_size;
+	feedback_buffer_size = ipts->device_info.feedback_size;
+
+	buffers = ipts->touch_data;
+	for (i = 0; i < 16; i++) {
+		buffers[i].address = dmam_alloc_coherent(ipts->dev,
+				touch_buffer_size,
+				&buffers[i].dma_address,
+				GFP_ATOMIC | __GFP_ZERO);
+
+		if (!buffers[i].address)
+			goto release_resources;
+	}
+
+	buffers = ipts->feedback;
+	for (i = 0; i < 16; i++) {
+		buffers[i].address = dmam_alloc_coherent(ipts->dev,
+				feedback_buffer_size,
+				&buffers[i].dma_address,
+				GFP_ATOMIC | __GFP_ZERO);
+
+		if (!buffers[i].address)
+			goto release_resources;
+	}
+
+	ipts->doorbell.address = dmam_alloc_coherent(ipts->dev,
+			sizeof(u32),
+			&ipts->doorbell.dma_address,
+			GFP_ATOMIC | __GFP_ZERO);
+
+	if (!ipts->doorbell.address)
+		goto release_resources;
+
+	ipts->workqueue.address = dmam_alloc_coherent(ipts->dev,
+			sizeof(u32),
+			&ipts->workqueue.dma_address,
+			GFP_ATOMIC | __GFP_ZERO);
+
+	if (!ipts->workqueue.address)
+		goto release_resources;
+
+	ipts->host2me.address = dmam_alloc_coherent(ipts->dev,
+			touch_buffer_size,
+			&ipts->host2me.dma_address,
+			GFP_ATOMIC | __GFP_ZERO);
+
+	if (!ipts->workqueue.address)
+		goto release_resources;
+
+	return 0;
+
+release_resources:
+
+	ipts_resources_free(ipts);
+	return -ENOMEM;
+}
diff --git a/drivers/input/touchscreen/ipts/resources.h b/drivers/input/touchscreen/ipts/resources.h
new file mode 100644
index 000000000000..cf9807b0dbe6
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/resources.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_RESOURCES_H_
+#define _IPTS_RESOURCES_H_
+
+#include "context.h"
+
+int ipts_resources_init(struct ipts_context *ipts);
+void ipts_resources_free(struct ipts_context *ipts);
+
+#endif /* _IPTS_RESOURCES_H_ */
diff --git a/drivers/input/touchscreen/ipts/singletouch.c b/drivers/input/touchscreen/ipts/singletouch.c
new file mode 100644
index 000000000000..237dd89f5816
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/singletouch.c
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/kernel.h>
+
+#include "context.h"
+#include "protocol/enums.h"
+#include "protocol/touch.h"
+
+void ipts_singletouch_parse_report(struct ipts_context *ipts,
+		struct ipts_touch_data *data)
+{
+	struct ipts_singletouch_report *report =
+		(struct ipts_singletouch_report *)&data->data[1];
+
+	input_report_key(ipts->singletouch, BTN_TOUCH, report->touch);
+	input_report_abs(ipts->singletouch, ABS_X, report->x);
+	input_report_abs(ipts->singletouch, ABS_Y, report->y);
+
+	input_sync(ipts->singletouch);
+}
+
+int ipts_singletouch_init(struct ipts_context *ipts)
+{
+	int ret;
+
+	ipts->singletouch = devm_input_allocate_device(ipts->dev);
+	if (!ipts->singletouch)
+		return -ENOMEM;
+
+	__set_bit(INPUT_PROP_DIRECT, ipts->singletouch->propbit);
+
+	input_set_capability(ipts->singletouch, EV_KEY, BTN_TOUCH);
+	input_set_abs_params(ipts->singletouch, ABS_X, 0, 32767, 0, 0);
+	input_abs_set_res(ipts->singletouch, ABS_X, 112);
+	input_set_abs_params(ipts->singletouch, ABS_Y, 0, 32767, 0, 0);
+	input_abs_set_res(ipts->singletouch, ABS_Y, 199);
+
+	ipts->singletouch->id.bustype = BUS_MEI;
+	ipts->singletouch->id.vendor = ipts->device_info.vendor_id;
+	ipts->singletouch->id.product = ipts->device_info.device_id;
+	ipts->singletouch->id.version = ipts->device_info.fw_rev;
+
+	ipts->singletouch->phys = "heci3";
+	ipts->singletouch->name = "Intel Precise Touchscreen (Singletouch)";
+
+	ret = input_register_device(ipts->singletouch);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to register touch device: %d\n",
+				ret);
+		return ret;
+	}
+
+	return 0;
+}
diff --git a/drivers/input/touchscreen/ipts/singletouch.h b/drivers/input/touchscreen/ipts/singletouch.h
new file mode 100644
index 000000000000..6bcaf939c8e3
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/singletouch.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_SINGLETOUCH_H_
+#define _IPTS_SINGLETOUCH_H_
+
+#include "context.h"
+#include "protocol/touch.h"
+
+void ipts_singletouch_parse_report(struct ipts_context *ipts,
+		struct ipts_touch_data *data);
+int ipts_singletouch_init(struct ipts_context *ipts);
+
+#endif /* _IPTS_SINGLETOUCH_H_ */
diff --git a/drivers/input/touchscreen/ipts/stylus.c b/drivers/input/touchscreen/ipts/stylus.c
new file mode 100644
index 000000000000..263aa133b706
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/stylus.c
@@ -0,0 +1,159 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <asm/fpu/api.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+
+#include "context.h"
+#include "devices.h"
+#include "math.h"
+#include "protocol/enums.h"
+#include "protocol/touch.h"
+
+static void ipts_stylus_handle_report(struct ipts_context *ipts,
+		struct ipts_stylus_report *report)
+{
+	u16 tool;
+	u8 prox = report->mode & IPTS_STYLUS_REPORT_MODE_PROXIMITY;
+	u8 touch = report->mode & IPTS_STYLUS_REPORT_MODE_TOUCH;
+	u8 button = report->mode & IPTS_STYLUS_REPORT_MODE_BUTTON;
+	u8 rubber = report->mode & IPTS_STYLUS_REPORT_MODE_RUBBER;
+
+	s32 tx = 0;
+	s32 ty = 0;
+
+	// avoid unnecessary computations
+	// altitude is zero if stylus does not touch the screen
+	if (report->altitude) {
+		ipts_math_altitude_azimuth_to_tilt(report->altitude,
+				report->azimuth, &tx, &ty);
+	}
+
+	if (prox && rubber)
+		tool = BTN_TOOL_RUBBER;
+	else
+		tool = BTN_TOOL_PEN;
+
+	// Fake proximity out to switch tools
+	if (ipts->stylus_tool != tool) {
+		input_report_key(ipts->stylus, ipts->stylus_tool, 0);
+		input_sync(ipts->stylus);
+		ipts->stylus_tool = tool;
+	}
+
+	input_report_key(ipts->stylus, BTN_TOUCH, touch);
+	input_report_key(ipts->stylus, ipts->stylus_tool, prox);
+	input_report_key(ipts->stylus, BTN_STYLUS, button);
+
+	input_report_abs(ipts->stylus, ABS_X, report->x);
+	input_report_abs(ipts->stylus, ABS_Y, report->y);
+	input_report_abs(ipts->stylus, ABS_PRESSURE, report->pressure);
+	input_report_abs(ipts->stylus, ABS_MISC, report->timestamp);
+
+	input_report_abs(ipts->stylus, ABS_TILT_X, tx);
+	input_report_abs(ipts->stylus, ABS_TILT_Y, ty);
+
+	input_sync(ipts->stylus);
+}
+
+static void ipts_stylus_parse_report_gen1(struct ipts_context *ipts,
+		struct ipts_touch_data *data)
+{
+	u8 count, i;
+	struct ipts_stylus_report report;
+	struct ipts_stylus_report_gen1 *reports;
+
+	count = data->data[32];
+	reports = (struct ipts_stylus_report_gen1 *)&data->data[44];
+
+	for (i = 0; i < count; i++) {
+		report.mode = reports[i].mode;
+		report.x = reports[i].x;
+		report.y = reports[i].y;
+		report.pressure = reports[i].pressure;
+
+		// The gen1 protocol doesn't support tilting the stylus
+		report.altitude = 0;
+		report.azimuth = 0;
+
+		// Use the buffer ID to emulate a timestamp
+		report.timestamp = data->buffer;
+
+		ipts_stylus_handle_report(ipts, &report);
+	}
+}
+
+static void ipts_stylus_parse_report_gen2(struct ipts_context *ipts,
+		struct ipts_touch_data *data)
+{
+	u8 count, i;
+	struct ipts_stylus_report *reports;
+
+	count = data->data[32];
+	reports = (struct ipts_stylus_report *)&data->data[40];
+
+	for (i = 0; i < count; i++)
+		ipts_stylus_handle_report(ipts, &reports[i]);
+}
+
+void ipts_stylus_parse_report(struct ipts_context *ipts,
+		struct ipts_touch_data *data)
+{
+	switch (ipts->device_cfg.stylus_protocol) {
+	case IPTS_STYLUS_PROTOCOL_GEN1:
+		ipts_stylus_parse_report_gen1(ipts, data);
+		break;
+	case IPTS_STYLUS_PROTOCOL_GEN2:
+		ipts_stylus_parse_report_gen2(ipts, data);
+		break;
+	}
+}
+
+int ipts_stylus_init(struct ipts_context *ipts)
+{
+	int ret;
+	u16 pressure;
+
+	ipts->stylus = devm_input_allocate_device(ipts->dev);
+	if (!ipts->stylus)
+		return -ENOMEM;
+
+	pressure = ipts->device_cfg.max_stylus_pressure;
+
+	ipts->stylus_tool = BTN_TOOL_PEN;
+
+	__set_bit(INPUT_PROP_DIRECT, ipts->stylus->propbit);
+	__set_bit(INPUT_PROP_POINTER, ipts->stylus->propbit);
+
+	input_set_abs_params(ipts->stylus, ABS_X, 0, 9600, 0, 0);
+	input_abs_set_res(ipts->stylus, ABS_X, 34);
+	input_set_abs_params(ipts->stylus, ABS_Y, 0, 7200, 0, 0);
+	input_abs_set_res(ipts->stylus, ABS_Y, 38);
+	input_set_abs_params(ipts->stylus, ABS_PRESSURE, 0, pressure, 0, 0);
+	input_set_abs_params(ipts->stylus, ABS_TILT_X, -9000, 9000, 0, 0);
+	input_abs_set_res(ipts->stylus, ABS_TILT_X, 5730);
+	input_set_abs_params(ipts->stylus, ABS_TILT_Y, -9000, 9000, 0, 0);
+	input_abs_set_res(ipts->stylus, ABS_TILT_Y, 5730);
+	input_set_abs_params(ipts->stylus, ABS_MISC, 0, 65535, 0, 0);
+	input_set_capability(ipts->stylus, EV_KEY, BTN_TOUCH);
+	input_set_capability(ipts->stylus, EV_KEY, BTN_STYLUS);
+	input_set_capability(ipts->stylus, EV_KEY, BTN_TOOL_PEN);
+	input_set_capability(ipts->stylus, EV_KEY, BTN_TOOL_RUBBER);
+
+	ipts->stylus->id.bustype = BUS_MEI;
+	ipts->stylus->id.vendor = ipts->device_info.vendor_id;
+	ipts->stylus->id.product = ipts->device_info.device_id;
+	ipts->stylus->id.version = ipts->device_info.fw_rev;
+
+	ipts->stylus->phys = "heci3";
+	ipts->stylus->name = "Intel Precise Stylus";
+
+	ret = input_register_device(ipts->stylus);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to register stylus device: %d\n",
+				ret);
+		return ret;
+	}
+
+	return 0;
+}
diff --git a/drivers/input/touchscreen/ipts/stylus.h b/drivers/input/touchscreen/ipts/stylus.h
new file mode 100644
index 000000000000..3b6424ade542
--- /dev/null
+++ b/drivers/input/touchscreen/ipts/stylus.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef _IPTS_STYLUS_H_
+#define _IPTS_STYLUS_H_
+
+#include "context.h"
+#include "protocol/touch.h"
+
+void ipts_stylus_parse_report(struct ipts_context *ipts,
+		struct ipts_touch_data *data);
+int ipts_stylus_init(struct ipts_context *ipts);
+
+#endif /* _IPTS_STYLUS_H_ */
diff --git a/drivers/misc/mei/hw-me-regs.h b/drivers/misc/mei/hw-me-regs.h
index 7cd67fb2365d..b6c685e861f9 100644
--- a/drivers/misc/mei/hw-me-regs.h
+++ b/drivers/misc/mei/hw-me-regs.h
@@ -59,6 +59,7 @@
 
 #define MEI_DEV_ID_SPT        0x9D3A  /* Sunrise Point */
 #define MEI_DEV_ID_SPT_2      0x9D3B  /* Sunrise Point 2 */
+#define MEI_DEV_ID_SPT_4      0x9D3E  /* Sunrise Point 4 (iTouch) */
 #define MEI_DEV_ID_SPT_H      0xA13A  /* Sunrise Point H */
 #define MEI_DEV_ID_SPT_H_2    0xA13B  /* Sunrise Point H 2 */
 
@@ -84,6 +85,7 @@
 #define MEI_DEV_ID_CMP_V      0xA3BA  /* Comet Point Lake V */
 
 #define MEI_DEV_ID_ICP_LP     0x34E0  /* Ice Lake Point LP */
+#define MEI_DEV_ID_ICP_LP_4   0x34E4  /* Ice Lake Point LP 4 (iTouch) */
 
 #define MEI_DEV_ID_TGP_LP     0xA0E0  /* Tiger Lake Point LP */
 
diff --git a/drivers/misc/mei/pci-me.c b/drivers/misc/mei/pci-me.c
index c845b7e40f26..0d1a13bb406a 100644
--- a/drivers/misc/mei/pci-me.c
+++ b/drivers/misc/mei/pci-me.c
@@ -77,6 +77,7 @@ static const struct pci_device_id mei_me_pci_tbl[] = {
 
 	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT, MEI_ME_PCH8_CFG)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_2, MEI_ME_PCH8_CFG)},
+	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_4, MEI_ME_PCH8_CFG)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_H, MEI_ME_PCH8_SPS_CFG)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_SPT_H_2, MEI_ME_PCH8_SPS_CFG)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_LBG, MEI_ME_PCH12_CFG)},
@@ -101,6 +102,7 @@ static const struct pci_device_id mei_me_pci_tbl[] = {
 	{MEI_PCI_DEVICE(MEI_DEV_ID_CMP_V, MEI_ME_PCH12_CFG)},
 
 	{MEI_PCI_DEVICE(MEI_DEV_ID_ICP_LP, MEI_ME_PCH12_CFG)},
+	{MEI_PCI_DEVICE(MEI_DEV_ID_ICP_LP_4, MEI_ME_PCH12_CFG)},
 
 	{MEI_PCI_DEVICE(MEI_DEV_ID_TGP_LP, MEI_ME_PCH15_CFG)},
 
diff --git a/include/uapi/linux/input.h b/include/uapi/linux/input.h
index 9a61c28ed3ae..47fc20975245 100644
--- a/include/uapi/linux/input.h
+++ b/include/uapi/linux/input.h
@@ -271,6 +271,7 @@ struct input_mask {
 #define BUS_RMI			0x1D
 #define BUS_CEC			0x1E
 #define BUS_INTEL_ISHTP		0x1F
+#define BUS_MEI			0x44
 
 /*
  * MT_TOOL types
-- 
2.25.0

