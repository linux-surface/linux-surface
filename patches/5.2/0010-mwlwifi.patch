From 3a34928359985f56d92bc287a45b9d23bddcbb89 Mon Sep 17 00:00:00 2001
From: Maximilian Luz <luzmaximilian@gmail.com>
Date: Fri, 26 Jul 2019 04:47:02 +0200
Subject: [PATCH 10/12] mwlwifi

---
 drivers/net/wireless/marvell/Kconfig          |    1 +
 drivers/net/wireless/marvell/Makefile         |    1 +
 drivers/net/wireless/marvell/mwlwifi/Kconfig  |   23 +
 drivers/net/wireless/marvell/mwlwifi/Makefile |   19 +
 .../wireless/marvell/mwlwifi/Makefile.module  |   28 +
 .../net/wireless/marvell/mwlwifi/README.md    |  142 +
 drivers/net/wireless/marvell/mwlwifi/core.c   | 1086 +++++
 drivers/net/wireless/marvell/mwlwifi/core.h   |  517 +++
 .../net/wireless/marvell/mwlwifi/debugfs.c    | 2201 ++++++++++
 .../net/wireless/marvell/mwlwifi/debugfs.h    |   24 +
 .../net/wireless/marvell/mwlwifi/hif/fwcmd.c  | 3852 +++++++++++++++++
 .../net/wireless/marvell/mwlwifi/hif/fwcmd.h  |  285 ++
 .../wireless/marvell/mwlwifi/hif/hif-ops.h    |  297 ++
 .../net/wireless/marvell/mwlwifi/hif/hif.h    |   81 +
 .../wireless/marvell/mwlwifi/hif/hostcmd.h    | 1285 ++++++
 .../wireless/marvell/mwlwifi/hif/pcie/dev.h   | 1032 +++++
 .../wireless/marvell/mwlwifi/hif/pcie/fwdl.c  |  274 ++
 .../wireless/marvell/mwlwifi/hif/pcie/fwdl.h  |   24 +
 .../wireless/marvell/mwlwifi/hif/pcie/pcie.c  | 1645 +++++++
 .../wireless/marvell/mwlwifi/hif/pcie/rx.c    |  540 +++
 .../wireless/marvell/mwlwifi/hif/pcie/rx.h    |   25 +
 .../marvell/mwlwifi/hif/pcie/rx_ndp.c         |  612 +++
 .../marvell/mwlwifi/hif/pcie/rx_ndp.h         |   26 +
 .../marvell/mwlwifi/hif/pcie/sc4_ddr.h        |  965 +++++
 .../wireless/marvell/mwlwifi/hif/pcie/tx.c    | 1396 ++++++
 .../wireless/marvell/mwlwifi/hif/pcie/tx.h    |   38 +
 .../marvell/mwlwifi/hif/pcie/tx_ndp.c         |  693 +++
 .../marvell/mwlwifi/hif/pcie/tx_ndp.h         |   30 +
 ...-workaround-for-80+80-and-160-MHz-channels |   32 +
 .../wireless/marvell/mwlwifi/hostapd/README   |   26 +
 .../net/wireless/marvell/mwlwifi/mac80211.c   |  933 ++++
 .../net/wireless/marvell/mwlwifi/mu_mimo.c    |   21 +
 .../net/wireless/marvell/mwlwifi/mu_mimo.h    |   23 +
 .../net/wireless/marvell/mwlwifi/sysadpt.h    |   86 +
 .../net/wireless/marvell/mwlwifi/thermal.c    |  182 +
 .../net/wireless/marvell/mwlwifi/thermal.h    |   42 +
 drivers/net/wireless/marvell/mwlwifi/utils.c  |  576 +++
 drivers/net/wireless/marvell/mwlwifi/utils.h  |  158 +
 .../net/wireless/marvell/mwlwifi/vendor_cmd.c |  136 +
 .../net/wireless/marvell/mwlwifi/vendor_cmd.h |   60 +
 40 files changed, 19417 insertions(+)
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/Kconfig
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/Makefile
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/Makefile.module
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/README.md
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/core.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/core.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/debugfs.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/debugfs.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/fwcmd.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/fwcmd.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/hif-ops.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/hif.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/hostcmd.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/dev.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/fwdl.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/fwdl.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/pcie.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx_ndp.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx_ndp.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/sc4_ddr.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx_ndp.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx_ndp.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hostapd/700-interoperability-workaround-for-80+80-and-160-MHz-channels
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/hostapd/README
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/mac80211.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/mu_mimo.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/mu_mimo.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/sysadpt.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/thermal.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/thermal.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/utils.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/utils.h
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/vendor_cmd.c
 create mode 100644 drivers/net/wireless/marvell/mwlwifi/vendor_cmd.h

diff --git a/drivers/net/wireless/marvell/Kconfig b/drivers/net/wireless/marvell/Kconfig
index dff82fdbea78..c0790dbd52c0 100644
--- a/drivers/net/wireless/marvell/Kconfig
+++ b/drivers/net/wireless/marvell/Kconfig
@@ -15,6 +15,7 @@ if WLAN_VENDOR_MARVELL
 source "drivers/net/wireless/marvell/libertas/Kconfig"
 source "drivers/net/wireless/marvell/libertas_tf/Kconfig"
 source "drivers/net/wireless/marvell/mwifiex/Kconfig"
+source "drivers/net/wireless/marvell/mwlwifi/Kconfig"
 
 config MWL8K
 	tristate "Marvell 88W8xxx PCI/PCIe Wireless support"
diff --git a/drivers/net/wireless/marvell/Makefile b/drivers/net/wireless/marvell/Makefile
index 25f6d5d2fa0c..00fccce28cdd 100644
--- a/drivers/net/wireless/marvell/Makefile
+++ b/drivers/net/wireless/marvell/Makefile
@@ -3,5 +3,6 @@ obj-$(CONFIG_LIBERTAS)		+= libertas/
 
 obj-$(CONFIG_LIBERTAS_THINFIRM)	+= libertas_tf/
 obj-$(CONFIG_MWIFIEX)	+= mwifiex/
+obj-$(CONFIG_MWLWIFI)	+= mwlwifi/
 
 obj-$(CONFIG_MWL8K)	+= mwl8k.o
diff --git a/drivers/net/wireless/marvell/mwlwifi/Kconfig b/drivers/net/wireless/marvell/mwlwifi/Kconfig
new file mode 100644
index 000000000000..a9bcb9cd4100
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/Kconfig
@@ -0,0 +1,23 @@
+config MWLWIFI
+	tristate "Marvell Avastar 88W8864/88W8897 PCIe driver (mac80211 compatible)"
+	depends on PCI && MAC80211
+	select FW_LOADER
+	---help---
+		Select to build the driver supporting the:
+
+		Marvell Wireless Wi-Fi 88W8864 modules
+		Marvell Wireless Wi-Fi 88W8897 modules
+
+		This driver uses the kernel's mac80211 subsystem.
+
+		If you want to compile the driver as a module (= code which can be
+		inserted in and removed from the running kernel whenever you want),
+		say M here and read <file:Documentation/kbuild/modules.txt>.  The
+		module will be called mwlwifi.
+
+		NOTE: Selecting this driver may cause conflict with MWIFIEX driver
+		that also operates on the same part number 88W8897. Users should
+		select either MWIFIEX or MWLWIFI, not both. MWIFIEX is fullmac,
+		supporting more comprehensive client functions for laptops/embedded
+		devices. MWLWIFI is mac80211-based for full AP/Wireless Bridge.
+
diff --git a/drivers/net/wireless/marvell/mwlwifi/Makefile b/drivers/net/wireless/marvell/mwlwifi/Makefile
new file mode 100644
index 000000000000..061833703c7f
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/Makefile
@@ -0,0 +1,19 @@
+obj-$(CONFIG_MWLWIFI)	+= mwlwifi.o
+
+mwlwifi-objs			+= core.o
+mwlwifi-objs			+= mac80211.o
+mwlwifi-objs			+= mu_mimo.o
+mwlwifi-objs			+= vendor_cmd.o
+mwlwifi-objs			+= utils.o
+mwlwifi-$(CONFIG_THERMAL)	+= thermal.o
+mwlwifi-$(CONFIG_DEBUG_FS)	+= debugfs.o
+mwlwifi-objs			+= hif/fwcmd.o
+mwlwifi-objs			+= hif/pcie/pcie.o
+mwlwifi-objs			+= hif/pcie/fwdl.o
+mwlwifi-objs			+= hif/pcie/tx.o
+mwlwifi-objs			+= hif/pcie/rx.o
+mwlwifi-objs			+= hif/pcie/tx_ndp.o
+mwlwifi-objs			+= hif/pcie/rx_ndp.o
+
+ccflags-y += -I$(src)
+ccflags-y += -D__CHECK_ENDIAN__
diff --git a/drivers/net/wireless/marvell/mwlwifi/Makefile.module b/drivers/net/wireless/marvell/mwlwifi/Makefile.module
new file mode 100644
index 000000000000..d11a1b88cab6
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/Makefile.module
@@ -0,0 +1,28 @@
+obj-m += mwlwifi.o
+
+mwlwifi-objs			+= core.o
+mwlwifi-objs			+= mac80211.o
+mwlwifi-objs			+= mu_mimo.o
+mwlwifi-objs			+= vendor_cmd.o
+mwlwifi-objs			+= utils.o
+mwlwifi-$(CONFIG_THERMAL)	+= thermal.o
+mwlwifi-$(CONFIG_DEBUG_FS)	+= debugfs.o
+mwlwifi-objs			+= hif/fwcmd.o
+mwlwifi-objs			+= hif/pcie/pcie.o
+mwlwifi-objs			+= hif/pcie/fwdl.o
+mwlwifi-objs			+= hif/pcie/tx.o
+mwlwifi-objs			+= hif/pcie/rx.o
+mwlwifi-objs			+= hif/pcie/tx_ndp.o
+mwlwifi-objs			+= hif/pcie/rx_ndp.o
+
+ccflags-y += -I$(src)
+ccflags-y += -O2 -funroll-loops -D__CHECK_ENDIAN__
+
+all:
+	$(MAKE) -C $(KDIR) M=$(PWD)
+
+clean:
+	rm -f *.a *.s *.ko *.ko.cmd *.mod.* .mwlwifi.* modules.order Module.symvers
+	rm -rf .tmp_versions
+	find . -name ".*.o.cmd" -exec rm -f {} \;
+	find . -name "*.o" -exec rm -f {} \;
diff --git a/drivers/net/wireless/marvell/mwlwifi/README.md b/drivers/net/wireless/marvell/mwlwifi/README.md
new file mode 100644
index 000000000000..788c5d4dc80d
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/README.md
@@ -0,0 +1,142 @@
+# mwlwifi
+mac80211 driver for the Marvell 88W8x64 802.11ac chip
+
+## Building mwlwifi With OpenWrt/LEDE
+1. Modify `package/kernel/mwlwifi/Makefile`:
+    ```
+    PKG_VERSION:=10.3.0.17-20160601
+    PKG_SOURCE_VERSION:=4bb95ba1aeccce506a95499b49b9b844ecfae8a1
+    ```
+
+2. Rename `package/kernel/mwlwifi/patches` to `package/kernel/mwlwifi/patches.tmp`.
+3. Run the following commands:
+    ```sh
+    make package/kernel/mwlwifi/clean
+    make V=s (-jx)
+    ```
+
+### Special Considerations
+* After driver 10.3.0.17-20160603, [MAX-MPDU-7991] should be removed from vht_capab command of hostapd.
+
+* Hostpad must include the following commit for 160 MHz operation:
+    ```
+    commit 03a72eacda5d9a1837a74387081596a0d5466ec1
+    Author: Jouni Malinen <jouni@qca.qualcomm.com>
+    Date:   Thu Dec 17 18:39:19 2015 +0200
+    
+    VHT: Add an interoperability workaround for 80+80 and 160 MHz channels
+
+    Number of deployed 80 MHz capable VHT stations that do not support 80+80
+    and 160 MHz bandwidths seem to misbehave when trying to connect to an AP
+    that advertises 80+80 or 160 MHz channel bandwidth in the VHT Operation
+    element. To avoid such issues with deployed devices, modify the design
+    based on newly proposed IEEE 802.11 standard changes.
+
+    This allows poorly implemented VHT 80 MHz stations to connect with the
+    AP in 80 MHz mode. 80+80 and 160 MHz capable stations need to support
+    the new workaround mechanism to allow full bandwidth to be used.
+    However, there are more or less no impacted station with 80+80/160
+    capability deployed.
+
+    Signed-off-by: Jouni Malinen jouni@qca.qualcomm.com
+
+    Note: After hostapd package 2016-06-15, this commit is already included.
+    ```
+
+* In order to let STA mode to support 160 MHz operation, mac80211 package should be 2016-10-08 or later.
+
+* WiFi device does not use HT rates when using TKIP as the encryption cipher. If you want to have good performance, please use AES only.
+
+* DTS parameters for mwlwifi driver (pcie@X,0):
+    ```sh
+    #Disable 2g band
+    marvell,2ghz = <0>;
+
+    #Disable 5g band
+    marvell,5ghz = <0>;
+    
+    #Specify antenna number, default is 4x4. For WRT1200AC, you must set these values to 2x2.
+    marvell,chainmask = <4 4>;
+    
+    #Specify external power table. If your device needs external power table, you must provide the power table via this parameter, otherwise the Tx power will be pretty low.
+    marvell,powertable
+    ```
+
+    To see if your device needs/accepts an external power table or not, run the following:
+    ```sh
+    cat /sys/kernel/debug/ieee80211/phy0/mwlwifi/info
+    ```
+    
+    You should see a line in the results which looks like the following:
+    ```sh
+    power table loaded from dts: no
+    ```
+
+    If it is "no", it does not allow you to load external power table (for newer devices due to FCC regulations). If it is "yes", you must provide power table in DTS file (for older devices).
+
+* Changing interrupt to different CPU cores:
+    ```sh
+    #Use CPU0:
+    echo 1 > /proc/irq/irq number of phy0 or phy1/smp_affinity
+
+    #Use CPU1:
+    echo 2 > /proc/irq/irq number of phy0 or phy1/smp_affinity
+    ```
+
+* Note for DFS of WRT3200ACM (88W8964):
+
+    All WRT3200ACM devices are programmed with device power table. Mwlwifi driver will base on region code to set country code for your device and it will not allow you to change country code. There are another wifi (phy2) on WRT3200ACM which is not mwlwifi. It will allow you to change country code. Under this case, country code setting will be conflicted and it will let DFS can't work.
+
+    There are two ways to resolve this problem:
+    * Please don't change country code and let mwlwifi set it for you.
+    * Remove phy2. Under this case, even though you change country code, mwlwifi will reject it. Because phy2 is not existed, country code setting won't be conflicted. To do this, run the following commands (for OpenWrt/LEDE):
+    
+        ```sh
+        opkg remove kmod-mwifiex-sdio
+        opkg remove mwifiex-sdio-firmware
+        reboot
+        ```
+
+    The better way is let mwlwifi set country code for you.
+
+## Replacing mwlwifi on a Current OpenWrt/LEDE Build
+
+1. Establish a symbolic link to your working mwlwifi directory with current mwlwifi package name under directory "dl":
+    ```sh
+    ls -l mwlwifi*
+    ```
+
+    You should see something like the following:
+    ```sh
+    lrwxrwxrwx 1 dlin dlin      48  mwlwifi-10.3.2.0-20170110 -> /home/dlin/home2/projects/github/mwlwifi
+
+    -rw-r--r-- 1 dlin dlin 4175136  mwlwifi-10.3.2.0-20170110.tar.xz
+    ```
+
+2. Back up original mwlwifi package and tar your working mwlwifi to replace original mwlwifi package:
+
+    ```sh
+    tar Jcvf mwlwifi-10.3.2.0-20170110.tar.xz mwlwifi-10.3.2.0-20170110/.
+    ```
+
+3. You can use `make V=s` to build the whole image or `make V=s package/kernel/mwlwifi/compile` to build mwlwifi package. The generated whole image or mwlwifi package can be found under directory "bin".
+
+Due to package version being the same as previous one, you need to add option `--force-reinstall` when you use `opkg` to update mwlwifi package on your device.
+
+## Monitor interface for debug
+
+1. Create moinitor interface mon0:
+    ```sh
+    iw wlan0/wlan1 interface add mon0 type monitor
+    ifconfig mon0 up
+    ```
+
+2. Use tcpdump to dump dhcp packets:
+    ```sh
+    tcpdump -vvvi mon0 -n port 67 and port 68
+    ```
+
+3. Use tcpdump to dump icmp packets:
+    ```sh
+    tcpdump -vvvi mon0 icmp
+    ```
diff --git a/drivers/net/wireless/marvell/mwlwifi/core.c b/drivers/net/wireless/marvell/mwlwifi/core.c
new file mode 100644
index 000000000000..9d2b5511607e
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/core.c
@@ -0,0 +1,1086 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements core layer related functions. */
+
+#include <linux/etherdevice.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "vendor_cmd.h"
+#include "thermal.h"
+#include "debugfs.h"
+#include "hif/fwcmd.h"
+#include "hif/hif-ops.h"
+
+#define CMD_BUF_SIZE     0x4000
+#define INVALID_WATCHDOG 0xAA
+
+static const struct ieee80211_channel mwl_channels_24[] = {
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2412, .hw_value = 1, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2417, .hw_value = 2, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2422, .hw_value = 3, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2427, .hw_value = 4, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2432, .hw_value = 5, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2437, .hw_value = 6, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2442, .hw_value = 7, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2447, .hw_value = 8, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2452, .hw_value = 9, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2457, .hw_value = 10, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2462, .hw_value = 11, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2467, .hw_value = 12, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2472, .hw_value = 13, },
+	{ .band = NL80211_BAND_2GHZ, .center_freq = 2484, .hw_value = 14, },
+};
+
+static const struct ieee80211_rate mwl_rates_24[] = {
+	{ .bitrate = 10, .hw_value = 2, },
+	{ .bitrate = 20, .hw_value = 4, },
+	{ .bitrate = 55, .hw_value = 11, },
+	{ .bitrate = 110, .hw_value = 22, },
+	{ .bitrate = 220, .hw_value = 44, },
+	{ .bitrate = 60, .hw_value = 12, },
+	{ .bitrate = 90, .hw_value = 18, },
+	{ .bitrate = 120, .hw_value = 24, },
+	{ .bitrate = 180, .hw_value = 36, },
+	{ .bitrate = 240, .hw_value = 48, },
+	{ .bitrate = 360, .hw_value = 72, },
+	{ .bitrate = 480, .hw_value = 96, },
+	{ .bitrate = 540, .hw_value = 108, },
+};
+
+static const struct ieee80211_channel mwl_channels_50[] = {
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5180, .hw_value = 36, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5200, .hw_value = 40, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5220, .hw_value = 44, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5240, .hw_value = 48, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5260, .hw_value = 52, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5280, .hw_value = 56, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5300, .hw_value = 60, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5320, .hw_value = 64, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5500, .hw_value = 100, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5520, .hw_value = 104, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5540, .hw_value = 108, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5560, .hw_value = 112, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5580, .hw_value = 116, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5600, .hw_value = 120, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5620, .hw_value = 124, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5640, .hw_value = 128, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5660, .hw_value = 132, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5680, .hw_value = 136, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5700, .hw_value = 140, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5720, .hw_value = 144, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5745, .hw_value = 149, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5765, .hw_value = 153, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5785, .hw_value = 157, },
+	{ .band = NL80211_BAND_5GHZ, .center_freq = 5805, .hw_value = 161, },
+};
+
+static const struct ieee80211_rate mwl_rates_50[] = {
+	{ .bitrate = 60, .hw_value = 12, },
+	{ .bitrate = 90, .hw_value = 18, },
+	{ .bitrate = 120, .hw_value = 24, },
+	{ .bitrate = 180, .hw_value = 36, },
+	{ .bitrate = 240, .hw_value = 48, },
+	{ .bitrate = 360, .hw_value = 72, },
+	{ .bitrate = 480, .hw_value = 96, },
+	{ .bitrate = 540, .hw_value = 108, },
+};
+
+static const struct ieee80211_iface_limit ap_if_limits[] = {
+	{ .max = SYSADPT_NUM_OF_AP, .types = BIT(NL80211_IFTYPE_AP) },
+#if defined(CPTCFG_MAC80211_MESH) || defined(CONFIG_MAC80211_MESH)
+	{ .max = SYSADPT_NUM_OF_MESH, .types = BIT(NL80211_IFTYPE_MESH_POINT) },
+#endif
+	{ .max = SYSADPT_NUM_OF_CLIENT, .types = BIT(NL80211_IFTYPE_STATION) },
+};
+
+static const struct ieee80211_iface_combination ap_if_comb = {
+	.limits = ap_if_limits,
+	.n_limits = ARRAY_SIZE(ap_if_limits),
+	.max_interfaces = SYSADPT_NUM_OF_AP,
+	.num_different_channels = 1,
+	.radar_detect_widths =	BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+				BIT(NL80211_CHAN_WIDTH_20) |
+				BIT(NL80211_CHAN_WIDTH_40) |
+				BIT(NL80211_CHAN_WIDTH_80) |
+				BIT(NL80211_CHAN_WIDTH_160),
+};
+
+struct region_code_mapping {
+	const char *alpha2;
+	u32 region_code;
+};
+
+static const struct region_code_mapping regmap[] = {
+	{"US", 0x10}, /* US FCC */
+	{"CA", 0x20}, /* Canada */
+	{"FR", 0x30}, /* France */
+	{"ES", 0x31}, /* Spain  */
+	{"FR", 0x32}, /* France */
+	{"JP", 0x40}, /* Japan  */
+	{"TW", 0x80}, /* Taiwan */
+	{"AU", 0x81}, /* Australia */
+	{"CN", 0x90}, /* China (Asia) */
+};
+
+static int mwl_prepare_cmd_buf(struct mwl_priv *priv)
+{
+	priv->pcmd_buf =
+		(unsigned short *)dmam_alloc_coherent(priv->dev,
+						      CMD_BUF_SIZE,
+						      &priv->pphys_cmd_buf,
+						      GFP_KERNEL);
+	if (!priv->pcmd_buf) {
+		wiphy_err(priv->hw->wiphy,
+			  "cannot alloc memory for command buffer\n");
+		goto err;
+	}
+	wiphy_debug(priv->hw->wiphy,
+		    "priv->pcmd_buf = %p  priv->pphys_cmd_buf = %p\n",
+		    priv->pcmd_buf,
+		    (void *)priv->pphys_cmd_buf);
+	memset(priv->pcmd_buf, 0x00, CMD_BUF_SIZE);
+
+	return 0;
+
+err:
+	wiphy_err(priv->hw->wiphy, "command buffer alloc fail\n");
+
+	return -EIO;
+}
+
+static int mwl_init_firmware(struct mwl_priv *priv, const char *fw_name,
+			     const char *cal_name, const char *txpwrlmt_name)
+{
+	int rc = 0;
+
+	rc = request_firmware((const struct firmware **)&priv->fw_ucode,
+			      fw_name, priv->dev);
+
+	if (rc) {
+		wiphy_err(priv->hw->wiphy,
+			  "cannot find firmware image <%s>\n", fw_name);
+		goto err_load_fw;
+	}
+
+	rc = mwl_hif_download_firmware(priv->hw);
+	if (rc) {
+		wiphy_err(priv->hw->wiphy,
+			  "cannot download firmware image <%s>\n", fw_name);
+		goto err_download_fw;
+	}
+
+	if (cal_name) {
+		if ((request_firmware((const struct firmware **)&priv->cal_data,
+		     cal_name, priv->dev)) < 0)
+			wiphy_debug(priv->hw->wiphy,
+				    "cannot find calibtration data\n");
+	}
+
+	if (txpwrlmt_name) {
+		if ((request_firmware(
+		     (const struct firmware **)&priv->txpwrlmt_file,
+		     txpwrlmt_name, priv->dev)) < 0)
+			wiphy_debug(priv->hw->wiphy,
+				    "cannot find tx power limit data\n");
+	}
+
+	return rc;
+
+err_download_fw:
+
+	release_firmware(priv->fw_ucode);
+
+err_load_fw:
+
+	wiphy_err(priv->hw->wiphy, "firmware init fail\n");
+
+	return rc;
+}
+
+static void mwl_process_of_dts(struct mwl_priv *priv)
+{
+#ifdef CONFIG_OF
+	struct property *prop;
+	u32 prop_value;
+
+	priv->dt_node =
+		of_find_node_by_name(mwl_hif_device_node(priv->hw),
+				     "mwlwifi");
+	if (!priv->dt_node)
+		return;
+
+	/* look for all matching property names */
+	for_each_property_of_node(priv->dt_node, prop) {
+		if (strcmp(prop->name, "marvell,2ghz") == 0)
+			priv->disable_2g = true;
+		if (strcmp(prop->name, "marvell,5ghz") == 0)
+			priv->disable_5g = true;
+		if (strcmp(prop->name, "marvell,chainmask") == 0) {
+			prop_value = be32_to_cpu(*((__be32 *)prop->value));
+			if (prop_value == 2)
+				priv->antenna_tx = ANTENNA_TX_2;
+			else if (prop_value == 3)
+				priv->antenna_tx = ANTENNA_TX_3;
+
+			prop_value = be32_to_cpu(*((__be32 *)
+						 (prop->value + 4)));
+			if (prop_value == 2)
+				priv->antenna_rx = ANTENNA_RX_2;
+			else if (prop_value == 3)
+				priv->antenna_rx = ANTENNA_RX_3;
+		}
+	}
+
+	priv->pwr_node = of_find_node_by_name(priv->dt_node,
+					      "marvell,powertable");
+#endif
+}
+
+static void mwl_reg_notifier(struct wiphy *wiphy,
+			     struct regulatory_request *request)
+{
+	struct ieee80211_hw *hw;
+	struct mwl_priv *priv;
+#ifdef CONFIG_OF
+	struct property *prop;
+	struct property *fcc_prop = NULL;
+	struct property *etsi_prop = NULL;
+	struct property *specific_prop = NULL;
+	u32 prop_value;
+	int i, j, k;
+#endif
+
+	hw = wiphy_to_ieee80211_hw(wiphy);
+	priv = hw->priv;
+
+	if (priv->forbidden_setting) {
+		if (!priv->regulatory_set) {
+			regulatory_hint(wiphy, priv->fw_alpha2);
+			priv->regulatory_set = true;
+		} else {
+			if (memcmp(priv->fw_alpha2, request->alpha2, 2))
+				regulatory_hint(wiphy, priv->fw_alpha2);
+		}
+		return;
+	}
+
+	priv->dfs_region = request->dfs_region;
+
+#ifdef CONFIG_OF
+	if ((priv->chip_type != MWL8997) && (priv->pwr_node)) {
+		for_each_property_of_node(priv->pwr_node, prop) {
+			if (strcmp(prop->name, "FCC") == 0)
+				fcc_prop = prop;
+			if (strcmp(prop->name, "ETSI") == 0)
+				etsi_prop = prop;
+			if ((prop->name[0] == request->alpha2[0]) &&
+			    (prop->name[1] == request->alpha2[1]))
+				specific_prop = prop;
+		}
+
+		prop = NULL;
+
+		if (specific_prop) {
+			prop = specific_prop;
+		} else {
+			if (priv->dfs_region == NL80211_DFS_ETSI)
+				prop = etsi_prop;
+			else
+				prop = fcc_prop;
+		}
+
+		if (prop) {
+			/* Reset the whole table */
+			for (i = 0; i < SYSADPT_MAX_NUM_CHANNELS; i++)
+				memset(&priv->tx_pwr_tbl[i], 0,
+				       sizeof(struct mwl_tx_pwr_tbl));
+
+			/* Load related power table */
+			i = 0;
+			j = 0;
+			while (i < prop->length) {
+				prop_value =
+					be32_to_cpu(*(__be32 *)
+						    (prop->value + i));
+				priv->tx_pwr_tbl[j].channel = prop_value;
+				i += 4;
+				prop_value =
+					be32_to_cpu(*(__be32 *)
+						    (prop->value + i));
+				priv->tx_pwr_tbl[j].setcap = prop_value;
+				i += 4;
+				for (k = 0; k < SYSADPT_TX_POWER_LEVEL_TOTAL;
+				     k++) {
+					prop_value =
+						be32_to_cpu(*(__be32 *)
+							    (prop->value + i));
+					priv->tx_pwr_tbl[j].tx_power[k] =
+						prop_value;
+					i += 4;
+				}
+				prop_value =
+					be32_to_cpu(*(__be32 *)
+						    (prop->value + i));
+				priv->tx_pwr_tbl[j].cdd =
+					(prop_value == 0) ? false : true;
+				i += 4;
+				prop_value =
+					be32_to_cpu(*(__be32 *)
+						    (prop->value + i));
+				priv->tx_pwr_tbl[j].txantenna2 = prop_value;
+				i += 4;
+				j++;
+			}
+
+			/* Dump loaded power tabel */
+			wiphy_debug(hw->wiphy, "regdomain: %s\n", prop->name);
+			for (i = 0; i < SYSADPT_MAX_NUM_CHANNELS; i++) {
+				struct mwl_tx_pwr_tbl *pwr_tbl;
+				char disp_buf[64];
+				char *disp_ptr;
+
+				pwr_tbl = &priv->tx_pwr_tbl[i];
+				if (pwr_tbl->channel == 0)
+					break;
+				wiphy_debug(hw->wiphy,
+					    "Channel: %d: 0x%x 0x%x 0x%x\n",
+					    pwr_tbl->channel,
+					    pwr_tbl->setcap,
+					    pwr_tbl->cdd,
+					    pwr_tbl->txantenna2);
+				disp_ptr = disp_buf;
+				for (j = 0; j < SYSADPT_TX_POWER_LEVEL_TOTAL;
+				     j++) {
+					disp_ptr +=
+						sprintf(disp_ptr, "%x ",
+							pwr_tbl->tx_power[j]);
+				}
+				wiphy_debug(hw->wiphy, "%s\n", disp_buf);
+			}
+		}
+	}
+#endif
+}
+
+static void mwl_regd_init(struct mwl_priv *priv)
+{
+	u8 region_code;
+	int rc;
+	int i;
+
+	/* hook regulatory domain change notification */
+	priv->hw->wiphy->reg_notifier = mwl_reg_notifier;
+
+	if (priv->chip_type == MWL8964)
+		rc = mwl_fwcmd_get_pwr_tbl_sc4(priv->hw,
+					       &priv->device_pwr_tbl[0],
+					       &region_code,
+					       &priv->number_of_channels,
+					       0);
+	else
+		rc = mwl_fwcmd_get_device_pwr_tbl(priv->hw,
+						  &priv->device_pwr_tbl[0],
+						  &region_code,
+						  &priv->number_of_channels,
+						  0);
+	if (rc)
+		return;
+
+	priv->forbidden_setting = true;
+
+	for (i = 1; i < priv->number_of_channels; i++) {
+		if (priv->chip_type == MWL8964)
+			mwl_fwcmd_get_pwr_tbl_sc4(priv->hw,
+						  &priv->device_pwr_tbl[i],
+						  &region_code,
+						  &priv->number_of_channels,
+						  i);
+		else
+			mwl_fwcmd_get_device_pwr_tbl(priv->hw,
+						     &priv->device_pwr_tbl[i],
+						     &region_code,
+						     &priv->number_of_channels,
+						     i);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(regmap); i++)
+		if (regmap[i].region_code == priv->fw_region_code) {
+			memcpy(priv->fw_alpha2, regmap[i].alpha2, 2);
+			break;
+		}
+}
+
+static void mwl_set_ht_caps(struct mwl_priv *priv,
+			    struct ieee80211_supported_band *band)
+{
+	struct ieee80211_hw *hw;
+	const u8 ant_rx_no[ANTENNA_RX_MAX] = { 3, 1, 2, 3};
+	int i;
+
+	hw = priv->hw;
+
+	band->ht_cap.ht_supported = 1;
+	if (priv->chip_type == MWL8964)
+		band->ht_cap.cap |= IEEE80211_HT_CAP_MAX_AMSDU;
+	band->ht_cap.cap |= IEEE80211_HT_CAP_LDPC_CODING;
+	band->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;
+	band->ht_cap.cap |= IEEE80211_HT_CAP_SM_PS;
+	band->ht_cap.cap |= IEEE80211_HT_CAP_SGI_20;
+	band->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;
+	band->ht_cap.cap |= IEEE80211_HT_CAP_DSSSCCK40;
+
+	if ((priv->chip_type == MWL8997) &&
+	    (priv->antenna_tx != ANTENNA_TX_1)) {
+		band->ht_cap.cap |= IEEE80211_HT_CAP_TX_STBC;
+		band->ht_cap.cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
+	}
+
+	ieee80211_hw_set(hw, AMPDU_AGGREGATION);
+	ieee80211_hw_set(hw, SUPPORTS_AMSDU_IN_AMPDU);
+	band->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;
+	band->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_4;
+
+	for (i = 0; i < ant_rx_no[priv->antenna_rx]; i++)
+		band->ht_cap.mcs.rx_mask[i] = 0xff;
+	band->ht_cap.mcs.rx_mask[4] = 0x01;
+
+	band->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
+}
+
+static void mwl_set_vht_caps(struct mwl_priv *priv,
+			     struct ieee80211_supported_band *band)
+{
+	u32 antenna_num = 4;
+
+	band->vht_cap.vht_supported = 1;
+
+	if (priv->chip_type == MWL8964) {
+		band->vht_cap.cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454;
+		band->vht_cap.cap |= IEEE80211_VHT_CAP_SHORT_GI_160;
+		band->vht_cap.cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
+	} else
+		band->vht_cap.cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895;
+	band->vht_cap.cap |= IEEE80211_VHT_CAP_RXLDPC;
+	band->vht_cap.cap |= IEEE80211_VHT_CAP_SHORT_GI_80;
+	band->vht_cap.cap |= IEEE80211_VHT_CAP_RXSTBC_1;
+	if (priv->antenna_tx != ANTENNA_TX_1) {
+		band->vht_cap.cap |= IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE;
+		if (priv->chip_type == MWL8964)
+			band->vht_cap.cap |=
+				IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE;
+	}
+	band->vht_cap.cap |= IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE;
+	if (priv->chip_type == MWL8964)
+		band->vht_cap.cap |= IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;
+	band->vht_cap.cap |= IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;
+	band->vht_cap.cap |= IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN;
+	band->vht_cap.cap |= IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN;
+	if (priv->chip_type == MWL8997) {
+		if (priv->antenna_tx != ANTENNA_TX_1)
+			band->vht_cap.cap |= IEEE80211_VHT_CAP_TXSTBC;
+	}
+
+	if (priv->antenna_rx == ANTENNA_RX_1)
+		band->vht_cap.vht_mcs.rx_mcs_map = cpu_to_le16(0xfffe);
+	else if (priv->antenna_rx == ANTENNA_RX_2)
+		band->vht_cap.vht_mcs.rx_mcs_map = cpu_to_le16(0xfffa);
+	else
+		band->vht_cap.vht_mcs.rx_mcs_map = cpu_to_le16(0xffea);
+
+	if (priv->antenna_tx == ANTENNA_TX_1) {
+		band->vht_cap.vht_mcs.tx_mcs_map = cpu_to_le16(0xfffe);
+		antenna_num = 1;
+	} else if (priv->antenna_tx == ANTENNA_TX_2) {
+		band->vht_cap.vht_mcs.tx_mcs_map = cpu_to_le16(0xfffa);
+		antenna_num = 2;
+	} else
+		band->vht_cap.vht_mcs.tx_mcs_map = cpu_to_le16(0xffea);
+
+	if (band->vht_cap.cap & (IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |
+	    IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE)) {
+		band->vht_cap.cap |=
+			((antenna_num - 1) <<
+			IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT) &
+			IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK;
+	}
+
+	if (band->vht_cap.cap & (IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |
+	    IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)) {
+		band->vht_cap.cap |=
+			((antenna_num - 1) <<
+			IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT) &
+			IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK;
+	}
+}
+
+static void mwl_set_caps(struct mwl_priv *priv)
+{
+	struct ieee80211_hw *hw;
+
+	hw = priv->hw;
+
+	/* set up band information for 2.4G */
+	if (!priv->disable_2g) {
+		BUILD_BUG_ON(sizeof(priv->channels_24) !=
+			     sizeof(mwl_channels_24));
+		memcpy(priv->channels_24, mwl_channels_24,
+		       sizeof(mwl_channels_24));
+
+		BUILD_BUG_ON(sizeof(priv->rates_24) != sizeof(mwl_rates_24));
+		memcpy(priv->rates_24, mwl_rates_24, sizeof(mwl_rates_24));
+
+		priv->band_24.band = NL80211_BAND_2GHZ;
+		priv->band_24.channels = priv->channels_24;
+		priv->band_24.n_channels = ARRAY_SIZE(mwl_channels_24);
+		priv->band_24.bitrates = priv->rates_24;
+		priv->band_24.n_bitrates = ARRAY_SIZE(mwl_rates_24);
+
+		mwl_set_ht_caps(priv, &priv->band_24);
+		mwl_set_vht_caps(priv, &priv->band_24);
+
+		hw->wiphy->bands[NL80211_BAND_2GHZ] = &priv->band_24;
+	}
+
+	/* set up band information for 5G */
+	if (!priv->disable_5g) {
+		BUILD_BUG_ON(sizeof(priv->channels_50) !=
+			     sizeof(mwl_channels_50));
+		memcpy(priv->channels_50, mwl_channels_50,
+		       sizeof(mwl_channels_50));
+
+		BUILD_BUG_ON(sizeof(priv->rates_50) != sizeof(mwl_rates_50));
+		memcpy(priv->rates_50, mwl_rates_50, sizeof(mwl_rates_50));
+
+		priv->band_50.band = NL80211_BAND_5GHZ;
+		priv->band_50.channels = priv->channels_50;
+		priv->band_50.n_channels = ARRAY_SIZE(mwl_channels_50);
+		priv->band_50.bitrates = priv->rates_50;
+		priv->band_50.n_bitrates = ARRAY_SIZE(mwl_rates_50);
+
+		mwl_set_ht_caps(priv, &priv->band_50);
+		mwl_set_vht_caps(priv, &priv->band_50);
+
+		hw->wiphy->bands[NL80211_BAND_5GHZ] = &priv->band_50;
+	}
+}
+
+static void mwl_heartbeat_handle(struct work_struct *work)
+{
+	struct mwl_priv *priv =
+		container_of(work, struct mwl_priv, heartbeat_handle);
+	u32 val;
+
+	mwl_fwcmd_get_addr_value(priv->hw, 0, 1, &val, 0);
+	priv->heartbeating = false;
+}
+
+static void mwl_watchdog_ba_events(struct work_struct *work)
+{
+	int rc;
+	u8 bitmap = 0, stream_index;
+	struct mwl_ampdu_stream *streams;
+	struct mwl_priv *priv =
+		container_of(work, struct mwl_priv, watchdog_ba_handle);
+
+	rc = mwl_fwcmd_get_watchdog_bitmap(priv->hw, &bitmap);
+
+	if (rc)
+		return;
+
+	spin_lock_bh(&priv->stream_lock);
+
+	/* the bitmap is the hw queue number.  Map it to the ampdu queue. */
+	if (bitmap != INVALID_WATCHDOG) {
+		if (bitmap == priv->ampdu_num)
+			stream_index = 0;
+		else if (bitmap > priv->ampdu_num)
+			stream_index = bitmap - priv->ampdu_num;
+		else
+			stream_index = bitmap + 3; /** queue 0 is stream 3*/
+
+		if (bitmap != 0xFF) {
+			/* Check if the stream is in use before disabling it */
+			streams = &priv->ampdu[stream_index];
+
+			if (streams->state == AMPDU_STREAM_ACTIVE)
+				ieee80211_stop_tx_ba_session(streams->sta,
+							     streams->tid);
+		} else {
+			for (stream_index = 0;
+			     stream_index < priv->ampdu_num;
+			     stream_index++) {
+				streams = &priv->ampdu[stream_index];
+
+				if (streams->state != AMPDU_STREAM_ACTIVE)
+					continue;
+
+				ieee80211_stop_tx_ba_session(streams->sta,
+							     streams->tid);
+			}
+		}
+	}
+
+	spin_unlock_bh(&priv->stream_lock);
+}
+
+static void mwl_account_handle(struct work_struct *work)
+{
+	struct mwl_priv *priv =
+		container_of(work, struct mwl_priv, account_handle);
+
+	mwl_hif_process_account(priv->hw);
+}
+
+static void mwl_wds_check_handle(struct work_struct *work)
+{
+	struct mwl_priv *priv =
+		container_of(work, struct mwl_priv, wds_check_handle);
+	struct mwl_sta *sta_info;
+	struct ieee80211_sta *sta;
+	bool wds_sta = false;
+
+	spin_lock_bh(&priv->sta_lock);
+	list_for_each_entry(sta_info, &priv->sta_list, list) {
+		if (sta_info->wds)
+			continue;
+		sta = container_of((void *)sta_info, struct ieee80211_sta,
+				   drv_priv);
+		if (ether_addr_equal(sta->addr, priv->wds_check_sta)) {
+			wds_sta = true;
+			break;
+		}
+	}
+	spin_unlock_bh(&priv->sta_lock);
+
+	if (wds_sta) {
+		mwl_fwcmd_set_new_stn_wds_sc4(priv->hw, sta->addr);
+		sta_info->wds = true;
+	}
+
+	priv->wds_check = false;
+}
+
+static void mwl_chnl_switch_event(struct work_struct *work)
+{
+	struct mwl_priv *priv =
+		container_of(work, struct mwl_priv, chnl_switch_handle);
+	struct mwl_vif *mwl_vif;
+	struct ieee80211_vif *vif;
+
+	if (!priv->csa_active) {
+		wiphy_err(priv->hw->wiphy,
+			  "csa is not active (got channel switch event)\n");
+		return;
+	}
+
+	spin_lock_bh(&priv->vif_lock);
+	list_for_each_entry(mwl_vif, &priv->vif_list, list) {
+		vif = container_of((void *)mwl_vif, struct ieee80211_vif,
+				   drv_priv);
+
+		if (vif->csa_active)
+			ieee80211_csa_finish(vif);
+	}
+	spin_unlock_bh(&priv->vif_lock);
+
+	wiphy_info(priv->hw->wiphy, "channel switch is done\n");
+
+	priv->csa_active = false;
+}
+
+static irqreturn_t mwl_isr(int irq, void *dev_id)
+{
+	struct ieee80211_hw *hw = dev_id;
+
+	return mwl_hif_irq_handler(hw);
+}
+
+#ifdef timer_setup
+static void timer_routine(struct timer_list *t)
+{
+	struct mwl_priv *priv = from_timer(priv, t, period_timer);
+	struct ieee80211_hw *hw = priv->hw;
+#else
+static void timer_routine(unsigned long data)
+{
+	struct ieee80211_hw *hw = (struct ieee80211_hw *)data;
+	struct mwl_priv *priv = hw->priv;
+#endif
+	if (priv->heartbeat) {
+		if ((jiffies - priv->pre_jiffies) >=
+		    msecs_to_jiffies(priv->heartbeat * 1000)) {
+			if (!priv->heartbeating) {
+				priv->heartbeating = true;
+				ieee80211_queue_work(hw,
+						     &priv->heartbeat_handle);
+			}
+			priv->pre_jiffies = jiffies;
+		}
+	}
+
+	mwl_hif_timer_routine(hw);
+
+	mod_timer(&priv->period_timer, jiffies +
+		  msecs_to_jiffies(SYSADPT_TIMER_WAKEUP_TIME));
+}
+
+static int mwl_wl_init(struct mwl_priv *priv)
+{
+	struct ieee80211_hw *hw = priv->hw;
+	int rc;
+	u16 addr_num;
+	struct mac_address *mac_addr;
+	u8 last_nibble;
+
+	hw->extra_tx_headroom = mwl_hif_get_tx_head_room(hw);
+	hw->queues = SYSADPT_TX_WMM_QUEUES;
+
+	/* Set rssi values to dBm */
+	ieee80211_hw_set(hw, SIGNAL_DBM);
+	ieee80211_hw_set(hw, HAS_RATE_CONTROL);
+
+	/* Ask mac80211 not to trigger PS mode
+	 * based on PM bit of incoming frames.
+	 */
+	ieee80211_hw_set(hw, AP_LINK_PS);
+
+	ieee80211_hw_set(hw, SUPPORTS_PER_STA_GTK);
+	ieee80211_hw_set(hw, MFP_CAPABLE);
+
+	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
+	hw->wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
+	hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;
+	hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
+
+	hw->vif_data_size = sizeof(struct mwl_vif);
+	hw->sta_data_size = sizeof(struct mwl_sta);
+
+	priv->ap_macids_supported = 0x0000ffff;
+	priv->sta_macids_supported = 0x00010000;
+	priv->macids_used = 0;
+	INIT_LIST_HEAD(&priv->vif_list);
+	INIT_LIST_HEAD(&priv->sta_list);
+
+	/* Set default radio state, preamble and wmm */
+	priv->noise = -104;
+	priv->radio_on = false;
+	priv->radio_short_preamble = false;
+	priv->wmm_enabled = false;
+	priv->powinited = 0;
+	priv->wds_check = false;
+	if (priv->chip_type == MWL8997)
+		priv->pwr_level = SYSADPT_TX_GRP_PWR_LEVEL_TOTAL;
+	else
+		priv->pwr_level = SYSADPT_TX_POWER_LEVEL_TOTAL;
+	priv->dfs_test = false;
+	priv->csa_active = false;
+	priv->dfs_chirp_count_min = 5;
+	priv->dfs_chirp_time_interval = 1000;
+	priv->dfs_pw_filter = 0;
+	priv->dfs_min_num_radar = 5;
+	priv->dfs_min_pri_count = 4;
+	priv->bf_type = TXBF_MODE_AUTO;
+
+	/* Handle watchdog ba events */
+	INIT_WORK(&priv->heartbeat_handle, mwl_heartbeat_handle);
+	INIT_WORK(&priv->watchdog_ba_handle, mwl_watchdog_ba_events);
+	INIT_WORK(&priv->account_handle, mwl_account_handle);
+	INIT_WORK(&priv->wds_check_handle, mwl_wds_check_handle);
+	INIT_WORK(&priv->chnl_switch_handle, mwl_chnl_switch_event);
+
+	mutex_init(&priv->fwcmd_mutex);
+	spin_lock_init(&priv->vif_lock);
+	spin_lock_init(&priv->sta_lock);
+	spin_lock_init(&priv->stream_lock);
+	spin_lock_init(&priv->stnid_lock);
+
+	rc = mwl_thermal_register(priv);
+	if (rc) {
+		wiphy_err(hw->wiphy, "fail to register thermal framework\n");
+		goto err_thermal_register;
+	}
+
+	rc = mwl_hif_init(hw);
+	if (rc) {
+		wiphy_err(hw->wiphy, "fail to initialize host interface\n");
+		goto err_hif_init;
+	}
+
+	SET_IEEE80211_PERM_ADDR(hw, priv->hw_data.mac_addr);
+
+	if (priv->chip_type == MWL8964) {
+		addr_num = SYSADPT_NUM_OF_AP + SYSADPT_NUM_OF_CLIENT;
+		hw->wiphy->n_addresses = addr_num;
+		hw->wiphy->addresses =
+			kzalloc(addr_num * sizeof(*mac_addr), GFP_KERNEL);
+
+		mac_addr = &hw->wiphy->addresses[0];
+		ether_addr_copy(mac_addr->addr, priv->hw_data.mac_addr);
+		last_nibble = mac_addr->addr[5] & 0x0F;
+		for (addr_num = 0; addr_num < SYSADPT_NUM_OF_AP; addr_num++) {
+			mac_addr = &hw->wiphy->addresses[addr_num + 1];
+			ether_addr_copy(mac_addr->addr, priv->hw_data.mac_addr);
+			if (!strcmp(wiphy_name(hw->wiphy), "phy0")) {
+				last_nibble++;
+				if (last_nibble == 0x10)
+					last_nibble = 0;
+			} else {
+				last_nibble--;
+				if (last_nibble == 0xFF)
+					last_nibble = 0x0F;
+			}
+			mac_addr->addr[5] =
+				(mac_addr->addr[5] & 0xF0) | last_nibble;
+			mac_addr->addr[0] |= 0x2;
+		}
+	}
+
+	wiphy_info(hw->wiphy,
+		   "firmware version: 0x%x\n", priv->hw_data.fw_release_num);
+
+	if (priv->chip_type == MWL8997) {
+		mwl_fwcmd_set_cfg_data(hw, 2);
+		mwl_fwcmd_set_txpwrlmt_cfg_data(hw);
+		mwl_fwcmd_get_txpwrlmt_cfg_data(hw);
+	}
+
+	if (priv->chip_type == MWL8964)
+		rc = mwl_fwcmd_get_fw_region_code_sc4(hw,
+						      &priv->fw_region_code);
+	else
+		rc = mwl_fwcmd_get_fw_region_code(hw, &priv->fw_region_code);
+	if (!rc) {
+		priv->fw_device_pwrtbl = true;
+		mwl_regd_init(priv);
+		wiphy_info(hw->wiphy,
+			   "firmware region code: %x\n", priv->fw_region_code);
+	}
+
+	if (priv->chip_type == MWL8997)
+		mwl_fwcmd_dump_otp_data(hw);
+
+	mwl_fwcmd_radio_disable(hw);
+	mwl_fwcmd_rf_antenna(hw, WL_ANTENNATYPE_TX, priv->antenna_tx);
+	mwl_fwcmd_rf_antenna(hw, WL_ANTENNATYPE_RX, priv->antenna_rx);
+
+	hw->wiphy->interface_modes = 0;
+	hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_AP);
+#if defined(CPTCFG_MAC80211_MESH) || defined(CONFIG_MAC80211_MESH)
+	hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_MESH_POINT);
+#endif
+	hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_STATION);
+	hw->wiphy->iface_combinations = &ap_if_comb;
+	hw->wiphy->n_iface_combinations = 1;
+
+	mwl_set_caps(priv);
+
+	priv->led_blink_enable = 1;
+	priv->led_blink_rate = LED_BLINK_RATE_MID;
+	mwl_fwcmd_led_ctrl(hw, priv->led_blink_enable, priv->led_blink_rate);
+
+	vendor_cmd_register(hw->wiphy);
+
+	rc = ieee80211_register_hw(hw);
+	if (rc) {
+		wiphy_err(hw->wiphy, "fail to register device\n");
+		goto err_register_hw;
+	}
+
+	priv->irq = mwl_hif_get_irq_num(hw);
+	rc = request_irq(priv->irq, mwl_isr, IRQF_SHARED,
+			 mwl_hif_get_driver_name(hw), hw);
+	if (rc) {
+		priv->irq = -1;
+		wiphy_err(hw->wiphy, "fail to register IRQ handler\n");
+		goto err_register_irq;
+	}
+#ifdef timer_setup
+	timer_setup(&priv->period_timer, timer_routine, 0);
+#else
+	setup_timer(&priv->period_timer, timer_routine, (unsigned long)hw);
+#endif
+	mod_timer(&priv->period_timer, jiffies +
+		  msecs_to_jiffies(SYSADPT_TIMER_WAKEUP_TIME));
+
+	return rc;
+
+err_register_hw:
+err_register_irq:
+	mwl_hif_deinit(hw);
+
+err_hif_init:
+err_thermal_register:
+
+	wiphy_err(hw->wiphy, "init fail\n");
+
+	return rc;
+}
+
+static void mwl_wl_deinit(struct mwl_priv *priv)
+{
+	struct ieee80211_hw *hw = priv->hw;
+
+	del_timer_sync(&priv->period_timer);
+
+	if (priv->irq != -1) {
+		free_irq(priv->irq, hw);
+		priv->irq = -1;
+	}
+
+	if (priv->chip_type == MWL8964)
+		kfree(hw->wiphy->addresses);
+	ieee80211_unregister_hw(hw);
+	mwl_thermal_unregister(priv);
+	cancel_work_sync(&priv->chnl_switch_handle);
+	cancel_work_sync(&priv->account_handle);
+	cancel_work_sync(&priv->wds_check_handle);
+	cancel_work_sync(&priv->watchdog_ba_handle);
+	cancel_work_sync(&priv->heartbeat_handle);
+	mwl_hif_deinit(hw);
+}
+
+struct ieee80211_hw *mwl_alloc_hw(int bus_type,
+				  int chip_type,
+				  struct device *dev,
+				  const struct mwl_hif_ops *ops,
+				  size_t hif_data_len)
+{
+	struct ieee80211_hw *hw;
+	struct mwl_priv *priv;
+	int priv_size;
+
+	priv_size = ALIGN(sizeof(*priv), NETDEV_ALIGN) + hif_data_len;
+
+	hw = ieee80211_alloc_hw(priv_size, &mwl_mac80211_ops);
+	if (!hw) {
+		pr_err("ieee80211 alloc hw failed\n");
+		return NULL;
+	}
+
+	priv = hw->priv;
+	priv->hw = hw;
+	priv->dev = dev;
+	priv->chip_type = chip_type;
+	priv->fw_device_pwrtbl = false;
+	priv->forbidden_setting = false;
+	priv->regulatory_set = false;
+	priv->use_short_slot = false;
+	priv->use_short_preamble = false;
+	priv->disable_2g = false;
+	priv->disable_5g = false;
+	priv->tx_amsdu = true;
+	priv->hif.bus = bus_type;
+	priv->hif.ops = ops;
+	priv->hif.priv = (char *)priv + ALIGN(sizeof(*priv), NETDEV_ALIGN);
+	priv->ampdu_num = mwl_hif_get_ampdu_num(hw);
+	priv->ampdu =
+		kzalloc(priv->ampdu_num * sizeof(*priv->ampdu), GFP_KERNEL);
+	if (!priv->ampdu) {
+		ieee80211_free_hw(hw);
+		pr_err("alloc ampdu stream failed\n");
+		return NULL;
+	}
+
+	if (chip_type == MWL8964)
+		priv->stnid_num = SYSADPT_MAX_STA_SC4;
+	else
+		priv->stnid_num = SYSADPT_MAX_STA;
+	priv->stnid =
+		kzalloc(priv->stnid_num * sizeof(struct mwl_stnid), GFP_KERNEL);
+	if (!priv->stnid) {
+		kfree(priv->ampdu);
+		ieee80211_free_hw(hw);
+		pr_err("alloc stnid failed\n");
+		return NULL;
+	}
+	priv->available_stnid = 0;
+
+	SET_IEEE80211_DEV(hw, dev);
+
+	return hw;
+}
+
+void mwl_free_hw(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	kfree(priv->stnid);
+	kfree(priv->ampdu);
+	ieee80211_free_hw(hw);
+}
+
+int mwl_init_hw(struct ieee80211_hw *hw, const char *fw_name,
+		const char *cal_name, const char *txpwrlmt_name)
+{
+	struct mwl_priv *priv = hw->priv;
+	int rc;
+	int tx_num = 4, rx_num = 4;
+
+
+	rc = mwl_prepare_cmd_buf(priv);
+	if (rc) {
+		wiphy_err(hw->wiphy, "fail to prepare command buffer\n");
+		return -ENOMEM;
+	}
+
+	rc = mwl_init_firmware(priv, fw_name, cal_name, txpwrlmt_name);
+	if (rc) {
+		wiphy_err(hw->wiphy, "fail to initialize firmware\n");
+		return -EIO;
+	}
+
+	/* firmware is loaded to H/W, it can be released now */
+	release_firmware(priv->fw_ucode);
+
+	mwl_process_of_dts(priv);
+
+	rc = mwl_wl_init(priv);
+	if (rc) {
+		wiphy_err(hw->wiphy, "fail to initialize wireless lan\n");
+		return -EIO;
+	}
+
+	wiphy_info(priv->hw->wiphy, "2G %s, 5G %s\n",
+		   priv->disable_2g ? "disabled" : "enabled",
+		   priv->disable_5g ? "disabled" : "enabled");
+
+	if (priv->antenna_tx == ANTENNA_TX_2)
+		tx_num = 2;
+	else if (priv->antenna_tx == ANTENNA_TX_3)
+		tx_num = 3;
+	if (priv->antenna_rx == ANTENNA_RX_2)
+		rx_num = 2;
+	else if (priv->antenna_rx == ANTENNA_RX_3)
+		rx_num = 3;
+	wiphy_info(priv->hw->wiphy, "%d TX antennas, %d RX antennas\n",
+		   tx_num, rx_num);
+
+#ifdef CONFIG_DEBUG_FS
+	mwl_debugfs_init(hw);
+#endif
+
+	return 0;
+}
+
+void mwl_deinit_hw(struct ieee80211_hw *hw)
+{
+#ifdef CONFIG_DEBUG_FS
+	mwl_debugfs_remove(hw);
+#endif
+
+	mwl_wl_deinit(hw->priv);
+}
diff --git a/drivers/net/wireless/marvell/mwlwifi/core.h b/drivers/net/wireless/marvell/mwlwifi/core.h
new file mode 100644
index 000000000000..00069c4f0b44
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/core.h
@@ -0,0 +1,517 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines core layer related functions. */
+
+#ifndef _CORE_H_
+#define _CORE_H_
+
+#include <linux/interrupt.h>
+#include <linux/firmware.h>
+#include <linux/of.h>
+#include <net/mac80211.h>
+
+#include "hif/hif.h"
+
+/* antenna control */
+#define ANTENNA_TX_4_AUTO             0
+#define ANTENNA_TX_1                  1
+#define ANTENNA_TX_2                  3
+#define ANTENNA_TX_3                  7
+#define ANTENNA_RX_4_AUTO             0
+#define ANTENNA_RX_1                  1
+#define ANTENNA_RX_2                  2
+#define ANTENNA_RX_3                  3
+#define ANTENNA_RX_MAX                4
+
+/* band related constants */
+#define BAND_24_CHANNEL_NUM           14
+#define BAND_24_RATE_NUM              13
+#define BAND_50_CHANNEL_NUM           24
+#define BAND_50_RATE_NUM              8
+
+#define NUM_WEP_KEYS                  4
+#define MWL_MAX_TID                   8
+#define MWL_AMSDU_SIZE_4K             1
+#define MWL_AMSDU_SIZE_8K             2
+#define MWL_AMSDU_SIZE_11K            3
+
+/* power init */
+#define MWL_POWER_INIT_1              1
+#define MWL_POWER_INIT_2              2
+
+/* tx rate information constants */
+#define TX_RATE_FORMAT_LEGACY         0
+#define TX_RATE_FORMAT_11N            1
+#define TX_RATE_FORMAT_11AC           2
+
+#define TX_RATE_BANDWIDTH_20          0
+#define TX_RATE_BANDWIDTH_40          1
+#define TX_RATE_BANDWIDTH_80          2
+#define TX_RATE_BANDWIDTH_160         3
+
+#define TX_RATE_INFO_STD_GI           0
+#define TX_RATE_INFO_SHORT_GI         1
+
+/* tx rate information */
+/* 0: legacy format 1: 11n format 2: 11ac format */
+#define MWL_TX_RATE_FORMAT_MASK       0x00000003
+#define MWL_TX_RATE_STBC_MASK         0x00000004
+#define MWL_TX_RATE_STBC_SHIFT        2
+/* 0: 20 MHz 1: 40 MHz 2: 80 MHz 3: 160 MHz      */
+#define MWL_TX_RATE_BANDWIDTH_MASK    0x00000030
+#define MWL_TX_RATE_BANDWIDTH_SHIFT   4
+/* 0: normal 1: short                            */
+#define MWL_TX_RATE_SHORTGI_MASK      0x00000040
+#define MWL_TX_RATE_SHORTGI_SHIFT     6
+#define MWL_TX_RATE_RATEIDMCS_MASK    0x00007F00
+#define MWL_TX_RATE_RATEIDMCS_SHIFT   8
+/* 0: long   1: short                            */
+#define MWL_TX_RATE_PREAMBLE_MASK     0x00008000
+#define MWL_TX_RATE_PREAMBLE_SHIFT    15
+#define MWL_TX_RATE_POWERID_MASK      0x003F0000
+#define MWL_TX_RATE_POWERID_SHIFT     16
+#define MWL_TX_RATE_ADVCODING_MASK    0x00400000
+#define MWL_TX_RATE_ADVCODING_SHIFT   22
+/* 0: beam forming off 1: beam forming on        */
+#define MWL_TX_RATE_BF_MASK           0x00800000
+#define MWL_TX_RATE_BF_SHIFT          23
+#define MWL_TX_RATE_ANTSELECT_MASK    0xFF000000
+#define MWL_TX_RATE_ANTSELECT_SHIFT   24
+
+#define ACNT_BA_SIZE                  1000
+
+/* Q stats */
+#define QS_MAX_DATA_RATES_G           14
+#define QS_NUM_SUPPORTED_11N_BW       2
+#define QS_NUM_SUPPORTED_GI           2
+#define QS_NUM_SUPPORTED_MCS          24
+#define QS_NUM_SUPPORTED_11AC_NSS     3
+#define QS_NUM_SUPPORTED_11AC_BW      4
+#define QS_NUM_SUPPORTED_11AC_MCS     10
+#define TX_RATE_HISTO_CUSTOM_CNT      1
+#define TX_RATE_HISTO_PER_CNT         5
+#define MAX_DATA_RATES_G              14
+#define MAX_SUPPORTED_MCS             24
+#define MAX_SUPPORTED_11AC_RATES      20
+/* MAX_DATA_RATES_G + MAX_SUPPORTED_MCS + MAX_SUPPORTED_11AC_RATES */
+#define MAX_SUPPORTED_RATES           58
+#define SU_MIMO                       0
+#define MU_MIMO                       1
+#define SU_MU_TYPE_CNT                2 /* traffic type, SU and MU */
+
+/* BF operation mode */
+#define TXBF_MODE_OFF                 0x05
+#define TXBF_MODE_AUTO                0x06
+#define TXBF_MODE_BFMER_AUTO          0x07
+
+static const u8 TX_HISTO_PER_THRES[TX_RATE_HISTO_PER_CNT - 1] = {6, 12, 20, 30};
+
+enum {
+	MWL8864 = 0,
+	MWL8897,
+	MWL8964,
+	MWL8997,
+	MWLUNKNOWN,
+};
+
+enum mwl_bus {
+	MWL_BUS_PCIE,
+	MWL_BUS_SDIO,
+};
+
+enum {
+	AP_MODE_11AC = 0x10,         /* generic 11ac indication mode */
+	AP_MODE_2_4GHZ_11AC_MIXED = 0x17,
+};
+
+enum {
+	AMPDU_NO_STREAM = 0,
+	AMPDU_STREAM_NEW,
+	AMPDU_STREAM_IN_PROGRESS,
+	AMPDU_STREAM_ACTIVE,
+};
+
+enum {
+	LED_BLINK_RATE_LOW = 0x1,
+	LED_BLINK_RATE_MID,
+	LED_BLINK_RATE_HIGH,
+};
+
+struct mwl_chip_info {
+	const char *part_name;
+	const char *fw_image;
+	const char *cal_file;
+	const char *txpwrlmt_file;
+	int antenna_tx;
+	int antenna_rx;
+};
+
+struct mwl_device_pwr_tbl {
+	u8 channel;
+	u8 tx_pwr[SYSADPT_TX_PWR_LEVEL_TOTAL_SC4];
+	u8 dfs_capable;
+	u8 ax_ant;
+	u8 cdd;
+};
+
+struct mwl_tx_pwr_tbl {
+	u8 channel;
+	u8 setcap;
+	u16 txantenna2;
+	u16 tx_power[SYSADPT_TX_POWER_LEVEL_TOTAL];
+	bool cdd;
+};
+
+struct mwl_hw_data {
+	u32 fw_release_num;          /* MajNbr:MinNbr:SubMin:PatchLevel */
+	u8 hw_version;               /* plain number indicating version */
+	unsigned char mac_addr[ETH_ALEN]; /* well known -> AA:BB:CC:DD:EE:FF */
+};
+
+struct mwl_ampdu_stream {
+	struct ieee80211_sta *sta;
+	u8 tid;
+	u8 state;
+	int idx;
+};
+
+struct mwl_stnid {
+	int macid;                  /* keep macid for related stnid */
+	u16 aid;                    /* keep aid for related stnid   */
+};
+
+struct otp_data {
+	u8 buf[SYSADPT_OTP_BUF_SIZE];
+	u32 len; /* Actual size of data in buf[] */
+};
+
+struct txpwrlmt_cfg_data {
+	u8 buf[SYSADPT_TXPWRLMT_CFG_BUF_SIZE];
+	u32 len; /* Actual size of data in buf[] */
+};
+
+struct mwl_priv {
+	struct ieee80211_hw *hw;
+	struct device *dev;
+	struct firmware *fw_ucode;
+	struct firmware *cal_data;
+	struct firmware *txpwrlmt_file;
+	struct otp_data otp_data;
+	struct txpwrlmt_cfg_data txpwrlmt_data;
+	bool fw_device_pwrtbl;
+	bool forbidden_setting;
+	bool regulatory_set;
+	u32 fw_region_code;
+	char fw_alpha2[2];
+	u8 number_of_channels;
+	struct mwl_device_pwr_tbl device_pwr_tbl[SYSADPT_MAX_NUM_CHANNELS];
+	int chip_type;
+
+	bool use_short_slot;
+	bool use_short_preamble;
+
+	struct {
+		enum mwl_bus bus;
+		const struct mwl_hif_ops *ops;
+		void *priv;
+	} hif;
+
+	struct device_node *dt_node;
+	struct device_node *pwr_node;
+	bool disable_2g;
+	bool disable_5g;
+	int antenna_tx;
+	int antenna_rx;
+	bool tx_amsdu;
+	bool dump_hostcmd;
+	bool dump_probe;
+
+	struct mwl_tx_pwr_tbl tx_pwr_tbl[SYSADPT_MAX_NUM_CHANNELS];
+	bool cdd;
+	u16 txantenna2;
+	u8 powinited;
+	u8 pwr_level;
+	u16 max_tx_pow[SYSADPT_TX_GRP_PWR_LEVEL_TOTAL]; /* max tx power (dBm) */
+	u16 target_powers[SYSADPT_TX_GRP_PWR_LEVEL_TOTAL]; /* target powers   */
+
+	struct mutex fwcmd_mutex;    /* for firmware command         */
+	unsigned short *pcmd_buf;    /* pointer to CmdBuf (virtual)  */
+	dma_addr_t pphys_cmd_buf;    /* pointer to CmdBuf (physical) */
+	bool in_send_cmd;
+	bool cmd_timeout;
+	bool rmmod;
+	int heartbeat;
+	u32 pre_jiffies;
+	bool heartbeating;
+	struct work_struct heartbeat_handle;
+
+	int irq;
+	struct mwl_hw_data hw_data;  /* Adapter HW specific info     */
+
+	struct timer_list period_timer;
+
+	/* keep survey information */
+	bool sw_scanning;
+	int survey_info_idx;
+	struct mwl_survey_info survey_info[SYSADPT_MAX_NUM_CHANNELS];
+	struct mwl_survey_info cur_survey_info;
+
+	s8 noise;                    /* Most recently reported noise in dBm */
+
+	struct ieee80211_supported_band band_24;
+	struct ieee80211_channel channels_24[BAND_24_CHANNEL_NUM];
+	struct ieee80211_rate rates_24[BAND_24_RATE_NUM];
+	struct ieee80211_supported_band band_50;
+	struct ieee80211_channel channels_50[BAND_50_CHANNEL_NUM];
+	struct ieee80211_rate rates_50[BAND_50_RATE_NUM];
+
+	u32 ap_macids_supported;
+	u32 sta_macids_supported;
+	u32 macids_used;
+	u32 running_bsses;           /* bitmap of running BSSes             */
+
+	struct {
+		spinlock_t vif_lock;         /* for private interface info  */
+		struct list_head vif_list;   /* List of interfaces.         */
+	} ____cacheline_aligned_in_smp;
+
+	struct {
+		spinlock_t sta_lock;         /* for private sta info        */
+		struct list_head sta_list;   /* List of stations            */
+	} ____cacheline_aligned_in_smp;
+
+	/* ampdu stream information */
+	/* for ampdu stream */
+	int ampdu_num;
+	struct {
+		spinlock_t stream_lock;      /* for BA stream               */
+		struct mwl_ampdu_stream *ampdu;
+	} ____cacheline_aligned_in_smp;
+	struct work_struct watchdog_ba_handle;
+
+	/* station id */
+	int stnid_num;
+	struct {
+		spinlock_t stnid_lock;      /* for station id              */
+		struct mwl_stnid *stnid;
+		u16 available_stnid;
+	} ____cacheline_aligned_in_smp;
+
+	bool radio_on;
+	bool radio_short_preamble;
+	bool wmm_enabled;
+	struct ieee80211_tx_queue_params wmm_params[SYSADPT_TX_WMM_QUEUES];
+
+	struct work_struct account_handle;
+
+	bool wds_check;
+	struct work_struct wds_check_handle;
+	u8 wds_check_sta[ETH_ALEN];
+
+	bool dfs_test;
+	bool csa_active;
+	struct work_struct chnl_switch_handle;
+	enum nl80211_dfs_regions dfs_region;
+	u16 dfs_chirp_count_min;
+	u16 dfs_chirp_time_interval;
+	u16 dfs_pw_filter;
+	u16 dfs_min_num_radar;
+	u16 dfs_min_pri_count;
+
+	u8 bf_type;
+
+	struct thermal_cooling_device *cdev;
+	u32 throttle_state;
+	u32 quiet_period;
+	int temperature;
+
+	u8 led_blink_enable;
+	u8 led_blink_rate;
+
+	struct dentry *debugfs_phy;
+	u32 reg_type;
+	u32 reg_offset;
+	u32 reg_value;
+	int ra_aid;
+	int ba_aid;
+	int fixed_rate;
+	bool coredump_text;
+	u32 ra_tx_attempt[2][6];
+};
+
+struct beacon_info {
+	bool valid;
+	u16 cap_info;
+	u8 power_constraint;
+	u8 b_rate_set[SYSADPT_MAX_DATA_RATES_G];
+	u8 op_rate_set[SYSADPT_MAX_DATA_RATES_G];
+	u8 ie_list_ht[148];
+	u8 ie_list_vht[24];
+	u8 *ie_wmm_ptr;
+	u8 *ie_wsc_ptr;
+	u8 *ie_rsn_ptr;
+	u8 *ie_rsn48_ptr;
+	u8 *ie_mde_ptr;
+	u8 *ie_ht_ptr;
+	u8 *ie_vht_ptr;
+	u8 *ie_country_ptr;
+	u8 *ie_meshid_ptr;
+	u8 *ie_meshcfg_ptr;
+	u8 *ie_meshchsw_ptr;
+	u8 ie_wmm_len;
+	u8 ie_wsc_len;
+	u8 ie_rsn_len;
+	u8 ie_rsn48_len;
+	u8 ie_mde_len;
+	u8 ie_ht_len;
+	u8 ie_vht_len;
+	u8 ie_country_len;
+	u8 ie_meshid_len;
+	u8 ie_meshcfg_len;
+	u8 ie_meshchsw_len;
+};
+
+struct mwl_vif {
+	struct list_head list;
+	enum nl80211_iftype type;
+	int macid;       /* Firmware macid for this vif.  */
+	u16 seqno;       /* Non AMPDU sequence number assigned by driver.  */
+	struct {         /* Saved WEP keys */
+		u8 enabled;
+		u8 key[sizeof(struct ieee80211_key_conf) + WLAN_KEY_LEN_WEP104];
+	} wep_key_conf[NUM_WEP_KEYS];
+	u8 bssid[ETH_ALEN];          /* BSSID */
+	u8 sta_mac[ETH_ALEN];        /* Station mac address */
+	/* A flag to indicate is HW crypto is enabled for this bssid */
+	bool is_hw_crypto_enabled;
+	/* Indicate if this is station mode */
+	struct beacon_info beacon_info;
+	bool set_beacon;
+	int basic_rate_idx;
+	u8 broadcast_ssid;
+	u16 iv16;
+	u32 iv32;
+	s8 keyidx;
+};
+
+struct mwl_tx_info {
+	unsigned long start_time;
+	u32 pkts;
+};
+
+struct mwl_amsdu_frag {
+	struct sk_buff *skb;
+	u8 *cur_pos;
+	unsigned long jiffies;
+	u8 pad;
+	u8 num;
+};
+
+struct mwl_amsdu_ctrl {
+	struct mwl_amsdu_frag frag[SYSADPT_TX_WMM_QUEUES];
+	u8 cap;
+};
+
+struct mwl_tx_ba_stats {
+	u8 ba_hole;     /* Total pkt not acked in a BA bitmap */
+	u8 ba_expected; /* Total Tx pkt expected to be acked  */
+	u8 no_ba;       /* No BA is received                  */
+	u8 pad;         /* Unused                             */
+};
+
+struct mwl_tx_ba_hist {
+	u16 index;      /* Current buffer index               */
+	u8 type;        /* 0:SU, 1: MU                        */
+	bool enable;
+	struct mwl_tx_ba_stats *ba_stats;
+};
+
+struct mwl_tx_hist_data {
+	u32 rateinfo;
+	u32 cnt;
+	/* store according to TX_HISTO_PER_THRES threshold    */
+	u32 per[TX_RATE_HISTO_PER_CNT];
+};
+
+struct mwl_tx_hist {
+	struct mwl_tx_hist_data su_rate[MAX_SUPPORTED_RATES];
+	struct mwl_tx_hist_data mu_rate
+		[QS_NUM_SUPPORTED_11AC_NSS - 1][QS_NUM_SUPPORTED_11AC_BW]
+		[QS_NUM_SUPPORTED_GI][QS_NUM_SUPPORTED_11AC_MCS];
+	struct mwl_tx_hist_data custom_rate[TX_RATE_HISTO_CUSTOM_CNT];
+	/* Current rate for 0:SU, 1:MU         */
+	u32 cur_rate_info[SU_MU_TYPE_CNT];
+	/* Total tx attempt cnt for 0:SU, 1:MU */
+	u32 total_tx_cnt[SU_MU_TYPE_CNT];
+};
+
+struct mwl_sta {
+	struct list_head list;
+	struct mwl_vif *mwl_vif;
+	u16 stnid;
+	u16 sta_stnid;
+	bool wds;
+	bool is_mesh_node;
+	bool is_ampdu_allowed;
+	struct mwl_tx_info tx_stats[MWL_MAX_TID];
+	u32 check_ba_failed[MWL_MAX_TID];
+	struct mwl_tx_ba_hist ba_hist;
+	bool is_amsdu_allowed;
+	bool is_key_set;
+	/* for amsdu aggregation */
+	struct {
+		spinlock_t amsdu_lock;   /* for amsdu */
+		struct mwl_amsdu_ctrl amsdu_ctrl;
+	} ____cacheline_aligned_in_smp;
+	struct mwl_tx_hist tx_hist;
+	u32 tx_rate_info;
+	u16 rx_format;
+	u16 rx_nss;
+	u16 rx_bw;
+	u16 rx_gi;
+	u16 rx_rate_mcs;
+	u8 rx_signal;
+	u16 iv16;
+	u32 iv32;
+};
+
+static inline struct mwl_vif *mwl_dev_get_vif(const struct ieee80211_vif *vif)
+{
+	return (struct mwl_vif *)&vif->drv_priv;
+}
+
+static inline struct mwl_sta *mwl_dev_get_sta(const struct ieee80211_sta *sta)
+{
+	return (struct mwl_sta *)&sta->drv_priv;
+}
+
+struct ieee80211_hw *mwl_alloc_hw(int bus_type,
+				  int chip_type,
+				  struct device *dev,
+				  const struct mwl_hif_ops *ops,
+				  size_t hif_data_len);
+
+void mwl_free_hw(struct ieee80211_hw *hw);
+
+int mwl_init_hw(struct ieee80211_hw *hw, const char *fw_name,
+		const char *cal_name, const char *txpwrlmt_name);
+
+void mwl_deinit_hw(struct ieee80211_hw *hw);
+
+/* Defined in mac80211.c. */
+extern const struct ieee80211_ops mwl_mac80211_ops;
+
+#endif /* _CORE_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/debugfs.c b/drivers/net/wireless/marvell/mwlwifi/debugfs.c
new file mode 100644
index 000000000000..e375806a7111
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/debugfs.c
@@ -0,0 +1,2201 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements debug fs related functions. */
+
+#include <linux/debugfs.h>
+#include <linux/etherdevice.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "utils.h"
+#include "thermal.h"
+#include "hif/fwcmd.h"
+#include "hif/hif-ops.h"
+#include "debugfs.h"
+
+#define MWLWIFI_DEBUGFS_ADD_FILE(name) do { \
+	if (!debugfs_create_file(#name, 0644, priv->debugfs_phy, \
+				 priv, &mwl_debugfs_##name##_fops)) \
+		return; \
+} while (0)
+
+#define MWLWIFI_DEBUGFS_FILE_OPS(name) \
+static const struct file_operations mwl_debugfs_##name##_fops = { \
+	.read = mwl_debugfs_##name##_read, \
+	.write = mwl_debugfs_##name##_write, \
+	.open = simple_open, \
+}
+
+#define MWLWIFI_DEBUGFS_FILE_READ_OPS(name) \
+static const struct file_operations mwl_debugfs_##name##_fops = { \
+	.read = mwl_debugfs_##name##_read, \
+	.open = simple_open, \
+}
+
+#define MWLWIFI_DEBUGFS_FILE_WRITE_OPS(name) \
+static const struct file_operations mwl_debugfs_##name##_fops = { \
+	.write = mwl_debugfs_##name##_write, \
+	.open = simple_open, \
+}
+
+static const char chipname[MWLUNKNOWN][8] = {
+	"88W8864",
+	"88W8897",
+	"88W8964",
+	"88W8997"
+};
+
+static void dump_data(char *p, int size, int *len, u8 *data,
+		      int data_len, char *title)
+{
+	int cur_byte = 0;
+	int i;
+
+	*len += scnprintf(p + *len, size - *len, "%s\n", title);
+
+	for (cur_byte = 0; cur_byte < data_len; cur_byte += 8) {
+		if ((cur_byte + 8) < data_len) {
+			for (i = 0; i < 8; i++)
+				*len += scnprintf(p + *len, size - *len,
+						  "0x%02x ",
+						  *(data + cur_byte + i));
+			*len += scnprintf(p + *len, size - *len, "\n");
+		} else {
+			for (i = 0; i < (data_len - cur_byte); i++)
+				*len += scnprintf(p + *len, size - *len,
+						  "0x%02x ",
+						  *(data + cur_byte + i));
+			*len += scnprintf(p + *len, size - *len, "\n");
+			break;
+		}
+	}
+}
+
+static void _dump_tx_hist_mu(char *p, int size, int *len, bool *printed,
+			     u32 *total, u8 nss, u8 bw, u8 mcs, u8 sgi,
+			     struct mwl_sta *sta_info)
+{
+	char *bw_str[4] = {"ht20", "ht40", "ht80", "ht160"};
+	char *sgi_str[2] = {"lgi", "sgi"};
+	struct mwl_tx_hist_data *tx_hist_data;
+	u32 cnt, rateinfo, per0, per1, per2, per3, per4, ratemask;
+
+	tx_hist_data = &sta_info->tx_hist.mu_rate[nss][bw][sgi][mcs];
+	cnt = le32_to_cpu(tx_hist_data->cnt);
+	rateinfo = le32_to_cpu(tx_hist_data->rateinfo);
+	if (cnt && (rateinfo > 0)) {
+		*total += cnt;
+		per4 = le32_to_cpu(tx_hist_data->per[4]);
+		per3 = le32_to_cpu(tx_hist_data->per[3]);
+		per2 = le32_to_cpu(tx_hist_data->per[2]);
+		per1 = le32_to_cpu(tx_hist_data->per[1]);
+		per0 = le32_to_cpu(tx_hist_data->per[0]);
+		if (!*printed) {
+			*len += scnprintf(p + *len, size - *len,
+				"%s %26s  <%2d %8s%2d%8s%2d%8s%2d%8s%2d\n",
+				"MU_MIMO rate", " PER%", TX_HISTO_PER_THRES[0],
+				">=", TX_HISTO_PER_THRES[0],
+				">=", TX_HISTO_PER_THRES[1],
+				">=", TX_HISTO_PER_THRES[2],
+				">=", TX_HISTO_PER_THRES[3]);
+			*len += scnprintf(p + *len, size - *len,
+				"TOTAL MPDU tx pkt: %d\n",
+				sta_info->tx_hist.total_tx_cnt[MU_MIMO]);
+				*printed = true;
+		}
+		if ((rateinfo & 0x3) == 0)
+			ratemask = 0xfff;
+		else
+			ratemask = 0xffff;
+		if ((sta_info->tx_hist.cur_rate_info[MU_MIMO] & ratemask) ==
+		    (rateinfo & ratemask))
+			 /* mark as current rate */
+			*len += scnprintf(p + *len, size - *len, "*");
+		else
+			*len += scnprintf(p + *len, size - *len, " ");
+		*len += scnprintf(p + *len, size - *len,
+			"%5s_%3s_%1dSS_MCS%2d: %10u, %9d, %9d, %9d, %9d, %9d\n",
+			bw_str[bw], sgi_str[sgi], (nss + 1), mcs, cnt, per0,
+			per1, per2, per3, per4);
+	}
+}
+
+static void dump_tx_hist_mu(char *p, int size, int *len, bool *printed,
+			    u32 *total, struct mwl_sta *sta_info)
+{
+	u8 nss, bw, mcs, sgi;
+
+	for (nss = 0; nss < (QS_NUM_SUPPORTED_11AC_NSS - 1); nss++) {
+		for (bw = 0; bw < QS_NUM_SUPPORTED_11AC_BW; bw++) {
+			for (mcs = 0; mcs < QS_NUM_SUPPORTED_11AC_MCS; mcs++) {
+				for (sgi = 0; sgi < QS_NUM_SUPPORTED_GI;
+				     sgi++) {
+					_dump_tx_hist_mu(p, size, len, printed,
+							 total, nss, bw, mcs,
+							 sgi, sta_info);
+				}
+			}
+		}
+	}
+}
+
+
+static void dump_tx_hist_su(char *p, int size, int *len, bool su, bool *printed,
+			    u32 *total, struct mwl_sta *sta_info)
+{
+	int g_rate[14] = {1, 2, 5, 11, 22, 6, 9, 12, 18, 24, 36, 48, 54, 72};
+	char *bw_str[4] = {"ht20", "ht40", "ht80", "ht160"};
+	char *sgi_str[2] = {"lgi", "sgi"};
+	char title_str[32];
+	struct mwl_tx_hist *tx_hist;
+	struct mwl_tx_hist_data *tx_hist_data;
+	u32 j, loopcnt;
+	u32 cnt, rateinfo, per0, per1, per2, per3, per4, ratemask;
+	u8 format, bw, sgi, mcs, nss;
+
+	tx_hist = &sta_info->tx_hist;
+	if (su) {
+		loopcnt = MAX_SUPPORTED_RATES;
+		tx_hist_data = &tx_hist->su_rate[0];
+	} else {
+		loopcnt = TX_RATE_HISTO_CUSTOM_CNT;
+		tx_hist_data = &tx_hist->custom_rate[0];
+	}
+
+	for (j = 0; j < loopcnt; j++) {
+		cnt = le32_to_cpu(tx_hist_data[j].cnt);
+		rateinfo = le32_to_cpu(tx_hist_data[j].rateinfo);
+		if (cnt && (rateinfo > 0)) {
+			*total += cnt;
+			per4 = le32_to_cpu(tx_hist_data[j].per[4]);
+			per3 = le32_to_cpu(tx_hist_data[j].per[3]);
+			per2 = le32_to_cpu(tx_hist_data[j].per[2]);
+			per1 = le32_to_cpu(tx_hist_data[j].per[1]);
+			per0 = le32_to_cpu(tx_hist_data[j].per[0]);
+			if (!*printed) {
+				*len += scnprintf(p + *len, size - *len,
+				"%s %26s  <%2d %8s%2d%8s%2d%8s%2d%8s%2d\n",
+				su ? "SU_MIMO rate" : " Custom rate",
+				" PER%", TX_HISTO_PER_THRES[0],
+				">=", TX_HISTO_PER_THRES[0],
+				">=", TX_HISTO_PER_THRES[1],
+				">=", TX_HISTO_PER_THRES[2],
+				">=", TX_HISTO_PER_THRES[3]);
+			*len += scnprintf(p + *len, size - *len,
+				"TOTAL MPDU tx pkt: %d\n",
+				tx_hist->total_tx_cnt[SU_MIMO]);
+				*printed = true;
+			}
+			format = rateinfo & MWL_TX_RATE_FORMAT_MASK;
+			bw = (rateinfo & MWL_TX_RATE_BANDWIDTH_MASK) >>
+				MWL_TX_RATE_BANDWIDTH_SHIFT;
+			sgi = (rateinfo & MWL_TX_RATE_SHORTGI_MASK) >>
+				MWL_TX_RATE_SHORTGI_SHIFT;
+			mcs = (rateinfo & MWL_TX_RATE_RATEIDMCS_MASK) >>
+				MWL_TX_RATE_RATEIDMCS_SHIFT;
+			if (format == TX_RATE_FORMAT_LEGACY)
+				ratemask = 0xfff;
+			else
+				ratemask = 0xffff;
+			if ((tx_hist->cur_rate_info[SU_MIMO] & ratemask) ==
+			    (rateinfo & ratemask))
+				/* mark as current rate */
+				*len += scnprintf(p + *len, size - *len, "*");
+			else
+				*len += scnprintf(p + *len, size - *len, " ");
+			if (format == TX_RATE_FORMAT_LEGACY) {
+				if (mcs == 2) {
+					*len += scnprintf(p + *len, size - *len,
+					"%s %10u, %9d, %9d, %9d, %9d, %9d\n",
+					"5.5Mbps             :", cnt, per0,
+					per1, per2, per3, per4);
+				} else {
+					sprintf(title_str,
+						"%-3dMbps             :",
+						g_rate[mcs]);
+					*len += scnprintf(p + *len, size - *len,
+					"%s %10u, %9d, %9d, %9d, %9d, %9d\n",
+					title_str, cnt, per0, per1, per2, per3,
+					per4);
+				}
+			} else if (format ==  TX_RATE_FORMAT_11N) {
+				sprintf(title_str, "%4s_%3s_MCS%2d	    :",
+					bw_str[bw], sgi_str[sgi], mcs);
+				*len += scnprintf(p + *len, size - *len,
+					"%s %10u, %9d, %9d, %9d, %9d, %9d\n",
+					title_str, cnt, per0, per1, per2, per3,
+					per4);
+			} else {
+				nss = (mcs >> 4);
+				sprintf(title_str, "%5s_%3s_%1dSS_MCS%2d :",
+					bw_str[bw], sgi_str[sgi], (nss+1),
+					(mcs & 0xf));
+				*len += scnprintf(p + *len, size - *len,
+					"%s %10u, %9d, %9d, %9d, %9d, %9d\n",
+					title_str, cnt, per0, per1, per2, per3,
+					per4);
+			}
+		}
+	}
+}
+
+static void dump_tx_hist(char *p, int size, int *len, struct mwl_sta *sta_info)
+{
+	int type;
+	bool printed, su;
+	u32 total;
+
+	for (type = 0; type <= SU_MU_TYPE_CNT; type++) {
+		printed = false;
+		total = 0;
+		if (type == MU_MIMO) {
+			dump_tx_hist_mu(p, size, len, &printed,
+					&total, sta_info);
+		} else {
+			su = (type == SU_MIMO) ? true : false;
+			dump_tx_hist_su(p, size, len, su, &printed,
+					&total, sta_info);
+		}
+		if (printed)
+			*len += scnprintf(p + *len, size - *len,
+					  "  TOTAL              : %10u\n\n",
+					  total);
+	}
+}
+
+static void core_dump_file(u8 *valbuf, u32 length, u32 region, u32 address,
+			   u32 append, u32 totallen, bool textmode)
+{
+	struct file *filp_core = NULL;
+	char file_name[40];
+	u8 *buf = kmalloc(length * 3, GFP_KERNEL);
+	u8 *data_p = buf;
+	u32 i, j = 0;
+
+	if (!buf)
+		return;
+
+	memset(file_name, 0, sizeof(file_name));
+	sprintf(file_name, "/dev/shm/coredump-%x-%x",
+		region, (region + totallen));
+
+	if (append)
+		filp_core = filp_open(file_name, O_RDWR | O_APPEND, 0);
+	else
+		filp_core = filp_open(file_name, O_RDWR | O_CREAT | O_TRUNC, 0);
+
+	if (!IS_ERR(filp_core)) {
+		if (textmode) {
+			for (i = 0; i < length; i += 4) {
+				u32 val = 0;
+
+				val = le32_to_cpu(*(__le32 *)(&valbuf[i]));
+
+				if (i % 16 == 0) {
+					sprintf(buf + j, "\n0x%08x",
+						(int)(address + i));
+					j = strlen(buf);
+				}
+				sprintf(buf + j, "  %08x", val);
+				j = strlen(buf);
+			}
+			data_p = buf + j;
+			data_p += sprintf(data_p, "\n");
+			__kernel_write(filp_core, buf, strlen(buf),
+				       &filp_core->f_pos);
+		} else
+			__kernel_write(filp_core, valbuf, length,
+				       &filp_core->f_pos);
+
+		filp_close(filp_core, current->files);
+	}
+
+	kfree(buf);
+}
+
+static ssize_t mwl_debugfs_info_read(struct file *file, char __user *ubuf,
+				     size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	int tx_num = 4, rx_num = 4;
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len,
+			 "driver name: %s\n",
+			 mwl_hif_get_driver_name(priv->hw));
+	len += scnprintf(p + len, size - len, "chip type: %s\n",
+			 chipname[priv->chip_type]);
+	len += scnprintf(p + len, size - len,
+			 "hw version: %X\n", priv->hw_data.hw_version);
+	len += scnprintf(p + len, size - len,
+			 "driver version: %s\n",
+			 mwl_hif_get_driver_version(priv->hw));
+	len += scnprintf(p + len, size - len, "firmware version: 0x%08x\n",
+			 priv->hw_data.fw_release_num);
+	len += scnprintf(p + len, size - len,
+			 "power table loaded from dts: %s\n",
+			 priv->forbidden_setting ? "no" : "yes");
+	len += scnprintf(p + len, size - len, "firmware region code: 0x%x\n",
+			 priv->fw_region_code);
+	len += scnprintf(p + len, size - len,
+			 "mac address: %pM\n", priv->hw_data.mac_addr);
+	len += scnprintf(p + len, size - len,
+			 "2g: %s\n", priv->disable_2g ? "disable" : "enable");
+	len += scnprintf(p + len, size - len,
+			 "5g: %s\n", priv->disable_5g ? "disable" : "enable");
+	if (priv->antenna_tx == ANTENNA_TX_2)
+		tx_num = 2;
+	else if (priv->antenna_tx == ANTENNA_TX_3)
+		tx_num = 3;
+	if (priv->antenna_rx == ANTENNA_RX_2)
+		rx_num = 2;
+	else if (priv->antenna_rx == ANTENNA_RX_3)
+		rx_num = 3;
+	len += scnprintf(p + len, size - len, "antenna: %d %d\n",
+			 tx_num, rx_num);
+	len += scnprintf(p + len, size - len, "irq number: %d\n", priv->irq);
+	len += scnprintf(p + len, size - len, "ap macid support: %08x\n",
+			 priv->ap_macids_supported);
+	len += scnprintf(p + len, size - len, "sta macid support: %08x\n",
+			 priv->sta_macids_supported);
+	len += scnprintf(p + len, size - len,
+			 "macid used: %08x\n", priv->macids_used);
+	len += scnprintf(p + len, size - len,
+			 "radio: %s\n", priv->radio_on ? "enable" : "disable");
+	len += mwl_hif_get_info(priv->hw, p + len, size - len);
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_tx_status_read(struct file *file, char __user *ubuf,
+					  size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += mwl_hif_get_tx_status(priv->hw, p + len, size - len);
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_rx_status_read(struct file *file, char __user *ubuf,
+					  size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += mwl_hif_get_rx_status(priv->hw, p + len, size - len);
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_vif_read(struct file *file, char __user *ubuf,
+				    size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	struct mwl_vif *mwl_vif;
+	struct ieee80211_vif *vif;
+	char ssid[IEEE80211_MAX_SSID_LEN + 1];
+	struct cfg80211_chan_def *chan_def;
+	struct beacon_info *beacon_info;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	spin_lock_bh(&priv->vif_lock);
+	list_for_each_entry(mwl_vif, &priv->vif_list, list) {
+		vif = container_of((void *)mwl_vif, struct ieee80211_vif,
+				   drv_priv);
+		len += scnprintf(p + len, size - len,
+				 "macid: %d\n", mwl_vif->macid);
+		switch (vif->type) {
+		case NL80211_IFTYPE_AP:
+			len += scnprintf(p + len, size - len, "type: ap\n");
+			memcpy(ssid, vif->bss_conf.ssid,
+			       vif->bss_conf.ssid_len);
+			ssid[vif->bss_conf.ssid_len] = 0;
+			len += scnprintf(p + len, size - len,
+					 "ssid: %s\n", ssid);
+			len += scnprintf(p + len, size - len,
+					 "mac address: %pM\n", mwl_vif->bssid);
+			break;
+		case NL80211_IFTYPE_MESH_POINT:
+			len += scnprintf(p + len, size - len, "type: mesh\n");
+			len += scnprintf(p + len, size - len,
+					 "mac address: %pM\n", mwl_vif->bssid);
+			break;
+		case NL80211_IFTYPE_STATION:
+			len += scnprintf(p + len, size - len, "type: sta\n");
+			len += scnprintf(p + len, size - len,
+					 "mac address: %pM\n",
+					 mwl_vif->sta_mac);
+			break;
+		default:
+			len += scnprintf(p + len, size - len,
+					 "type: unknown\n");
+			break;
+		}
+		if (vif->chanctx_conf) {
+			chan_def = &vif->chanctx_conf->def;
+			len += scnprintf(p + len, size - len,
+					 "channel: %d: width: %d\n",
+					 chan_def->chan->hw_value,
+					 chan_def->width);
+			len += scnprintf(p + len, size - len,
+					 "freq: %d freq1: %d freq2: %d\n",
+					 chan_def->chan->center_freq,
+					 chan_def->center_freq1,
+					 chan_def->center_freq2);
+		}
+		len += scnprintf(p + len, size - len, "hw_crypto_enabled: %s\n",
+				 mwl_vif->is_hw_crypto_enabled ?
+				 "true" : "false");
+		len += scnprintf(p + len, size - len,
+				 "key idx: %d\n", mwl_vif->keyidx);
+		len += scnprintf(p + len, size - len,
+				 "IV: %08x%04x\n", mwl_vif->iv32,
+				 mwl_vif->iv16);
+		beacon_info = &mwl_vif->beacon_info;
+		dump_data(p, size, &len, beacon_info->ie_wmm_ptr,
+			  beacon_info->ie_wmm_len, "WMM:");
+		dump_data(p, size, &len, beacon_info->ie_rsn_ptr,
+			  beacon_info->ie_rsn_len, "RSN:");
+		dump_data(p, size, &len, beacon_info->ie_rsn48_ptr,
+			  beacon_info->ie_rsn48_len, "RSN48:");
+		dump_data(p, size, &len, beacon_info->ie_mde_ptr,
+			  beacon_info->ie_mde_len, "MDE:");
+		dump_data(p, size, &len, beacon_info->ie_ht_ptr,
+			  beacon_info->ie_ht_len, "HT:");
+		dump_data(p, size, &len, beacon_info->ie_vht_ptr,
+			  beacon_info->ie_vht_len, "VHT:");
+		if (vif->type == NL80211_IFTYPE_MESH_POINT) {
+			dump_data(p, size, &len, beacon_info->ie_meshid_ptr,
+				  beacon_info->ie_meshid_len, "MESHID:");
+			dump_data(p, size, &len, beacon_info->ie_meshcfg_ptr,
+				  beacon_info->ie_meshcfg_len, "MESHCFG:");
+			dump_data(p, size, &len, beacon_info->ie_meshchsw_ptr,
+				  beacon_info->ie_meshchsw_len, "MESHCHSW:");
+		}
+		len += scnprintf(p + len, size - len, "\n");
+	}
+	spin_unlock_bh(&priv->vif_lock);
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_sta_read(struct file *file, char __user *ubuf,
+				    size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	struct mwl_sta *sta_info;
+	struct ieee80211_sta *sta;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	spin_lock_bh(&priv->sta_lock);
+	list_for_each_entry(sta_info, &priv->sta_list, list) {
+		sta = container_of((void *)sta_info, struct ieee80211_sta,
+				   drv_priv);
+		len += scnprintf(p + len, size - len,
+				 "mac address: %pM\n", sta->addr);
+		len += scnprintf(p + len, size - len, "aid: %u\n", sta->aid);
+		len += scnprintf(p + len, size - len, "ampdu: %s\n",
+				 sta_info->is_ampdu_allowed ? "true" : "false");
+		len += scnprintf(p + len, size - len, "amsdu: %s\n",
+				 sta_info->is_amsdu_allowed ? "true" : "false");
+		len += scnprintf(p + len, size - len, "wds: %s\n",
+				 sta_info->wds ? "true" : "false");
+		len += scnprintf(p + len, size - len, "ba_hist: %s\n",
+				 sta_info->ba_hist.enable ?
+				 "enable" : "disable");
+		if (sta_info->is_amsdu_allowed) {
+			len += scnprintf(p + len, size - len,
+					 "amsdu cap: 0x%02x\n",
+					 sta_info->amsdu_ctrl.cap);
+		}
+		if (sta->ht_cap.ht_supported) {
+			len += scnprintf(p + len, size - len,
+					 "ht_cap: 0x%04x, ampdu: %02x, %02x\n",
+					 sta->ht_cap.cap,
+					 sta->ht_cap.ampdu_factor,
+					 sta->ht_cap.ampdu_density);
+			len += scnprintf(p + len, size - len,
+					 "rx_mask: 0x%02x, %02x, %02x, %02x\n",
+					 sta->ht_cap.mcs.rx_mask[0],
+					 sta->ht_cap.mcs.rx_mask[1],
+					 sta->ht_cap.mcs.rx_mask[2],
+					 sta->ht_cap.mcs.rx_mask[3]);
+		}
+		if (sta->vht_cap.vht_supported) {
+			len += scnprintf(p + len, size - len,
+					 "vht_cap: 0x%08x, mcs: %02x, %02x\n",
+					 sta->vht_cap.cap,
+					 sta->vht_cap.vht_mcs.rx_mcs_map,
+					 sta->vht_cap.vht_mcs.tx_mcs_map);
+		}
+		len += scnprintf(p + len, size - len, "rx_bw: %d, rx_nss: %d\n",
+				 sta->bandwidth, sta->rx_nss);
+		len += scnprintf(p + len, size - len,
+				 "tdls: %d, tdls_init: %d\n",
+				 sta->tdls, sta->tdls_initiator);
+		len += scnprintf(p + len, size - len, "wme: %d, mfp: %d\n",
+				 sta->wme, sta->mfp);
+		len += scnprintf(p + len, size - len, "IV: %08x%04x\n",
+				 sta_info->iv32, sta_info->iv16);
+		len += scnprintf(p + len, size - len, "\n");
+	}
+	spin_unlock_bh(&priv->sta_lock);
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_ampdu_read(struct file *file, char __user *ubuf,
+				      size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	struct mwl_ampdu_stream *stream;
+	int i;
+	struct mwl_sta *sta_info;
+	struct ieee80211_sta *sta;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	spin_lock_bh(&priv->stream_lock);
+	for (i = 0; i < priv->ampdu_num; i++) {
+		stream = &priv->ampdu[i];
+		if (!stream->state)
+			continue;
+		len += scnprintf(p + len, size - len, "stream: %d\n", i);
+		len += scnprintf(p + len, size - len, "idx: %u\n", stream->idx);
+		len += scnprintf(p + len, size - len,
+				 "state: %u\n", stream->state);
+		if (stream->sta) {
+			len += scnprintf(p + len, size - len,
+					 "mac address: %pM\n",
+					 stream->sta->addr);
+			len += scnprintf(p + len, size - len,
+					 "tid: %u\n", stream->tid);
+		}
+	}
+	spin_unlock_bh(&priv->stream_lock);
+	spin_lock_bh(&priv->sta_lock);
+	list_for_each_entry(sta_info, &priv->sta_list, list) {
+		for (i = 0; i < MWL_MAX_TID; i++) {
+			if (sta_info->check_ba_failed[i]) {
+				sta = container_of((void *)sta_info,
+						   struct ieee80211_sta,
+						   drv_priv);
+				len += scnprintf(p + len, size - len,
+						 "%pM(%d): %d\n",
+						 sta->addr, i,
+						 sta_info->check_ba_failed[i]);
+			}
+		}
+	}
+	spin_unlock_bh(&priv->sta_lock);
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_stnid_read(struct file *file, char __user *ubuf,
+				      size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	struct mwl_stnid *stnid;
+	int i;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	spin_lock_bh(&priv->stnid_lock);
+	for (i = 0; i < priv->stnid_num; i++) {
+		stnid = &priv->stnid[i];
+		if (!stnid->aid)
+			continue;
+		len += scnprintf(p + len, size - len,
+				 "stnid: %d macid: %d aid: %d\n",
+				 i + 1, stnid->macid, stnid->aid);
+	}
+	spin_unlock_bh(&priv->stnid_lock);
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_device_pwrtbl_read(struct file *file,
+					      char __user *ubuf,
+					      size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	int i, j;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len,
+			 "power table loaded from dts: %s\n",
+			 priv->forbidden_setting ? "no" : "yes");
+	len += scnprintf(p + len, size - len, "firmware region code: 0x%x\n",
+			 priv->fw_region_code);
+	len += scnprintf(p + len, size - len, "number of channel: %d\n",
+			 priv->number_of_channels);
+	for (i = 0; i < priv->number_of_channels; i++) {
+		len += scnprintf(p + len, size - len, "%3d ",
+				 priv->device_pwr_tbl[i].channel);
+		for (j = 0; j < SYSADPT_TX_POWER_LEVEL_TOTAL; j++)
+			len += scnprintf(p + len, size - len, "%3d ",
+					 priv->device_pwr_tbl[i].tx_pwr[j]);
+		len += scnprintf(p + len, size - len, "%3d ",
+				 priv->device_pwr_tbl[i].dfs_capable);
+		len += scnprintf(p + len, size - len, "%3d ",
+				 priv->device_pwr_tbl[i].ax_ant);
+		len += scnprintf(p + len, size - len, "%3d\n",
+				 priv->device_pwr_tbl[i].cdd);
+	}
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_txpwrlmt_read(struct file *file,
+					 char __user *ubuf,
+					 size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+
+	return simple_read_from_buffer(ubuf, count, ppos,
+				       priv->txpwrlmt_data.buf,
+				       priv->txpwrlmt_data.len);
+}
+
+static ssize_t mwl_debugfs_tx_amsdu_read(struct file *file,
+					 char __user *ubuf,
+					 size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len, "tx amsdu: %s\n",
+			 priv->tx_amsdu ? "enable" : "disable");
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_tx_amsdu_write(struct file *file,
+					  const char __user *ubuf,
+					  size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	int value;
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (kstrtoint(buf, 0, &value)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	priv->tx_amsdu = value ? true : false;
+
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_dump_hostcmd_read(struct file *file,
+					     char __user *ubuf,
+					     size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len, "dump_hostcmd: %s\n",
+			 priv->dump_hostcmd ? "enable" : "disable");
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_dump_hostcmd_write(struct file *file,
+					      const char __user *ubuf,
+					      size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	int value;
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (kstrtoint(buf, 0, &value)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	priv->dump_hostcmd = value ? true : false;
+
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_dump_probe_read(struct file *file,
+					   char __user *ubuf,
+					   size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len, "dump_probe: %s\n",
+			 priv->dump_probe ? "enable" : "disable");
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_dump_probe_write(struct file *file,
+					    const char __user *ubuf,
+					    size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	int value;
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (kstrtoint(buf, 0, &value)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	priv->dump_probe = value ? true : false;
+
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_heartbeat_read(struct file *file,
+					  char __user *ubuf,
+					  size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len, "heartbeat: %d\n",
+			 priv->heartbeat);
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_heartbeat_write(struct file *file,
+					   const char __user *ubuf,
+					   size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (kstrtoint(buf, 0, &priv->heartbeat)) {
+		ret = -EINVAL;
+		goto err;
+	}
+	priv->pre_jiffies = jiffies;
+
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_dfs_test_read(struct file *file,
+					 char __user *ubuf,
+					 size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len, "dfs_test: %s\n",
+			 priv->dfs_test ? "enable" : "disable");
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_dfs_test_write(struct file *file,
+					  const char __user *ubuf,
+					  size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	int value;
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (kstrtoint(buf, 0, &value)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	priv->dfs_test = value ? true : false;
+
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_dfs_channel_read(struct file *file,
+					    char __user *ubuf,
+					    size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *channel;
+	int i;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	sband = priv->hw->wiphy->bands[NL80211_BAND_5GHZ];
+	if (!sband) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	len += scnprintf(p + len, size - len, "\n");
+	for (i = 0; i < sband->n_channels; i++) {
+		channel = &sband->channels[i];
+		if (channel->flags & IEEE80211_CHAN_RADAR) {
+			len += scnprintf(p + len, size - len,
+					 "%d(%d): flags: %08x dfs_state: %d\n",
+					 channel->hw_value,
+					 channel->center_freq,
+					 channel->flags, channel->dfs_state);
+			len += scnprintf(p + len, size - len,
+					 "cac timer: %d ms\n",
+					 channel->dfs_cac_ms);
+		}
+	}
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+
+err:
+	free_page(page);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_dfs_channel_write(struct file *file,
+					     const char __user *ubuf,
+					     size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	struct ieee80211_supported_band *sband;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	int dfs_state = 0;
+	int cac_time = -1;
+	struct ieee80211_channel *channel;
+	int i;
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	sband = priv->hw->wiphy->bands[NL80211_BAND_5GHZ];
+	if (!sband) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	ret = sscanf(buf, "%d %d", &dfs_state, &cac_time);
+
+	if ((ret < 1) || (ret > 2)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	for (i = 0; i < sband->n_channels; i++) {
+		channel = &sband->channels[i];
+		if (channel->flags & IEEE80211_CHAN_RADAR) {
+			channel->dfs_state = dfs_state;
+			if (cac_time != -1)
+				channel->dfs_cac_ms = cac_time * 1000;
+		}
+	}
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_dfs_radar_read(struct file *file, char __user *ubuf,
+					  size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len,
+			 "csa_active: %d\n", priv->csa_active);
+	len += scnprintf(p + len, size - len,
+			 "dfs_region: %d\n", priv->dfs_region);
+	len += scnprintf(p + len, size - len,
+			 "chirp_count_min: %d\n", priv->dfs_chirp_count_min);
+	len += scnprintf(p + len, size - len, "chirp_time_interval: %d\n",
+			 priv->dfs_chirp_time_interval);
+	len += scnprintf(p + len, size - len,
+			 "pw_filter: %d\n", priv->dfs_pw_filter);
+	len += scnprintf(p + len, size - len,
+			 "min_num_radar: %d\n", priv->dfs_min_num_radar);
+	len += scnprintf(p + len, size - len,
+			 "min_pri_count: %d\n", priv->dfs_min_pri_count);
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_dfs_radar_write(struct file *file,
+					   const char __user *ubuf,
+					   size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+
+	wiphy_info(priv->hw->wiphy, "simulate radar detected\n");
+	ieee80211_radar_detected(priv->hw);
+
+	return count;
+}
+
+static ssize_t mwl_debugfs_thermal_read(struct file *file,
+					char __user *ubuf,
+					size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	mwl_fwcmd_get_temp(priv->hw, &priv->temperature);
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len, "quiet period: %d\n",
+			 priv->quiet_period);
+	len += scnprintf(p + len, size - len, "throttle state: %d\n",
+			 priv->throttle_state);
+	len += scnprintf(p + len, size - len, "temperature: %d\n",
+			 priv->temperature);
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_thermal_write(struct file *file,
+					 const char __user *ubuf,
+					 size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	int throttle_state;
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (kstrtoint(buf, 0, &throttle_state)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (throttle_state > SYSADPT_THERMAL_THROTTLE_MAX) {
+		wiphy_warn(priv->hw->wiphy,
+			   "throttle state %d is exceeding the limit %d\n",
+			   throttle_state, SYSADPT_THERMAL_THROTTLE_MAX);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	priv->throttle_state = throttle_state;
+	mwl_thermal_set_throttling(priv);
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_led_ctrl_read(struct file *file,
+					 char __user *ubuf,
+					 size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len, "led blink %s\n",
+			 priv->led_blink_enable ? "enable" : "disable");
+	len += scnprintf(p + len, size - len, "led blink rate: %d\n",
+			 priv->led_blink_rate);
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+
+	return ret;
+}
+
+static ssize_t mwl_debugfs_led_ctrl_write(struct file *file,
+					  const char __user *ubuf,
+					  size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	int enable, rate;
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	ret = sscanf(buf, "%x %x", &enable, &rate);
+
+	if ((ret != 1) && (ret != 2)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (enable && (ret != 2)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	ret = mwl_fwcmd_led_ctrl(priv->hw, enable, rate);
+
+	if (ret)
+		goto err;
+
+	priv->led_blink_enable = enable;
+	if (enable)
+		priv->led_blink_rate = rate;
+	else
+		priv->led_blink_rate = 0;
+
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_regrdwr_read(struct file *file, char __user *ubuf,
+					size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (*ppos)
+		return len;
+
+	if (!p)
+		return -ENOMEM;
+
+	if (!priv->reg_type) {
+		/* No command has been given */
+		len += scnprintf(p + len, size - len, "0");
+		ret = -EINVAL;
+		goto none;
+	}
+
+	/* Set command has been given */
+	if (priv->reg_value != UINT_MAX) {
+		ret = mwl_hif_reg_access(priv->hw, true);
+		goto done;
+	}
+	/* Get command has been given */
+	ret = mwl_hif_reg_access(priv->hw, false);
+
+done:
+	if (!ret)
+		len += scnprintf(p + len, size - len, "%u 0x%08x 0x%08x\n",
+				 priv->reg_type, priv->reg_offset,
+				 priv->reg_value);
+	else
+		len += scnprintf(p + len, size - len,
+				 "error: %d(%u 0x%08x 0x%08x)\n",
+				 ret, priv->reg_type, priv->reg_offset,
+				 priv->reg_value);
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+
+none:
+	free_page(page);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_regrdwr_write(struct file *file,
+					 const char __user *ubuf,
+					 size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	ssize_t ret;
+	u32 reg_type = 0, reg_offset = 0, reg_value = UINT_MAX;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	ret = sscanf(buf, "%u %x %x", &reg_type, &reg_offset, &reg_value);
+
+	if (!reg_type) {
+		ret = -EINVAL;
+		goto err;
+	} else {
+		priv->reg_type = reg_type;
+		priv->reg_offset = reg_offset;
+		priv->reg_value = reg_value;
+		ret = count;
+	}
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_ratetable_read(struct file *file, char __user *ubuf,
+					  size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	struct mwl_sta *sta_info;
+	struct ieee80211_sta *sta;
+	u8 addr[ETH_ALEN];
+	int table_size = (sizeof(__le32) * 2 * SYSADPT_MAX_RATE_ADAPT_RATES);
+	u8 *rate_table, *rate_idx;
+	u32 rate_info;
+	u8 fmt, stbc, bw, sgi, mcs, preamble_gf, power_id, ldpc, bf, ant;
+	int idx, rate, nss;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	if (!priv->ra_aid) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	spin_lock_bh(&priv->sta_lock);
+	list_for_each_entry(sta_info, &priv->sta_list, list) {
+		sta = container_of((void *)sta_info, struct ieee80211_sta,
+				   drv_priv);
+		if (priv->ra_aid == sta->aid) {
+			ether_addr_copy(addr, sta->addr);
+			break;
+		}
+	}
+	spin_unlock_bh(&priv->sta_lock);
+
+	rate_table = kzalloc(size, GFP_KERNEL);
+	if (!rate_table) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	ret = mwl_fwcmd_get_ratetable(priv->hw, addr, rate_table,
+				      table_size, 0);
+	if (ret) {
+		kfree(rate_table);
+		goto err;
+	}
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len,
+		"%3s %6s %5s %5s %5s %5s %5s %4s %2s %5s %4s %5s %5s\n",
+		"Num", "Fmt", "STBC", "BW", "SGI", "Nss", "RateId",
+		"GF/Pre", "PId", "LDPC", "BF", "TxAnt", "Rate");
+	idx = 0;
+	rate_idx = rate_table;
+	rate_info = le32_to_cpu(*(__le32 *)rate_idx);
+	while (rate_info) {
+		fmt = rate_info & MWL_TX_RATE_FORMAT_MASK;
+		stbc = (rate_info & MWL_TX_RATE_STBC_MASK) >>
+			MWL_TX_RATE_STBC_SHIFT;
+		bw = (rate_info & MWL_TX_RATE_BANDWIDTH_MASK) >>
+			MWL_TX_RATE_BANDWIDTH_SHIFT;
+		sgi = (rate_info & MWL_TX_RATE_SHORTGI_MASK) >>
+			MWL_TX_RATE_SHORTGI_SHIFT;
+		mcs = (rate_info & MWL_TX_RATE_RATEIDMCS_MASK) >>
+			MWL_TX_RATE_RATEIDMCS_SHIFT;
+		preamble_gf = (rate_info & MWL_TX_RATE_PREAMBLE_MASK) >>
+			MWL_TX_RATE_PREAMBLE_SHIFT;
+		power_id = (rate_info & MWL_TX_RATE_POWERID_MASK) >>
+			MWL_TX_RATE_POWERID_SHIFT;
+		ldpc = (rate_info & MWL_TX_RATE_ADVCODING_MASK) >>
+			MWL_TX_RATE_ADVCODING_SHIFT;
+		bf = (rate_info & MWL_TX_RATE_BF_MASK) >>
+			MWL_TX_RATE_BF_SHIFT;
+		ant = (rate_info & MWL_TX_RATE_ANTSELECT_MASK) >>
+			MWL_TX_RATE_ANTSELECT_SHIFT;
+
+		if (fmt == TX_RATE_FORMAT_11AC) {
+			rate = mcs & 0xf; /* 11ac, mcs[3:0]: rate      */
+			nss = mcs >> 4;   /* 11ac, mcs[6:4] = nss code */
+			nss++;  /* ddd 1 to correct Nss representation */
+		} else {
+			rate = mcs;
+			nss = 0;
+			if (fmt == TX_RATE_FORMAT_11N) {
+				if ((mcs >= 0) && (mcs < 8))
+					nss = 1;
+				else if ((mcs >= 8) && (mcs < 16))
+					nss = 2;
+				else if ((mcs >= 16) && (mcs < 24))
+					nss = 3;
+			}
+		}
+
+		len += scnprintf(p + len, size - len,
+			"%3d %5d %5d %5d %5d %5d %5d %5d %5d %5d %5d %5d %5d\n",
+			idx, (int)fmt, (int)stbc, (int)bw, (int)sgi, nss, rate,
+			(int)preamble_gf, (int)power_id, (int)ldpc, (int)bf,
+			(int)ant,
+			utils_get_phy_rate(fmt, bw, sgi, mcs));
+
+		idx++;
+		rate_idx += (2 * sizeof(__le32));
+		rate_info = le32_to_cpu(*(__le32 *)rate_idx);
+	}
+	len += scnprintf(p + len, size - len, "\n");
+
+	kfree(rate_table);
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+
+err:
+	free_page(page);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_ratetable_write(struct file *file,
+					   const char __user *ubuf,
+					   size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	int sta_aid;
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (kstrtoint(buf, 0, &sta_aid)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if ((sta_aid <= 0) || (sta_aid > SYSADPT_MAX_STA_SC4)) {
+		wiphy_warn(priv->hw->wiphy,
+			   "station aid is exceeding the limit %d\n", sta_aid);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	priv->ra_aid = sta_aid;
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_tx_hist_read(struct file *file, char __user *ubuf,
+					size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	struct ieee80211_sta *sta;
+	struct mwl_sta *sta_info;
+	ssize_t ret;
+
+	if (priv->chip_type != MWL8964)
+		return -EPERM;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len,
+			 "SU: <4:%d >=4:%d >=15:%d >=50:%d >=100:%d >=250:%d\n",
+			 priv->ra_tx_attempt[SU_MIMO][0],
+			 priv->ra_tx_attempt[SU_MIMO][1],
+			 priv->ra_tx_attempt[SU_MIMO][2],
+			 priv->ra_tx_attempt[SU_MIMO][3],
+			 priv->ra_tx_attempt[SU_MIMO][4],
+			 priv->ra_tx_attempt[SU_MIMO][5]);
+	len += scnprintf(p + len, size - len,
+			 "MU: <4:%d >=4:%d >=15:%d >=50:%d >=100:%d >=250:%d\n",
+			 priv->ra_tx_attempt[MU_MIMO][0],
+			 priv->ra_tx_attempt[MU_MIMO][1],
+			 priv->ra_tx_attempt[MU_MIMO][2],
+			 priv->ra_tx_attempt[MU_MIMO][3],
+			 priv->ra_tx_attempt[MU_MIMO][4],
+			 priv->ra_tx_attempt[MU_MIMO][5]);
+	spin_lock_bh(&priv->sta_lock);
+	list_for_each_entry(sta_info, &priv->sta_list, list) {
+		sta = container_of((void *)sta_info, struct ieee80211_sta,
+				   drv_priv);
+		len += scnprintf(p + len, size - len, "\nSTA %pM\n", sta->addr);
+		len += scnprintf(p + len, size - len,
+				 "============================\n");
+		dump_tx_hist(p, size, &len, sta_info);
+		len += scnprintf(p + len, size - len,
+				 "============================\n");
+	}
+	spin_unlock_bh(&priv->sta_lock);
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_tx_hist_write(struct file *file,
+					 const char __user *ubuf,
+					 size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	int reset;
+	struct mwl_sta *sta_info;
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (kstrtoint(buf, 0, &reset)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (!reset) {
+		memset(&priv->ra_tx_attempt, 0, 2 * 6 * sizeof(u32));
+		spin_lock_bh(&priv->sta_lock);
+		list_for_each_entry(sta_info, &priv->sta_list, list) {
+			memset(&sta_info->tx_hist, 0,
+			       sizeof(sta_info->tx_hist));
+		}
+		spin_unlock_bh(&priv->sta_lock);
+	}
+
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_ba_hist_read(struct file *file, char __user *ubuf,
+					size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	struct mwl_sta *sta_info;
+	struct mwl_tx_ba_stats *ba_stats;
+	u32 i, data;
+	u32 baholecnt, baexpcnt, bmap0cnt, nobacnt;
+	u8 bmap0flag, nobaflag;
+	char buff[500], file_location[20];
+	struct file *filp_bahisto;
+	u8 *data_p = buff;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	if (!priv->ba_aid) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	memset(buff, 0, sizeof(buff));
+	memset(file_location, 0, sizeof(file_location));
+	sprintf(file_location, "/tmp/ba_histo-%d", priv->ba_aid);
+
+	filp_bahisto = filp_open(file_location,
+				 O_RDWR | O_CREAT | O_TRUNC, 0);
+
+	if (IS_ERR(filp_bahisto)) {
+		ret = -EIO;
+		goto err;
+	}
+
+	sta_info = utils_find_sta_by_aid(priv, priv->ba_aid);
+	if (sta_info && sta_info->ba_hist.enable &&
+	    sta_info->ba_hist.ba_stats) {
+		ba_stats = sta_info->ba_hist.ba_stats;
+		len += scnprintf(p + len, size - len,
+				 "BA histogram aid: %d, stnid: %d type: %s\n",
+				 priv->ba_aid, sta_info->stnid,
+				 sta_info->ba_hist.type ? "MU" : "SU");
+		data_p += sprintf(data_p,
+				  "BA histogram aid: %d, stnid: %d type: %s\n",
+				  priv->ba_aid, sta_info->stnid,
+				  sta_info->ba_hist.type ? "MU" : "SU");
+		data_p += sprintf(data_p, "%8s,%8s,%8s,%8s\n",
+				  "BAhole", "Expect", "Bmap0", "NoBA");
+		data = *(u32 *)&ba_stats[0];
+		baholecnt = 0;
+		baexpcnt = 0;
+		bmap0cnt = 0;
+		nobacnt = 0;
+		for (i = 0; i < ACNT_BA_SIZE && data; i++) {
+			data = *(u32 *)&ba_stats[i];
+			if (data == 0)
+				break;
+
+			/* If no BA event does not happen, check BA hole and BA
+			 * expected to mark BA bitmap all 0 event
+			 */
+			if (!ba_stats[i].no_ba)
+				bmap0flag = (ba_stats[i].ba_hole ==
+					     ba_stats[i].ba_expected) ? 1 : 0;
+			else
+				bmap0flag = 0;
+			nobaflag = ba_stats[i].no_ba;
+
+			/* Buffer is full. Write to file and reset buf */
+			if ((strlen(buff) + 36) >= 500) {
+				__kernel_write(filp_bahisto, buff, strlen(buff),
+					       &filp_bahisto->f_pos);
+				mdelay(2);
+				memset(buff, 0, sizeof(buff));
+				data_p = buff;
+			}
+
+			data_p += sprintf(data_p, "%8d,%8d,",
+					  ba_stats[i].ba_hole,
+					  ba_stats[i].ba_expected);
+
+			baholecnt += ba_stats[i].ba_hole;
+			baexpcnt += ba_stats[i].ba_expected;
+			if (bmap0flag) {
+				data_p += sprintf(data_p, "       #,");
+				bmap0cnt++;
+			} else
+				data_p += sprintf(data_p, "%8d,", bmap0flag);
+			if (nobaflag) {
+				data_p += sprintf(data_p, "       *\n");
+				nobacnt++;
+			} else
+				data_p += sprintf(data_p, "%8d\n", nobaflag);
+		}
+
+		__kernel_write(filp_bahisto, buff, strlen(buff),
+			       &filp_bahisto->f_pos);
+		len += scnprintf(p + len, size - len,
+				 "hole: %d, expect: %d, bmap0: %d, noba: %d\n",
+				 baholecnt, baexpcnt, bmap0cnt, nobacnt);
+		len += scnprintf(p + len, size - len,
+				 "BA histogram data written to %s\n",
+				 file_location);
+	} else
+		len += scnprintf(p + len, size - len,
+				 "No BA histogram for sta aid: %d\n",
+				 priv->ba_aid);
+
+	filp_close(filp_bahisto, current->files);
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+
+err:
+	free_page(page);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_ba_hist_write(struct file *file,
+					 const char __user *ubuf,
+					 size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	int sta_aid;
+	struct mwl_sta *sta_info;
+	int size;
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (kstrtoint(buf, 0, &sta_aid)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if ((sta_aid <= 0) || (sta_aid > SYSADPT_MAX_STA_SC4)) {
+		wiphy_warn(priv->hw->wiphy,
+			   "station aid is exceeding the limit %d\n", sta_aid);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (priv->ba_aid) {
+		sta_info = utils_find_sta_by_aid(priv, priv->ba_aid);
+		if (sta_info) {
+			sta_info->ba_hist.enable = false;
+			kfree(sta_info->ba_hist.ba_stats);
+		}
+	}
+	priv->ba_aid = 0;
+	sta_info = utils_find_sta_by_aid(priv, sta_aid);
+	if (sta_info) {
+		sta_info->ba_hist.enable = true;
+		sta_info->ba_hist.index = 0;
+		size = sizeof(struct mwl_tx_ba_stats) * ACNT_BA_SIZE;
+		sta_info->ba_hist.ba_stats = kmalloc(size, GFP_KERNEL);
+		if (sta_info->ba_hist.ba_stats) {
+			memset(sta_info->ba_hist.ba_stats, 0, size);
+			priv->ba_aid = sta_aid;
+		}
+		ret = count;
+	} else
+		ret = -EINVAL;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_fixed_rate_read(struct file *file, char __user *ubuf,
+					   size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	ssize_t ret;
+
+	if (!p)
+		return -ENOMEM;
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len, "fixed rate: 0x%08x\n",
+			 priv->fixed_rate);
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+	free_page(page);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_fixed_rate_write(struct file *file,
+					    const char __user *ubuf,
+					    size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	ssize_t ret;
+	int fixed_rate = 0, fwcmd_ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	ret = sscanf(buf, "%08x", &fixed_rate);
+	if (!ret) {
+		ret = -EIO;
+		goto err;
+	}
+
+	priv->fixed_rate = fixed_rate;
+
+	if (fixed_rate != 0)
+		fwcmd_ret = mwl_fwcmd_set_rate_drop(priv->hw, 3,
+						    priv->fixed_rate, 0);
+	else
+		fwcmd_ret = mwl_fwcmd_set_rate_drop(priv->hw, 1,
+						    priv->fixed_rate, 0);
+	if (fwcmd_ret)
+		ret = -EIO;
+	else
+		ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_core_dump_read(struct file *file, char __user *ubuf,
+					  size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long page = get_zeroed_page(GFP_KERNEL);
+	char *p = (char *)page;
+	int len = 0, size = PAGE_SIZE;
+	struct coredump_cmd *core_dump = NULL;
+	struct coredump *cd = NULL;
+	char  *buff = NULL;
+	u32 i, offset;
+	u32 address, length;
+	ssize_t ret;
+
+	if (priv->chip_type != MWL8964)
+		return -EPERM;
+
+	if (*ppos)
+		return len;
+
+	if (!p)
+		return -ENOMEM;
+
+	core_dump = kmalloc(sizeof(*core_dump), GFP_ATOMIC);
+	if (!core_dump) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	buff = kmalloc(MAX_CORE_DUMP_BUFFER, GFP_ATOMIC);
+	if (!buff) {
+		ret = -ENOMEM;
+		goto err;
+	}
+	memset((char *)buff, 0, MAX_CORE_DUMP_BUFFER);
+
+	cd = kmalloc(sizeof(*cd), GFP_ATOMIC);
+	if (!cd) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	core_dump->context = 0;
+	core_dump->flags = 0;
+	core_dump->size_kb = 0;
+	if (mwl_fwcmd_get_fw_core_dump(priv->hw, core_dump, buff)) {
+		ret = -EIO;
+		goto err;
+	}
+	memcpy(cd, buff, sizeof(*cd));
+
+	len += scnprintf(p + len, size - len, "\n");
+	len += scnprintf(p + len, size - len, "Major Version : %d\n",
+			 cd->version_major);
+	len += scnprintf(p + len, size - len, "Minor Version : %d\n",
+			 cd->version_minor);
+	len += scnprintf(p + len, size - len, "Patch Version : %d\n",
+			 cd->version_patch);
+	len += scnprintf(p + len, size - len, "Num of Regions: %d\n",
+			 cd->num_regions);
+	len += scnprintf(p + len, size - len, "Num of Symbols: %d\n",
+			 cd->num_symbols);
+
+	for (i = 0; i < cd->num_regions; i++) {
+		address = le32_to_cpu(cd->region[i].address);
+		length = le32_to_cpu(cd->region[i].length);
+		len += scnprintf(p + len, size - len,
+				 "\ncd.region[%d]: address=%x, length=%x\n",
+				 i, address, length);
+
+		for (offset = 0; offset < length;
+		     offset += MAX_CORE_DUMP_BUFFER) {
+			core_dump->context = cpu_to_le32((i << 28) | offset);
+			core_dump->flags = 0;
+			core_dump->size_kb = 0;
+			if (mwl_fwcmd_get_fw_core_dump(priv->hw,
+			    core_dump, buff)) {
+				wiphy_info(priv->hw->wiphy,
+					   "region:%d offset:%x\n", i, offset);
+				break;
+			}
+			core_dump_file(buff, MAX_CORE_DUMP_BUFFER,
+				       address, address + offset,
+				       offset, length, priv->coredump_text);
+		}
+	}
+	len += scnprintf(p + len, size - len, "\n");
+
+	ret = simple_read_from_buffer(ubuf, count, ppos, p, len);
+
+err:
+	kfree(core_dump);
+	kfree(buff);
+	kfree(cd);
+	free_page(page);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_core_dump_write(struct file *file,
+					   const char __user *ubuf,
+					   size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	int text_mode;
+	ssize_t ret;
+
+	if (priv->chip_type != MWL8964)
+		return -EPERM;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (kstrtoint(buf, 0, &text_mode)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if ((text_mode < 0) || (text_mode > 1)) {
+		wiphy_warn(priv->hw->wiphy,
+			   "text mode should be 0 (false) or 1 (true): %d\n",
+			   text_mode);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	mwl_fwcmd_core_dump_diag_mode(priv->hw, 1);
+	priv->coredump_text = text_mode ? true : false;
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_mcast_cts_write(struct file *file,
+					   const char __user *ubuf,
+					   size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	int cts_enable = 0;
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (kstrtoint(buf, 0, &cts_enable)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	ret = mwl_hif_mcast_cts(priv->hw, cts_enable ? true : false);
+	if (ret)
+		goto err;
+
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+static ssize_t mwl_debugfs_wmmedcaap_write(struct file *file,
+					   const char __user *ubuf,
+					   size_t count, loff_t *ppos)
+{
+	struct mwl_priv *priv = (struct mwl_priv *)file->private_data;
+	unsigned long addr = get_zeroed_page(GFP_KERNEL);
+	char *buf = (char *)addr;
+	size_t buf_size = min_t(size_t, count, PAGE_SIZE - 1);
+	u32 index = 0, cw_min = 0, cw_max = 0, aifsn = 0, txop = 0;
+	ssize_t ret;
+
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, buf_size)) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	ret = sscanf(buf, "%u %x %x %u %x", &index, &cw_min,
+			&cw_max, &aifsn, &txop);
+	if (ret != 5) {
+		ret = -EINVAL;
+		goto err;
+	}
+	wiphy_info(priv->hw->wiphy, "set TCQ%d wmm edca with:\n", index);
+	wiphy_info(priv->hw->wiphy,
+		   "cw_min=0x%x, cw_max=0x%x, aifs_num=%d, txop=0x%x\n",
+		   cw_min, cw_max, aifsn, txop);
+
+	ret = mwl_fwcmd_set_edca_params(priv->hw, index,
+			cw_min, cw_max, aifsn, txop);
+	if (ret)
+		goto err;
+
+	ret = count;
+
+err:
+	free_page(addr);
+	return ret;
+}
+
+MWLWIFI_DEBUGFS_FILE_READ_OPS(info);
+MWLWIFI_DEBUGFS_FILE_READ_OPS(tx_status);
+MWLWIFI_DEBUGFS_FILE_READ_OPS(rx_status);
+MWLWIFI_DEBUGFS_FILE_READ_OPS(vif);
+MWLWIFI_DEBUGFS_FILE_READ_OPS(sta);
+MWLWIFI_DEBUGFS_FILE_READ_OPS(ampdu);
+MWLWIFI_DEBUGFS_FILE_READ_OPS(stnid);
+MWLWIFI_DEBUGFS_FILE_READ_OPS(device_pwrtbl);
+MWLWIFI_DEBUGFS_FILE_READ_OPS(txpwrlmt);
+MWLWIFI_DEBUGFS_FILE_OPS(tx_amsdu);
+MWLWIFI_DEBUGFS_FILE_OPS(dump_hostcmd);
+MWLWIFI_DEBUGFS_FILE_OPS(dump_probe);
+MWLWIFI_DEBUGFS_FILE_OPS(heartbeat);
+MWLWIFI_DEBUGFS_FILE_OPS(dfs_test);
+MWLWIFI_DEBUGFS_FILE_OPS(dfs_channel);
+MWLWIFI_DEBUGFS_FILE_OPS(dfs_radar);
+MWLWIFI_DEBUGFS_FILE_OPS(thermal);
+MWLWIFI_DEBUGFS_FILE_OPS(led_ctrl);
+MWLWIFI_DEBUGFS_FILE_OPS(regrdwr);
+MWLWIFI_DEBUGFS_FILE_OPS(ratetable);
+MWLWIFI_DEBUGFS_FILE_OPS(tx_hist);
+MWLWIFI_DEBUGFS_FILE_OPS(ba_hist);
+MWLWIFI_DEBUGFS_FILE_OPS(fixed_rate);
+MWLWIFI_DEBUGFS_FILE_OPS(core_dump);
+MWLWIFI_DEBUGFS_FILE_WRITE_OPS(mcast_cts);
+MWLWIFI_DEBUGFS_FILE_WRITE_OPS(wmmedcaap);
+
+void mwl_debugfs_init(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (!priv->debugfs_phy)
+		priv->debugfs_phy = debugfs_create_dir("mwlwifi",
+						       hw->wiphy->debugfsdir);
+
+	if (!priv->debugfs_phy)
+		return;
+
+	MWLWIFI_DEBUGFS_ADD_FILE(info);
+	MWLWIFI_DEBUGFS_ADD_FILE(tx_status);
+	MWLWIFI_DEBUGFS_ADD_FILE(rx_status);
+	MWLWIFI_DEBUGFS_ADD_FILE(vif);
+	MWLWIFI_DEBUGFS_ADD_FILE(sta);
+	MWLWIFI_DEBUGFS_ADD_FILE(ampdu);
+	MWLWIFI_DEBUGFS_ADD_FILE(stnid);
+	MWLWIFI_DEBUGFS_ADD_FILE(device_pwrtbl);
+	MWLWIFI_DEBUGFS_ADD_FILE(txpwrlmt);
+	MWLWIFI_DEBUGFS_ADD_FILE(tx_amsdu);
+	MWLWIFI_DEBUGFS_ADD_FILE(dump_hostcmd);
+	MWLWIFI_DEBUGFS_ADD_FILE(dump_probe);
+	MWLWIFI_DEBUGFS_ADD_FILE(heartbeat);
+	MWLWIFI_DEBUGFS_ADD_FILE(dfs_test);
+	MWLWIFI_DEBUGFS_ADD_FILE(dfs_channel);
+	MWLWIFI_DEBUGFS_ADD_FILE(dfs_radar);
+	MWLWIFI_DEBUGFS_ADD_FILE(thermal);
+	MWLWIFI_DEBUGFS_ADD_FILE(led_ctrl);
+	MWLWIFI_DEBUGFS_ADD_FILE(regrdwr);
+	MWLWIFI_DEBUGFS_ADD_FILE(ratetable);
+	MWLWIFI_DEBUGFS_ADD_FILE(tx_hist);
+	MWLWIFI_DEBUGFS_ADD_FILE(ba_hist);
+	MWLWIFI_DEBUGFS_ADD_FILE(fixed_rate);
+	MWLWIFI_DEBUGFS_ADD_FILE(core_dump);
+	MWLWIFI_DEBUGFS_ADD_FILE(mcast_cts);
+	MWLWIFI_DEBUGFS_ADD_FILE(wmmedcaap);
+}
+
+void mwl_debugfs_remove(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	debugfs_remove(priv->debugfs_phy);
+	priv->debugfs_phy = NULL;
+}
diff --git a/drivers/net/wireless/marvell/mwlwifi/debugfs.h b/drivers/net/wireless/marvell/mwlwifi/debugfs.h
new file mode 100644
index 000000000000..e7595f563348
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/debugfs.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines debug fs related functions. */
+
+#ifndef _MWL_DEBUGFS_H_
+#define _MWL_DEBUGFS_H_
+
+void mwl_debugfs_init(struct ieee80211_hw *hw);
+void mwl_debugfs_remove(struct ieee80211_hw *hw);
+
+#endif /* _MWL_DEBUGFS_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/fwcmd.c b/drivers/net/wireless/marvell/mwlwifi/hif/fwcmd.c
new file mode 100644
index 000000000000..ff943d6fe447
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/fwcmd.c
@@ -0,0 +1,3852 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements firmware host command related
+ * functions.
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/ctype.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "utils.h"
+#include "hif/fwcmd.h"
+#include "hif/hif-ops.h"
+
+#define MAX_WAIT_GET_HW_SPECS_ITERATONS         3
+
+struct cmd_header {
+	__le16 command;
+	__le16 len;
+} __packed;
+
+char *mwl_fwcmd_get_cmd_string(unsigned short cmd)
+{
+	int max_entries = 0;
+	int curr_cmd = 0;
+
+	static const struct {
+		u16 cmd;
+		char *cmd_string;
+	} cmds[] = {
+		{ HOSTCMD_CMD_GET_HW_SPEC, "GetHwSpecifications" },
+		{ HOSTCMD_CMD_SET_HW_SPEC, "SetHwSepcifications" },
+		{ HOSTCMD_CMD_802_11_GET_STAT, "80211GetStat" },
+		{ HOSTCMD_CMD_BBP_REG_ACCESS, "BBPRegAccess" },
+		{ HOSTCMD_CMD_RF_REG_ACCESS, "RFRegAccess" },
+		{ HOSTCMD_CMD_802_11_RADIO_CONTROL, "80211RadioControl" },
+		{ HOSTCMD_CMD_MEM_ADDR_ACCESS, "MEMAddrAccess" },
+		{ HOSTCMD_CMD_802_11_TX_POWER, "80211TxPower" },
+		{ HOSTCMD_CMD_802_11_RF_ANTENNA, "80211RfAntenna" },
+		{ HOSTCMD_CMD_BROADCAST_SSID_ENABLE, "BroadcastSsidEnable" },
+		{ HOSTCMD_CMD_SET_CFG, "SetCfg" },
+		{ HOSTCMD_CMD_SET_RF_CHANNEL, "SetRfChannel" },
+		{ HOSTCMD_CMD_SET_AID, "SetAid" },
+		{ HOSTCMD_CMD_SET_INFRA_MODE, "SetInfraMode" },
+		{ HOSTCMD_CMD_802_11_RTS_THSD, "80211RtsThreshold" },
+		{ HOSTCMD_CMD_SET_EDCA_PARAMS, "SetEDCAParams" },
+		{ HOSTCMD_CMD_802_11H_DETECT_RADAR, "80211hDetectRadar" },
+		{ HOSTCMD_CMD_SET_WMM_MODE, "SetWMMMode" },
+		{ HOSTCMD_CMD_HT_GUARD_INTERVAL, "HtGuardInterval" },
+		{ HOSTCMD_CMD_SET_FIXED_RATE, "SetFixedRate" },
+		{ HOSTCMD_CMD_SET_IES, "SetInformationElements" },
+		{ HOSTCMD_CMD_SET_LINKADAPT_CS_MODE, "LinkAdaptCsMode" },
+		{ HOSTCMD_CMD_DUMP_OTP_DATA, "DumpOtpData" },
+		{ HOSTCMD_CMD_SET_MAC_ADDR, "SetMacAddr" },
+		{ HOSTCMD_CMD_SET_RATE_ADAPT_MODE, "SetRateAdaptationMode" },
+		{ HOSTCMD_CMD_GET_WATCHDOG_BITMAP, "GetWatchdogBitMap" },
+		{ HOSTCMD_CMD_DEL_MAC_ADDR, "DelMacAddr" },
+		{ HOSTCMD_CMD_BSS_START, "BssStart" },
+		{ HOSTCMD_CMD_AP_BEACON, "SetApBeacon" },
+		{ HOSTCMD_CMD_SET_NEW_STN, "SetNewStation" },
+		{ HOSTCMD_CMD_SET_APMODE, "SetApMode" },
+		{ HOSTCMD_CMD_SET_SWITCH_CHANNEL, "SetSwitchChannel" },
+		{ HOSTCMD_CMD_UPDATE_ENCRYPTION, "UpdateEncryption" },
+		{ HOSTCMD_CMD_BASTREAM, "BAStream" },
+		{ HOSTCMD_CMD_SET_SPECTRUM_MGMT, "SetSpectrumMgmt" },
+		{ HOSTCMD_CMD_SET_POWER_CONSTRAINT, "SetPowerConstraint" },
+		{ HOSTCMD_CMD_SET_COUNTRY_CODE, "SetCountryCode" },
+		{ HOSTCMD_CMD_SET_OPTIMIZATION_LEVEL, "SetOptimizationLevel" },
+		{ HOSTCMD_CMD_SET_WSC_IE, "SetWscIE" },
+		{ HOSTCMD_CMD_GET_RATETABLE, "GetRateTable" },
+		{ HOSTCMD_CMD_GET_SEQNO, "GetSeqno" },
+		{ HOSTCMD_CMD_DWDS_ENABLE, "DwdsEnable" },
+		{ HOSTCMD_CMD_FW_FLUSH_TIMER, "FwFlushTimer" },
+		{ HOSTCMD_CMD_SET_CDD, "SetCDD" },
+		{ HOSTCMD_CMD_SET_BFTYPE, "SetBFType" },
+		{ HOSTCMD_CMD_CAU_REG_ACCESS, "CAURegAccess" },
+		{ HOSTCMD_CMD_GET_TEMP, "GetTemp" },
+		{ HOSTCMD_CMD_LED_CTRL, "LedCtrl" },
+		{ HOSTCMD_CMD_GET_FW_REGION_CODE, "GetFwRegionCode" },
+		{ HOSTCMD_CMD_GET_DEVICE_PWR_TBL, "GetDevicePwrTbl" },
+		{ HOSTCMD_CMD_SET_RATE_DROP, "SetRateDrop" },
+		{ HOSTCMD_CMD_NEWDP_DMATHREAD_START, "NewdpDMAThreadStart" },
+		{ HOSTCMD_CMD_GET_FW_REGION_CODE_SC4, "GetFwRegionCodeSC4" },
+		{ HOSTCMD_CMD_GET_DEVICE_PWR_TBL_SC4, "GetDevicePwrTblSC4" },
+		{ HOSTCMD_CMD_QUIET_MODE, "QuietMode" },
+		{ HOSTCMD_CMD_CORE_DUMP_DIAG_MODE, "CoreDumpDiagMode" },
+		{ HOSTCMD_CMD_802_11_SLOT_TIME, "80211SlotTime" },
+		{ HOSTCMD_CMD_GET_FW_CORE_DUMP, "GetFwCoreDump" },
+		{ HOSTCMD_CMD_EDMAC_CTRL, "EDMACCtrl" },
+		{ HOSTCMD_CMD_TXPWRLMT_CFG, "TxpwrlmtCfg" },
+		{ HOSTCMD_CMD_MCAST_CTS, "McastCts" },
+	};
+
+	max_entries = ARRAY_SIZE(cmds);
+
+	for (curr_cmd = 0; curr_cmd < max_entries; curr_cmd++)
+		if ((cmd & 0x7fff) == cmds[curr_cmd].cmd)
+			return cmds[curr_cmd].cmd_string;
+
+	return "unknown";
+}
+
+static int mwl_fwcmd_802_11_radio_control(struct mwl_priv *priv,
+					  bool enable, bool force)
+{
+	struct hostcmd_cmd_802_11_radio_control *pcmd;
+
+	if (enable == priv->radio_on && !force)
+		return 0;
+
+	pcmd = (struct hostcmd_cmd_802_11_radio_control *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_802_11_RADIO_CONTROL);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action = cpu_to_le16(WL_SET);
+	pcmd->control = cpu_to_le16(priv->radio_short_preamble ?
+		WL_AUTO_PREAMBLE : WL_LONG_PREAMBLE);
+	pcmd->radio_on = cpu_to_le16(enable ? WL_ENABLE : WL_DISABLE);
+
+	if (mwl_hif_exec_cmd(priv->hw, HOSTCMD_CMD_802_11_RADIO_CONTROL)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	priv->radio_on = enable;
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+static int mwl_fwcmd_get_tx_powers(struct mwl_priv *priv, u16 *powlist,
+				   u8 action, u16 ch, u16 band,
+				   u16 width, u16 sub_ch)
+{
+	struct hostcmd_cmd_802_11_tx_power *pcmd;
+	int i;
+
+	pcmd = (struct hostcmd_cmd_802_11_tx_power *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	if (priv->chip_type == MWL8997) {
+		memset(pcmd, 0x00,
+		       sizeof(struct hostcmd_cmd_802_11_tx_power_kf2));
+		pcmd->cmd_hdr.len = cpu_to_le16(
+			sizeof(struct hostcmd_cmd_802_11_tx_power_kf2));
+	} else {
+		memset(pcmd, 0x00, sizeof(*pcmd));
+		pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	}
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_802_11_TX_POWER);
+	pcmd->action = cpu_to_le16(action);
+	pcmd->ch = cpu_to_le16(ch);
+	pcmd->bw = cpu_to_le16(width);
+	pcmd->band = cpu_to_le16(band);
+	pcmd->sub_ch = cpu_to_le16(sub_ch);
+
+	if (mwl_hif_exec_cmd(priv->hw, HOSTCMD_CMD_802_11_TX_POWER)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	for (i = 0; i < priv->pwr_level; i++)
+		powlist[i] = le16_to_cpu(pcmd->power_level_list[i]);
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+static int mwl_fwcmd_set_tx_powers(struct mwl_priv *priv, u16 txpow[],
+				   u8 action, u16 ch, u16 band,
+				   u16 width, u16 sub_ch)
+{
+	struct hostcmd_cmd_802_11_tx_power *pcmd;
+	int i;
+
+	pcmd = (struct hostcmd_cmd_802_11_tx_power *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	if (priv->chip_type == MWL8997) {
+		memset(pcmd, 0x00,
+		       sizeof(struct hostcmd_cmd_802_11_tx_power_kf2));
+		pcmd->cmd_hdr.len = cpu_to_le16(
+			sizeof(struct hostcmd_cmd_802_11_tx_power_kf2));
+	} else {
+		memset(pcmd, 0x00, sizeof(*pcmd));
+		pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	}
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_802_11_TX_POWER);
+	pcmd->action = cpu_to_le16(action);
+	pcmd->ch = cpu_to_le16(ch);
+	pcmd->bw = cpu_to_le16(width);
+	pcmd->band = cpu_to_le16(band);
+	pcmd->sub_ch = cpu_to_le16(sub_ch);
+
+	for (i = 0; i < priv->pwr_level; i++)
+		pcmd->power_level_list[i] = cpu_to_le16(txpow[i]);
+
+	if (mwl_hif_exec_cmd(priv->hw, HOSTCMD_CMD_802_11_TX_POWER)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+static u8 mwl_fwcmd_get_80m_pri_chnl(u8 channel)
+{
+	u8 act_primary = ACT_PRIMARY_CHAN_0;
+
+	switch (channel) {
+	case 36:
+		act_primary = ACT_PRIMARY_CHAN_0;
+		break;
+	case 40:
+		act_primary = ACT_PRIMARY_CHAN_1;
+		break;
+	case 44:
+		act_primary = ACT_PRIMARY_CHAN_2;
+		break;
+	case 48:
+		act_primary = ACT_PRIMARY_CHAN_3;
+		break;
+	case 52:
+		act_primary = ACT_PRIMARY_CHAN_0;
+		break;
+	case 56:
+		act_primary = ACT_PRIMARY_CHAN_1;
+		break;
+	case 60:
+		act_primary = ACT_PRIMARY_CHAN_2;
+		break;
+	case 64:
+		act_primary = ACT_PRIMARY_CHAN_3;
+		break;
+	case 100:
+		act_primary = ACT_PRIMARY_CHAN_0;
+		break;
+	case 104:
+		act_primary = ACT_PRIMARY_CHAN_1;
+		break;
+	case 108:
+		act_primary = ACT_PRIMARY_CHAN_2;
+		break;
+	case 112:
+		act_primary = ACT_PRIMARY_CHAN_3;
+		break;
+	case 116:
+		act_primary = ACT_PRIMARY_CHAN_0;
+		break;
+	case 120:
+		act_primary = ACT_PRIMARY_CHAN_1;
+		break;
+	case 124:
+		act_primary = ACT_PRIMARY_CHAN_2;
+		break;
+	case 128:
+		act_primary = ACT_PRIMARY_CHAN_3;
+		break;
+	case 132:
+		act_primary = ACT_PRIMARY_CHAN_0;
+		break;
+	case 136:
+		act_primary = ACT_PRIMARY_CHAN_1;
+		break;
+	case 140:
+		act_primary = ACT_PRIMARY_CHAN_2;
+		break;
+	case 144:
+		act_primary = ACT_PRIMARY_CHAN_3;
+		break;
+	case 149:
+		act_primary = ACT_PRIMARY_CHAN_0;
+		break;
+	case 153:
+		act_primary = ACT_PRIMARY_CHAN_1;
+		break;
+	case 157:
+		act_primary = ACT_PRIMARY_CHAN_2;
+		break;
+	case 161:
+		act_primary = ACT_PRIMARY_CHAN_3;
+		break;
+	}
+
+	return act_primary;
+}
+
+static u8 mwl_fwcmd_get_160m_pri_chnl(u8 channel)
+{
+	u8 act_primary = ACT_PRIMARY_CHAN_0;
+
+	switch (channel) {
+	case 36:
+		act_primary = ACT_PRIMARY_CHAN_0;
+		break;
+	case 40:
+		act_primary = ACT_PRIMARY_CHAN_1;
+		break;
+	case 44:
+		act_primary = ACT_PRIMARY_CHAN_2;
+		break;
+	case 48:
+		act_primary = ACT_PRIMARY_CHAN_3;
+		break;
+	case 52:
+		act_primary = ACT_PRIMARY_CHAN_4;
+		break;
+	case 56:
+		act_primary = ACT_PRIMARY_CHAN_5;
+		break;
+	case 60:
+		act_primary = ACT_PRIMARY_CHAN_6;
+		break;
+	case 64:
+		act_primary = ACT_PRIMARY_CHAN_7;
+		break;
+	case 100:
+		act_primary = ACT_PRIMARY_CHAN_0;
+		break;
+	case 104:
+		act_primary = ACT_PRIMARY_CHAN_1;
+		break;
+	case 108:
+		act_primary = ACT_PRIMARY_CHAN_2;
+		break;
+	case 112:
+		act_primary = ACT_PRIMARY_CHAN_3;
+		break;
+	case 116:
+		act_primary = ACT_PRIMARY_CHAN_4;
+		break;
+	case 120:
+		act_primary = ACT_PRIMARY_CHAN_5;
+		break;
+	case 124:
+		act_primary = ACT_PRIMARY_CHAN_6;
+		break;
+	case 128:
+		act_primary = ACT_PRIMARY_CHAN_7;
+		break;
+	case 149:
+		act_primary = ACT_PRIMARY_CHAN_0;
+		break;
+	case 153:
+		act_primary = ACT_PRIMARY_CHAN_1;
+		break;
+	case 157:
+		act_primary = ACT_PRIMARY_CHAN_2;
+		break;
+	case 161:
+		act_primary = ACT_PRIMARY_CHAN_3;
+		break;
+	case 165:
+		act_primary = ACT_PRIMARY_CHAN_4;
+		break;
+	case 169:
+		act_primary = ACT_PRIMARY_CHAN_5;
+		break;
+	case 173:
+		act_primary = ACT_PRIMARY_CHAN_6;
+		break;
+	case 177:
+		act_primary = ACT_PRIMARY_CHAN_7;
+		break;
+	}
+
+	return act_primary;
+}
+
+static void mwl_fwcmd_parse_beacon(struct mwl_priv *priv,
+				   struct mwl_vif *vif, u8 *beacon, int len)
+{
+	struct ieee80211_mgmt *mgmt;
+	struct beacon_info *beacon_info;
+	int baselen;
+	u8 *pos;
+	size_t left;
+	bool elem_parse_failed;
+
+	mgmt = (struct ieee80211_mgmt *)beacon;
+
+	baselen = (u8 *)mgmt->u.beacon.variable - (u8 *)mgmt;
+	if (baselen > len)
+		return;
+
+	beacon_info = &vif->beacon_info;
+	memset(beacon_info, 0, sizeof(struct beacon_info));
+	beacon_info->valid = false;
+	beacon_info->ie_ht_ptr = &beacon_info->ie_list_ht[0];
+	beacon_info->ie_vht_ptr = &beacon_info->ie_list_vht[0];
+
+	beacon_info->cap_info = le16_to_cpu(mgmt->u.beacon.capab_info);
+	beacon_info->power_constraint = 0;
+
+	pos = (u8 *)mgmt->u.beacon.variable;
+	left = len - baselen;
+
+	elem_parse_failed = false;
+
+	while (left >= 2) {
+		u8 id, elen;
+
+		id = *pos++;
+		elen = *pos++;
+		left -= 2;
+
+		if (elen > left) {
+			elem_parse_failed = true;
+			break;
+		}
+
+		switch (id) {
+		case WLAN_EID_COUNTRY:
+			beacon_info->ie_country_len = (elen + 2);
+			beacon_info->ie_country_ptr = (pos - 2);
+			break;
+		case WLAN_EID_SUPP_RATES:
+		case WLAN_EID_EXT_SUPP_RATES:
+			{
+			int idx, bi, oi;
+			u8 rate;
+
+			for (bi = 0; bi < SYSADPT_MAX_DATA_RATES_G;
+			     bi++) {
+				if (beacon_info->b_rate_set[bi] == 0)
+					break;
+			}
+
+			for (oi = 0; oi < SYSADPT_MAX_DATA_RATES_G;
+			     oi++) {
+				if (beacon_info->op_rate_set[oi] == 0)
+					break;
+			}
+
+			for (idx = 0; idx < elen; idx++) {
+				rate = pos[idx];
+				if ((rate & 0x80) != 0) {
+					if (bi < SYSADPT_MAX_DATA_RATES_G)
+						beacon_info->b_rate_set[bi++]
+							= rate & 0x7f;
+					else {
+						elem_parse_failed = true;
+						break;
+					}
+				}
+				if (oi < SYSADPT_MAX_DATA_RATES_G)
+					beacon_info->op_rate_set[oi++] =
+						rate & 0x7f;
+				else {
+					elem_parse_failed = true;
+					break;
+				}
+			}
+			}
+			break;
+		case WLAN_EID_PWR_CONSTRAINT:
+			if (elen == 1)
+				beacon_info->power_constraint = *pos;
+			break;
+		case WLAN_EID_RSN:
+			beacon_info->ie_rsn48_len = (elen + 2);
+			beacon_info->ie_rsn48_ptr = (pos - 2);
+			break;
+		case WLAN_EID_MOBILITY_DOMAIN:
+			beacon_info->ie_mde_len = (elen + 2);
+			beacon_info->ie_mde_ptr = (pos - 2);
+			break;
+		case WLAN_EID_HT_CAPABILITY:
+		case WLAN_EID_HT_OPERATION:
+		case WLAN_EID_OVERLAP_BSS_SCAN_PARAM:
+		case WLAN_EID_EXT_CAPABILITY:
+			beacon_info->ie_ht_len += (elen + 2);
+			if (beacon_info->ie_ht_len >
+			    sizeof(beacon_info->ie_list_ht)) {
+				elem_parse_failed = true;
+			} else {
+				*beacon_info->ie_ht_ptr++ = id;
+				*beacon_info->ie_ht_ptr++ = elen;
+				memcpy(beacon_info->ie_ht_ptr, pos, elen);
+				beacon_info->ie_ht_ptr += elen;
+			}
+			break;
+		case WLAN_EID_MESH_CONFIG:
+			beacon_info->ie_meshcfg_len = (elen + 2);
+			beacon_info->ie_meshcfg_ptr = (pos - 2);
+			break;
+		case WLAN_EID_MESH_ID:
+			beacon_info->ie_meshid_len = (elen + 2);
+			beacon_info->ie_meshid_ptr = (pos - 2);
+			break;
+		case WLAN_EID_CHAN_SWITCH_PARAM:
+			beacon_info->ie_meshchsw_len = (elen + 2);
+			beacon_info->ie_meshchsw_ptr = (pos - 2);
+			break;
+		case WLAN_EID_VHT_CAPABILITY:
+		case WLAN_EID_VHT_OPERATION:
+		case WLAN_EID_OPMODE_NOTIF:
+			beacon_info->ie_vht_len += (elen + 2);
+			if (beacon_info->ie_vht_len >
+			    sizeof(beacon_info->ie_list_vht)) {
+				elem_parse_failed = true;
+			} else {
+				*beacon_info->ie_vht_ptr++ = id;
+				*beacon_info->ie_vht_ptr++ = elen;
+				memcpy(beacon_info->ie_vht_ptr, pos, elen);
+				beacon_info->ie_vht_ptr += elen;
+			}
+			break;
+		case WLAN_EID_VENDOR_SPECIFIC:
+			if ((pos[0] == 0x00) && (pos[1] == 0x50) &&
+			    (pos[2] == 0xf2)) {
+				if (pos[3] == 0x01) {
+					beacon_info->ie_rsn_len = (elen + 2);
+					beacon_info->ie_rsn_ptr = (pos - 2);
+				}
+
+				if (pos[3] == 0x02) {
+					beacon_info->ie_wmm_len = (elen + 2);
+					beacon_info->ie_wmm_ptr = (pos - 2);
+				}
+
+				if (pos[3] == 0x04) {
+					beacon_info->ie_wsc_len = (elen + 2);
+					beacon_info->ie_wsc_ptr = (pos - 2);
+				}
+			}
+			break;
+		default:
+			break;
+		}
+
+		left -= elen;
+		pos += elen;
+	}
+
+	if (!elem_parse_failed) {
+		beacon_info->ie_ht_ptr = &beacon_info->ie_list_ht[0];
+		beacon_info->ie_vht_ptr = &beacon_info->ie_list_vht[0];
+		beacon_info->valid = true;
+	}
+}
+
+static int mwl_fwcmd_set_ies(struct mwl_priv *priv, struct mwl_vif *mwl_vif)
+{
+	struct hostcmd_cmd_set_ies *pcmd;
+	struct beacon_info *beacon = &mwl_vif->beacon_info;
+	u16 ie_list_len_proprietary = 0;
+
+	if (beacon->ie_ht_len > sizeof(pcmd->ie_list_ht))
+		goto einval;
+
+	if (beacon->ie_vht_len > sizeof(pcmd->ie_list_vht))
+		goto einval;
+
+	pcmd = (struct hostcmd_cmd_set_ies *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_IES);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+
+	pcmd->action = cpu_to_le16(HOSTCMD_ACT_GEN_SET);
+
+	memcpy(pcmd->ie_list_ht, beacon->ie_ht_ptr, beacon->ie_ht_len);
+	pcmd->ie_list_len_ht = cpu_to_le16(beacon->ie_ht_len);
+
+	memcpy(pcmd->ie_list_vht, beacon->ie_vht_ptr, beacon->ie_vht_len);
+	pcmd->ie_list_len_vht = cpu_to_le16(beacon->ie_vht_len);
+
+	memcpy(pcmd->ie_list_proprietary, beacon->ie_meshid_ptr,
+	       beacon->ie_meshid_len);
+	ie_list_len_proprietary = beacon->ie_meshid_len;
+
+	memcpy(pcmd->ie_list_proprietary + ie_list_len_proprietary,
+	       beacon->ie_meshcfg_ptr, beacon->ie_meshcfg_len);
+	ie_list_len_proprietary += beacon->ie_meshcfg_len;
+
+	memcpy(pcmd->ie_list_proprietary + ie_list_len_proprietary,
+	       beacon->ie_meshchsw_ptr, beacon->ie_meshchsw_len);
+	ie_list_len_proprietary += beacon->ie_meshchsw_len;
+
+	if (priv->chip_type == MWL8897) {
+		memcpy(pcmd->ie_list_proprietary + ie_list_len_proprietary,
+		       beacon->ie_wmm_ptr, beacon->ie_wmm_len);
+		ie_list_len_proprietary += mwl_vif->beacon_info.ie_wmm_len;
+	}
+
+	memcpy(pcmd->ie_list_proprietary + ie_list_len_proprietary,
+	       beacon->ie_mde_ptr, beacon->ie_mde_len);
+	ie_list_len_proprietary += mwl_vif->beacon_info.ie_mde_len;
+
+	pcmd->ie_list_len_proprietary = cpu_to_le16(ie_list_len_proprietary);
+
+	if (mwl_hif_exec_cmd(priv->hw, HOSTCMD_CMD_SET_IES)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+
+einval:
+
+	wiphy_err(priv->hw->wiphy, "length of IE is too long\n");
+
+	return -EINVAL;
+}
+
+static int mwl_fwcmd_set_ap_beacon(struct mwl_priv *priv,
+				   struct mwl_vif *mwl_vif,
+				   struct ieee80211_bss_conf *bss_conf)
+{
+	struct hostcmd_cmd_ap_beacon *pcmd;
+	struct ds_params *phy_ds_param_set;
+
+	/* wmm structure of start command is defined less one byte,
+	 * due to following field country is not used, add byte one
+	 * to bypass the check.
+	 */
+	if (mwl_vif->beacon_info.ie_wmm_len >
+	    (sizeof(pcmd->start_cmd.wmm_param) + 1))
+		goto ielenerr;
+
+	if (mwl_vif->beacon_info.ie_rsn_len > sizeof(pcmd->start_cmd.rsn_ie))
+		goto ielenerr;
+
+	if (mwl_vif->beacon_info.ie_rsn48_len >
+	    sizeof(pcmd->start_cmd.rsn48_ie))
+		goto ielenerr;
+
+	pcmd = (struct hostcmd_cmd_ap_beacon *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_AP_BEACON);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+
+	ether_addr_copy(pcmd->start_cmd.sta_mac_addr, mwl_vif->bssid);
+	memcpy(pcmd->start_cmd.ssid, bss_conf->ssid, bss_conf->ssid_len);
+	if (priv->chip_type == MWL8997)
+		ether_addr_copy(pcmd->start_cmd.bssid, mwl_vif->bssid);
+	pcmd->start_cmd.bss_type = 1;
+	pcmd->start_cmd.bcn_period  = cpu_to_le16(bss_conf->beacon_int);
+	pcmd->start_cmd.dtim_period = bss_conf->dtim_period; /* 8bit */
+
+	phy_ds_param_set = &pcmd->start_cmd.phy_param_set.ds_param_set;
+	phy_ds_param_set->elem_id = WLAN_EID_DS_PARAMS;
+	phy_ds_param_set->len = sizeof(phy_ds_param_set->current_chnl);
+	phy_ds_param_set->current_chnl = bss_conf->chandef.chan->hw_value;
+
+	pcmd->start_cmd.probe_delay = cpu_to_le16(10);
+	pcmd->start_cmd.cap_info = cpu_to_le16(mwl_vif->beacon_info.cap_info);
+
+	memcpy(&pcmd->start_cmd.wmm_param, mwl_vif->beacon_info.ie_wmm_ptr,
+	       mwl_vif->beacon_info.ie_wmm_len);
+
+	memcpy(&pcmd->start_cmd.rsn_ie, mwl_vif->beacon_info.ie_rsn_ptr,
+	       mwl_vif->beacon_info.ie_rsn_len);
+
+	memcpy(&pcmd->start_cmd.rsn48_ie, mwl_vif->beacon_info.ie_rsn48_ptr,
+	       mwl_vif->beacon_info.ie_rsn48_len);
+
+	memcpy(pcmd->start_cmd.b_rate_set, mwl_vif->beacon_info.b_rate_set,
+	       SYSADPT_MAX_DATA_RATES_G);
+
+	memcpy(pcmd->start_cmd.op_rate_set, mwl_vif->beacon_info.op_rate_set,
+	       SYSADPT_MAX_DATA_RATES_G);
+
+	if (mwl_hif_exec_cmd(priv->hw, HOSTCMD_CMD_AP_BEACON)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+
+ielenerr:
+
+	wiphy_err(priv->hw->wiphy, "length of IE is too long\n");
+
+	return -EINVAL;
+}
+
+static int mwl_fwcmd_set_spectrum_mgmt(struct mwl_priv *priv, bool enable)
+{
+	struct hostcmd_cmd_set_spectrum_mgmt *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_spectrum_mgmt *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_SPECTRUM_MGMT);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->spectrum_mgmt = cpu_to_le32(enable);
+
+	if (mwl_hif_exec_cmd(priv->hw, HOSTCMD_CMD_SET_SPECTRUM_MGMT)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+static int mwl_fwcmd_set_power_constraint(struct mwl_priv *priv,
+					  u32 power_constraint)
+{
+	struct hostcmd_cmd_set_power_constraint *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_power_constraint *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_POWER_CONSTRAINT);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->power_constraint = cpu_to_le32(power_constraint);
+
+	if (mwl_hif_exec_cmd(priv->hw, HOSTCMD_CMD_SET_POWER_CONSTRAINT)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+static int mwl_fwcmd_set_country_code(struct mwl_priv *priv,
+				      struct mwl_vif *mwl_vif,
+				      struct ieee80211_bss_conf *bss_conf)
+{
+	struct hostcmd_cmd_set_country_code *pcmd;
+	struct beacon_info *b_inf = &mwl_vif->beacon_info;
+	u8 chnl_len;
+	bool a_band;
+	bool enable = false;
+
+	if (b_inf->ie_country_ptr) {
+		if (bss_conf->chandef.chan->band == NL80211_BAND_2GHZ)
+			a_band = false;
+		else if (bss_conf->chandef.chan->band == NL80211_BAND_5GHZ)
+			a_band = true;
+		else
+			return -EINVAL;
+
+		chnl_len = b_inf->ie_country_len - 5;
+		if (a_band) {
+			if (chnl_len > sizeof(pcmd->domain_info.domain_entry_a))
+				return -EINVAL;
+		} else {
+			if (chnl_len > sizeof(pcmd->domain_info.domain_entry_g))
+				return -EINVAL;
+		}
+
+		enable = true;
+	}
+
+	pcmd = (struct hostcmd_cmd_set_country_code *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_COUNTRY_CODE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action = cpu_to_le32(enable);
+	if (enable) {
+		memcpy(pcmd->domain_info.country_string,
+		       b_inf->ie_country_ptr + 2, 3);
+		if (a_band) {
+			pcmd->domain_info.g_chnl_len = 0;
+			pcmd->domain_info.a_chnl_len = chnl_len;
+			memcpy(pcmd->domain_info.domain_entry_a,
+			       b_inf->ie_country_ptr + 5, chnl_len);
+		} else {
+			pcmd->domain_info.a_chnl_len = 0;
+			pcmd->domain_info.g_chnl_len = chnl_len;
+			memcpy(pcmd->domain_info.domain_entry_g,
+			       b_inf->ie_country_ptr + 5, chnl_len);
+		}
+	}
+
+	if (mwl_hif_exec_cmd(priv->hw, HOSTCMD_CMD_SET_COUNTRY_CODE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+static int mwl_fwcmd_encryption_set_cmd_info(struct hostcmd_cmd_set_key *cmd,
+					     u8 *addr,
+					     struct ieee80211_key_conf *key)
+{
+	cmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_UPDATE_ENCRYPTION);
+	cmd->cmd_hdr.len = cpu_to_le16(sizeof(*cmd));
+	cmd->key_param.length = cpu_to_le16(sizeof(*cmd) -
+		offsetof(struct hostcmd_cmd_set_key, key_param));
+	cmd->key_param.key_index = cpu_to_le32(key->keyidx);
+	cmd->key_param.key_len = cpu_to_le16(key->keylen);
+	ether_addr_copy(cmd->key_param.mac_addr, addr);
+
+	switch (key->cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		cmd->key_param.key_type_id = cpu_to_le16(KEY_TYPE_ID_WEP);
+		if (key->keyidx == 0)
+			cmd->key_param.key_info =
+				cpu_to_le32(ENCR_KEY_FLAG_WEP_TXKEY);
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		cmd->key_param.key_type_id = cpu_to_le16(KEY_TYPE_ID_TKIP);
+		cmd->key_param.key_info =
+			(key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ?
+			cpu_to_le32(ENCR_KEY_FLAG_PAIRWISE) :
+			cpu_to_le32(ENCR_KEY_FLAG_TXGROUPKEY);
+		cmd->key_param.key_info |=
+			cpu_to_le32(ENCR_KEY_FLAG_MICKEY_VALID |
+				      ENCR_KEY_FLAG_TSC_VALID);
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		cmd->key_param.key_type_id = cpu_to_le16(KEY_TYPE_ID_AES);
+		cmd->key_param.key_info =
+			(key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ?
+			cpu_to_le32(ENCR_KEY_FLAG_PAIRWISE) :
+			cpu_to_le32(ENCR_KEY_FLAG_TXGROUPKEY);
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		return 1;
+	default:
+		return -ENOTSUPP;
+	}
+
+	return 0;
+}
+
+static __le16 mwl_fwcmd_parse_cal_cfg(const u8 *src, size_t len, u8 *dst)
+{
+	const u8 *ptr;
+	u8 *dptr;
+	char byte_str[3];
+	long res;
+
+	ptr = src;
+	dptr = dst;
+	byte_str[2] = '\0';
+
+	while (ptr - src < len) {
+		if (*ptr && (isspace(*ptr) || iscntrl(*ptr))) {
+			ptr++;
+			continue;
+		}
+
+		if (isxdigit(*ptr)) {
+			byte_str[0] = *ptr++;
+			byte_str[1] = *ptr++;
+			kstrtol(byte_str, 16, &res);
+			*dptr++ = res;
+		} else {
+			ptr++;
+		}
+	}
+
+	return cpu_to_le16(dptr - dst);
+}
+
+static u16 mwl_fwcmd_parse_txpwrlmt_cfg(const u8 *src, size_t len,
+					u16 parse_len, u8 *dst)
+{
+	const u8 *ptr;
+	u8 *dptr;
+	char byte_str[3];
+	long res;
+
+	ptr = src;
+	dptr = dst;
+	byte_str[2] = '\0';
+
+	while ((ptr - src < len) && (dptr - dst < parse_len)) {
+		if (*ptr && (isspace(*ptr) || iscntrl(*ptr))) {
+			ptr++;
+			continue;
+		}
+
+		if (isxdigit(*ptr)) {
+			byte_str[0] = *ptr++;
+			byte_str[1] = *ptr++;
+			kstrtol(byte_str, 16, &res);
+			*dptr++ = res;
+		} else {
+			ptr++;
+		}
+	}
+
+	return (ptr - src);
+}
+
+const struct hostcmd_get_hw_spec
+*mwl_fwcmd_get_hw_specs(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_get_hw_spec *pcmd;
+	int retry;
+
+	pcmd = (struct hostcmd_cmd_get_hw_spec *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	wiphy_debug(hw->wiphy, "pcmd = %p\n", pcmd);
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	eth_broadcast_addr(pcmd->hw_spec.permanent_addr);
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_GET_HW_SPEC);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->hw_spec.fw_awake_cookie = cpu_to_le32(priv->pphys_cmd_buf + 2048);
+
+	retry = 0;
+	while (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_GET_HW_SPEC)) {
+		if (retry++ > MAX_WAIT_GET_HW_SPECS_ITERATONS) {
+			wiphy_err(hw->wiphy, "can't get hw specs\n");
+			mutex_unlock(&priv->fwcmd_mutex);
+			return NULL;
+		}
+
+		msleep(1000);
+		wiphy_debug(hw->wiphy,
+			    "repeat command = %p\n", pcmd);
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return &pcmd->hw_spec;
+}
+
+int mwl_fwcmd_set_hw_specs(struct ieee80211_hw *hw,
+			   struct hostcmd_set_hw_spec *spec)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_hw_spec *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_hw_spec *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_HW_SPEC);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	memcpy(&pcmd->hw_spec, spec, sizeof(*spec));
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_HW_SPEC)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_get_stat(struct ieee80211_hw *hw,
+		       struct ieee80211_low_level_stats *stats)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_802_11_get_stat *pcmd;
+
+	pcmd = (struct hostcmd_cmd_802_11_get_stat *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_802_11_GET_STAT);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_802_11_GET_STAT)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	stats->dot11ACKFailureCount =
+		le32_to_cpu(pcmd->ack_failures);
+	stats->dot11RTSFailureCount =
+		le32_to_cpu(pcmd->rts_failures);
+	stats->dot11FCSErrorCount =
+		le32_to_cpu(pcmd->rx_fcs_errors);
+	stats->dot11RTSSuccessCount =
+		le32_to_cpu(pcmd->rts_successes);
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_reg_bb(struct ieee80211_hw *hw, u8 flag, u32 reg, u32 *val)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_bbp_reg_access *pcmd;
+
+	pcmd = (struct hostcmd_cmd_bbp_reg_access *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_BBP_REG_ACCESS);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->offset = cpu_to_le16(reg);
+	pcmd->action = cpu_to_le16(flag);
+	pcmd->value = *val;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_BBP_REG_ACCESS)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	*val = pcmd->value;
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_reg_rf(struct ieee80211_hw *hw, u8 flag, u32 reg, u32 *val)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_rf_reg_access *pcmd;
+
+	pcmd = (struct hostcmd_cmd_rf_reg_access *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_RF_REG_ACCESS);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->offset = cpu_to_le16(reg);
+	pcmd->action = cpu_to_le16(flag);
+	pcmd->value = *val;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_RF_REG_ACCESS)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	*val = pcmd->value;
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_radio_enable(struct ieee80211_hw *hw)
+{
+	return mwl_fwcmd_802_11_radio_control(hw->priv, true, false);
+}
+
+int mwl_fwcmd_radio_disable(struct ieee80211_hw *hw)
+{
+	return mwl_fwcmd_802_11_radio_control(hw->priv, false, false);
+}
+
+int mwl_fwcmd_set_radio_preamble(struct ieee80211_hw *hw, bool short_preamble)
+{
+	struct mwl_priv *priv = hw->priv;
+	int rc;
+
+	priv->radio_short_preamble = short_preamble;
+	rc = mwl_fwcmd_802_11_radio_control(priv, true, true);
+
+	return rc;
+}
+
+int mwl_fwcmd_get_addr_value(struct ieee80211_hw *hw, u32 addr, u32 len,
+			     u32 *val, u16 set)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_mem_addr_access *pcmd;
+	int i;
+
+	pcmd = (struct hostcmd_cmd_mem_addr_access *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_MEM_ADDR_ACCESS);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->address = cpu_to_le32(addr);
+	pcmd->length = cpu_to_le16(len);
+	pcmd->value[0] = cpu_to_le32(*val);
+	pcmd->reserved = cpu_to_le16(set);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_MEM_ADDR_ACCESS)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	for (i = 0; i < len; i++)
+		val[i] = le32_to_cpu(pcmd->value[i]);
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_max_tx_power(struct ieee80211_hw *hw,
+			   struct ieee80211_conf *conf, u8 fraction)
+{
+	struct ieee80211_channel *channel = conf->chandef.chan;
+	struct mwl_priv *priv = hw->priv;
+	int reduce_val = 0;
+	u16 band = 0, width = 0, sub_ch = 0;
+	u16 maxtxpow[SYSADPT_TX_GRP_PWR_LEVEL_TOTAL];
+	int i, tmp;
+	int rc = 0;
+
+	if ((priv->chip_type != MWL8997) && (priv->forbidden_setting))
+		return rc;
+
+	switch (fraction) {
+	case 0:
+		reduce_val = 0;    /* Max */
+		break;
+	case 1:
+		reduce_val = 2;    /* 75% -1.25db */
+		break;
+	case 2:
+		reduce_val = 3;    /* 50% -3db */
+		break;
+	case 3:
+		reduce_val = 6;    /* 25% -6db */
+		break;
+	default:
+		/* larger than case 3,  pCmd->MaxPowerLevel is min */
+		reduce_val = 0xff;
+		break;
+	}
+
+	if (channel->band == NL80211_BAND_2GHZ)
+		band = FREQ_BAND_2DOT4GHZ;
+	else if (channel->band == NL80211_BAND_5GHZ)
+		band = FREQ_BAND_5GHZ;
+
+	switch (conf->chandef.width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+	case NL80211_CHAN_WIDTH_20:
+		width = CH_20_MHZ_WIDTH;
+		sub_ch = NO_EXT_CHANNEL;
+		break;
+	case NL80211_CHAN_WIDTH_40:
+		width = CH_40_MHZ_WIDTH;
+		if (conf->chandef.center_freq1 > channel->center_freq)
+			sub_ch = EXT_CH_ABOVE_CTRL_CH;
+		else
+			sub_ch = EXT_CH_BELOW_CTRL_CH;
+		break;
+	case NL80211_CHAN_WIDTH_80:
+		width = CH_80_MHZ_WIDTH;
+		if (conf->chandef.center_freq1 > channel->center_freq)
+			sub_ch = EXT_CH_ABOVE_CTRL_CH;
+		else
+			sub_ch = EXT_CH_BELOW_CTRL_CH;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (priv->chip_type == MWL8997) {
+		mwl_fwcmd_get_tx_powers(priv, priv->max_tx_pow,
+					HOSTCMD_ACT_GET_MAX_TX_PWR,
+					channel->hw_value, band, width, sub_ch);
+
+		for (i = 0; i < priv->pwr_level; i++) {
+			tmp = priv->max_tx_pow[i];
+			maxtxpow[i] = ((tmp - reduce_val) > 0) ?
+				(tmp - reduce_val) : 0;
+		}
+
+		rc = mwl_fwcmd_set_tx_powers(priv, maxtxpow,
+					     HOSTCMD_ACT_SET_MAX_TX_PWR,
+					     channel->hw_value, band,
+					     width, sub_ch);
+		return rc;
+	}
+
+	if ((priv->powinited & MWL_POWER_INIT_2) == 0) {
+		mwl_fwcmd_get_tx_powers(priv, priv->max_tx_pow,
+					HOSTCMD_ACT_GEN_GET_LIST,
+					channel->hw_value, band, width, sub_ch);
+		priv->powinited |= MWL_POWER_INIT_2;
+	}
+
+	if ((priv->powinited & MWL_POWER_INIT_1) == 0) {
+		mwl_fwcmd_get_tx_powers(priv, priv->target_powers,
+					HOSTCMD_ACT_GEN_GET_LIST,
+					channel->hw_value, band, width, sub_ch);
+		priv->powinited |= MWL_POWER_INIT_1;
+	}
+
+	for (i = 0; i < priv->pwr_level; i++) {
+		if (priv->target_powers[i] > priv->max_tx_pow[i])
+			tmp = priv->max_tx_pow[i];
+		else
+			tmp = priv->target_powers[i];
+		maxtxpow[i] = ((tmp - reduce_val) > 0) ? (tmp - reduce_val) : 0;
+	}
+
+	rc = mwl_fwcmd_set_tx_powers(priv, maxtxpow, HOSTCMD_ACT_GEN_SET,
+				     channel->hw_value, band, width, sub_ch);
+
+	return rc;
+}
+
+int mwl_fwcmd_tx_power(struct ieee80211_hw *hw,
+		       struct ieee80211_conf *conf, u8 fraction)
+{
+	struct ieee80211_channel *channel = conf->chandef.chan;
+	struct mwl_priv *priv = hw->priv;
+	int reduce_val = 0;
+	u16 band = 0, width = 0, sub_ch = 0;
+	u16 txpow[SYSADPT_TX_GRP_PWR_LEVEL_TOTAL];
+	int index, found = 0;
+	int i, tmp;
+	int rc = 0;
+
+	if ((priv->chip_type != MWL8997) && (priv->forbidden_setting))
+		return rc;
+
+	switch (fraction) {
+	case 0:
+		reduce_val = 0;    /* Max */
+		break;
+	case 1:
+		reduce_val = 2;    /* 75% -1.25db */
+		break;
+	case 2:
+		reduce_val = 3;    /* 50% -3db */
+		break;
+	case 3:
+		reduce_val = 6;    /* 25% -6db */
+		break;
+	default:
+		/* larger than case 3,  pCmd->MaxPowerLevel is min */
+		reduce_val = 0xff;
+		break;
+	}
+
+	if (channel->band == NL80211_BAND_2GHZ)
+		band = FREQ_BAND_2DOT4GHZ;
+	else if (channel->band == NL80211_BAND_5GHZ)
+		band = FREQ_BAND_5GHZ;
+
+	switch (conf->chandef.width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+	case NL80211_CHAN_WIDTH_20:
+		width = CH_20_MHZ_WIDTH;
+		sub_ch = NO_EXT_CHANNEL;
+		break;
+	case NL80211_CHAN_WIDTH_40:
+		width = CH_40_MHZ_WIDTH;
+		if (conf->chandef.center_freq1 > channel->center_freq)
+			sub_ch = EXT_CH_ABOVE_CTRL_CH;
+		else
+			sub_ch = EXT_CH_BELOW_CTRL_CH;
+		break;
+	case NL80211_CHAN_WIDTH_80:
+		width = CH_80_MHZ_WIDTH;
+		if (conf->chandef.center_freq1 > channel->center_freq)
+			sub_ch = EXT_CH_ABOVE_CTRL_CH;
+		else
+			sub_ch = EXT_CH_BELOW_CTRL_CH;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (priv->chip_type == MWL8997) {
+		mwl_fwcmd_get_tx_powers(priv, priv->target_powers,
+					HOSTCMD_ACT_GET_TARGET_TX_PWR,
+					channel->hw_value, band, width, sub_ch);
+
+		for (i = 0; i < priv->pwr_level; i++) {
+			tmp = priv->target_powers[i];
+			txpow[i] = ((tmp - reduce_val) > 0) ?
+				(tmp - reduce_val) : 0;
+		}
+
+		rc = mwl_fwcmd_set_tx_powers(priv, txpow,
+					     HOSTCMD_ACT_SET_TARGET_TX_PWR,
+					     channel->hw_value, band,
+					     width, sub_ch);
+
+		return rc;
+	}
+
+	/* search tx power table if exist */
+	for (index = 0; index < SYSADPT_MAX_NUM_CHANNELS; index++) {
+		struct mwl_tx_pwr_tbl *tx_pwr;
+
+		tx_pwr = &priv->tx_pwr_tbl[index];
+
+		/* do nothing if table is not loaded */
+		if (tx_pwr->channel == 0)
+			break;
+
+		if (tx_pwr->channel == channel->hw_value) {
+			priv->cdd = tx_pwr->cdd;
+			priv->txantenna2 = tx_pwr->txantenna2;
+
+			if (tx_pwr->setcap)
+				priv->powinited = MWL_POWER_INIT_1;
+			else
+				priv->powinited = MWL_POWER_INIT_2;
+
+			for (i = 0; i < priv->pwr_level; i++) {
+				if (tx_pwr->setcap)
+					priv->max_tx_pow[i] =
+						tx_pwr->tx_power[i];
+				else
+					priv->target_powers[i] =
+						tx_pwr->tx_power[i];
+			}
+
+			found = 1;
+			break;
+		}
+	}
+
+	if ((priv->powinited & MWL_POWER_INIT_2) == 0) {
+		mwl_fwcmd_get_tx_powers(priv, priv->max_tx_pow,
+					HOSTCMD_ACT_GEN_GET_LIST,
+					channel->hw_value, band, width, sub_ch);
+
+		priv->powinited |= MWL_POWER_INIT_2;
+	}
+
+	if ((priv->powinited & MWL_POWER_INIT_1) == 0) {
+		mwl_fwcmd_get_tx_powers(priv, priv->target_powers,
+					HOSTCMD_ACT_GEN_GET_LIST,
+					channel->hw_value, band, width, sub_ch);
+
+		priv->powinited |= MWL_POWER_INIT_1;
+	}
+
+	for (i = 0; i < priv->pwr_level; i++) {
+		if (found) {
+			if ((priv->tx_pwr_tbl[index].setcap) &&
+			    (priv->tx_pwr_tbl[index].tx_power[i] >
+			    priv->max_tx_pow[i]))
+				tmp = priv->max_tx_pow[i];
+			else
+				tmp = priv->tx_pwr_tbl[index].tx_power[i];
+		} else {
+			if (priv->target_powers[i] > priv->max_tx_pow[i])
+				tmp = priv->max_tx_pow[i];
+			else
+				tmp = priv->target_powers[i];
+		}
+
+		txpow[i] = ((tmp - reduce_val) > 0) ? (tmp - reduce_val) : 0;
+	}
+
+	rc = mwl_fwcmd_set_tx_powers(priv, txpow, HOSTCMD_ACT_GEN_SET_LIST,
+				     channel->hw_value, band, width, sub_ch);
+
+	return rc;
+}
+
+int mwl_fwcmd_rf_antenna(struct ieee80211_hw *hw, int dir, int antenna)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_802_11_rf_antenna *pcmd;
+
+	pcmd = (struct hostcmd_cmd_802_11_rf_antenna *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_802_11_RF_ANTENNA);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+	pcmd->action = cpu_to_le16(dir);
+
+	if (dir == WL_ANTENNATYPE_RX) {
+		u8 rx_antenna;
+
+		if (priv->chip_type == MWL8964) {
+			if (antenna == ANTENNA_RX_4_AUTO)
+				rx_antenna = 0xf;
+			else if (antenna == ANTENNA_RX_3)
+				rx_antenna = 7;
+			else if (antenna == ANTENNA_RX_2)
+				rx_antenna = 4;
+			else
+				rx_antenna = 1;
+
+			pcmd->antenna_mode = cpu_to_le16(rx_antenna);
+		} else {
+			rx_antenna = 4;
+
+			if (antenna != 0)
+				pcmd->antenna_mode = cpu_to_le16(antenna);
+			else
+				pcmd->antenna_mode = cpu_to_le16(rx_antenna);
+		}
+	} else {
+		u8 tx_antenna = 0xf;
+
+		if (antenna != 0)
+			pcmd->antenna_mode = cpu_to_le16(antenna);
+		else
+			pcmd->antenna_mode = cpu_to_le16(tx_antenna);
+	}
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_802_11_RF_ANTENNA)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_broadcast_ssid_enable(struct ieee80211_hw *hw,
+				    struct ieee80211_vif *vif, bool enable)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_broadcast_ssid_enable *pcmd;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	pcmd = (struct hostcmd_cmd_broadcast_ssid_enable *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_BROADCAST_SSID_ENABLE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+	pcmd->enable = cpu_to_le32(enable);
+	if (priv->chip_type == MWL8997)
+		pcmd->hidden_ssid_info = enable ? 0 : 2;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_BROADCAST_SSID_ENABLE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_cfg_data(struct ieee80211_hw *hw, u16 type)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_cfg *pcmd;
+
+	if (!priv->cal_data)
+		return 0;
+
+	pcmd = (struct hostcmd_cmd_set_cfg *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->data_len = mwl_fwcmd_parse_cal_cfg(priv->cal_data->data,
+						 priv->cal_data->size,
+						 pcmd->data);
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_CFG);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd) +
+		le16_to_cpu(pcmd->data_len) - sizeof(pcmd->data));
+	pcmd->action = cpu_to_le16(HOSTCMD_ACT_GEN_SET);
+	pcmd->type = cpu_to_le16(type);
+
+	utils_dump_data_debug("CalData:", pcmd->data,
+			      le16_to_cpu(pcmd->data_len));
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_CFG)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		release_firmware(priv->cal_data);
+		priv->cal_data = NULL;
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	release_firmware(priv->cal_data);
+	priv->cal_data = NULL;
+
+	return 0;
+}
+
+int mwl_fwcmd_set_rf_channel(struct ieee80211_hw *hw,
+			     struct ieee80211_conf *conf)
+{
+	struct ieee80211_channel *channel = conf->chandef.chan;
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_rf_channel *pcmd;
+	u32 chnl_flags, freq_band, chnl_width, act_primary;
+
+	pcmd = (struct hostcmd_cmd_set_rf_channel *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	if (priv->chip_type == MWL8997) {
+		memset(pcmd, 0x00,
+		       sizeof(struct hostcmd_cmd_set_rf_channel_kf2));
+		pcmd->cmd_hdr.len = cpu_to_le16(
+			sizeof(struct hostcmd_cmd_set_rf_channel_kf2));
+	} else {
+		memset(pcmd, 0x00, sizeof(*pcmd));
+		pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	}
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_RF_CHANNEL);
+	pcmd->action = cpu_to_le16(WL_SET);
+	pcmd->curr_chnl = channel->hw_value;
+
+	if (channel->band == NL80211_BAND_2GHZ) {
+		freq_band = FREQ_BAND_2DOT4GHZ;
+	} else if (channel->band == NL80211_BAND_5GHZ) {
+		freq_band = FREQ_BAND_5GHZ;
+	} else {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EINVAL;
+	}
+
+	switch (conf->chandef.width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+	case NL80211_CHAN_WIDTH_20:
+		chnl_width = CH_20_MHZ_WIDTH;
+		act_primary = ACT_PRIMARY_CHAN_0;
+		break;
+	case NL80211_CHAN_WIDTH_40:
+		chnl_width = CH_40_MHZ_WIDTH;
+		if (conf->chandef.center_freq1 > channel->center_freq)
+			act_primary = ACT_PRIMARY_CHAN_0;
+		else
+			act_primary = ACT_PRIMARY_CHAN_1;
+		break;
+	case NL80211_CHAN_WIDTH_80:
+		chnl_width = CH_80_MHZ_WIDTH;
+		act_primary =
+			mwl_fwcmd_get_80m_pri_chnl(pcmd->curr_chnl);
+		break;
+	case NL80211_CHAN_WIDTH_160:
+		chnl_width = CH_160_MHZ_WIDTH;
+		act_primary =
+			mwl_fwcmd_get_160m_pri_chnl(pcmd->curr_chnl);
+		break;
+	default:
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EINVAL;
+	}
+
+	chnl_flags = (freq_band & FREQ_BAND_MASK) |
+		((chnl_width << CHNL_WIDTH_SHIFT) & CHNL_WIDTH_MASK) |
+		((act_primary << ACT_PRIMARY_SHIFT) & ACT_PRIMARY_MASK);
+
+	pcmd->chnl_flags = cpu_to_le32(chnl_flags);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_RF_CHANNEL)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	if (pcmd->cmd_hdr.result != 0) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	if (priv->sw_scanning) {
+		priv->survey_info_idx++;
+		mwl_fwcmd_get_survey(hw, priv->survey_info_idx);
+	} else {
+		mwl_fwcmd_get_survey(hw, 0);
+		memset(&priv->cur_survey_info, 0,
+		       sizeof(struct mwl_survey_info));
+	}
+
+	return 0;
+}
+
+int mwl_fwcmd_set_aid(struct ieee80211_hw *hw,
+		      struct ieee80211_vif *vif, u8 *bssid, u16 aid)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_set_aid *pcmd;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	pcmd = (struct hostcmd_cmd_set_aid *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_AID);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+	pcmd->aid = cpu_to_le16(aid);
+	ether_addr_copy(pcmd->mac_addr, bssid);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_AID)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_infra_mode(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_set_infra_mode *pcmd;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	pcmd = (struct hostcmd_cmd_set_infra_mode *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_INFRA_MODE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_INFRA_MODE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_rts_threshold(struct ieee80211_hw *hw, int threshold)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_802_11_rts_thsd *pcmd;
+
+	pcmd = (struct hostcmd_cmd_802_11_rts_thsd *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_802_11_RTS_THSD);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action  = cpu_to_le16(WL_SET);
+	pcmd->threshold = cpu_to_le16(threshold);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_802_11_RTS_THSD)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_edca_params(struct ieee80211_hw *hw, u8 index,
+			      u16 cw_min, u16 cw_max, u8 aifs, u16 txop)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_edca_params *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_edca_params *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_EDCA_PARAMS);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+	pcmd->action = cpu_to_le16(0xffff);
+	pcmd->txop = cpu_to_le16(txop);
+	pcmd->cw_max = cpu_to_le32(cw_max);
+	pcmd->cw_min = cpu_to_le32(cw_min);
+	pcmd->aifsn = aifs;
+	pcmd->txq_num = index;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_EDCA_PARAMS)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_radar_detect(struct ieee80211_hw *hw, u16 action)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_802_11h_detect_radar *pcmd;
+	u16 radar_type = RADAR_TYPE_CODE_0;
+	u8 channel = hw->conf.chandef.chan->hw_value;
+
+	pcmd = (struct hostcmd_cmd_802_11h_detect_radar *)&priv->pcmd_buf[0];
+
+	if (priv->dfs_region == NL80211_DFS_JP) {
+		if (channel >= 52 && channel <= 64)
+			radar_type = RADAR_TYPE_CODE_53;
+		else if (channel >= 100 && channel <= 140)
+			radar_type = RADAR_TYPE_CODE_56;
+		else
+			radar_type = RADAR_TYPE_CODE_0;
+	} else if (priv->dfs_region == NL80211_DFS_ETSI) {
+		radar_type = RADAR_TYPE_CODE_ETSI;
+	}
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_802_11H_DETECT_RADAR);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action = cpu_to_le16(action);
+	pcmd->radar_type_code = cpu_to_le16(radar_type);
+	pcmd->min_chirp_cnt = cpu_to_le16(priv->dfs_chirp_count_min);
+	pcmd->chirp_time_intvl = cpu_to_le16(priv->dfs_chirp_time_interval);
+	pcmd->pw_filter = cpu_to_le16(priv->dfs_pw_filter);
+	pcmd->min_num_radar = cpu_to_le16(priv->dfs_min_num_radar);
+	pcmd->pri_min_num = cpu_to_le16(priv->dfs_min_pri_count);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_802_11H_DETECT_RADAR)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_wmm_mode(struct ieee80211_hw *hw, bool enable)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_wmm_mode *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_wmm_mode *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_WMM_MODE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action = cpu_to_le16(enable ? WL_ENABLE : WL_DISABLE);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_WMM_MODE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_ht_guard_interval(struct ieee80211_hw *hw, u32 gi_type)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_ht_guard_interval *pcmd;
+
+	pcmd = (struct hostcmd_cmd_ht_guard_interval *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_HT_GUARD_INTERVAL);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action = cpu_to_le32(WL_SET);
+	pcmd->gi_type = cpu_to_le32(gi_type);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_HT_GUARD_INTERVAL)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_use_fixed_rate(struct ieee80211_hw *hw, int mcast, int mgmt)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_fixed_rate *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_fixed_rate *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_FIXED_RATE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+	pcmd->action = cpu_to_le32(HOSTCMD_ACT_NOT_USE_FIXED_RATE);
+	pcmd->multicast_rate = mcast;
+	pcmd->management_rate = mgmt;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_FIXED_RATE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_linkadapt_cs_mode(struct ieee80211_hw *hw, u16 cs_mode)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_linkadapt_cs_mode *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_linkadapt_cs_mode *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_LINKADAPT_CS_MODE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action  = cpu_to_le16(HOSTCMD_ACT_GEN_SET);
+	pcmd->cs_mode = cpu_to_le16(cs_mode);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_LINKADAPT_CS_MODE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_dump_otp_data(struct ieee80211_hw *hw)
+{
+	int otp_data_len;
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_dump_otp_data *pcmd;
+
+	pcmd = (struct hostcmd_cmd_dump_otp_data *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_DUMP_OTP_DATA);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_DUMP_OTP_DATA)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	otp_data_len = pcmd->cmd_hdr.len - cpu_to_le16(sizeof(*pcmd));
+
+	if (otp_data_len <= SYSADPT_OTP_BUF_SIZE) {
+		wiphy_info(hw->wiphy, "OTP data len = %d\n", otp_data_len);
+		priv->otp_data.len = otp_data_len;
+		memcpy(priv->otp_data.buf, pcmd->pload, otp_data_len);
+	} else {
+		wiphy_err(hw->wiphy, "Driver OTP buf size is less\n");
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_rate_adapt_mode(struct ieee80211_hw *hw, u16 mode)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_rate_adapt_mode *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_rate_adapt_mode *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_RATE_ADAPT_MODE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action = cpu_to_le16(WL_SET);
+	pcmd->rate_adapt_mode = cpu_to_le16(mode);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_RATE_ADAPT_MODE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_mac_addr_client(struct ieee80211_hw *hw,
+				  struct ieee80211_vif *vif, u8 *mac_addr)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_set_mac_addr *pcmd;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	pcmd = (struct hostcmd_cmd_set_mac_addr *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_MAC_ADDR);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+	pcmd->mac_type = cpu_to_le16(WL_MAC_TYPE_SECONDARY_CLIENT);
+	ether_addr_copy(pcmd->mac_addr, mac_addr);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_MAC_ADDR)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_get_watchdog_bitmap(struct ieee80211_hw *hw, u8 *bitmap)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_get_watchdog_bitmap *pcmd;
+
+	pcmd = (struct hostcmd_cmd_get_watchdog_bitmap *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_GET_WATCHDOG_BITMAP);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_GET_WATCHDOG_BITMAP)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	*bitmap = pcmd->watchdog_bitmap;
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_remove_mac_addr(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif, u8 *mac_addr)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_set_mac_addr *pcmd;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	pcmd = (struct hostcmd_cmd_set_mac_addr *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_DEL_MAC_ADDR);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+	ether_addr_copy(pcmd->mac_addr, mac_addr);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_DEL_MAC_ADDR)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_bss_start(struct ieee80211_hw *hw,
+			struct ieee80211_vif *vif, bool enable)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_bss_start *pcmd;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	if (enable && (priv->running_bsses & (1 << mwl_vif->macid)))
+		return 0;
+
+	if (!enable && !(priv->running_bsses & (1 << mwl_vif->macid)))
+		return 0;
+
+	pcmd = (struct hostcmd_cmd_bss_start *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_BSS_START);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+
+	if (enable) {
+		pcmd->enable = cpu_to_le32(WL_ENABLE);
+	} else {
+		if (mwl_vif->macid == 0)
+			pcmd->enable = cpu_to_le32(WL_DISABLE);
+		else
+			pcmd->enable = cpu_to_le32(WL_DISABLE_VMAC);
+	}
+	if (priv->chip_type == MWL8964)
+		pcmd->amsdu = MWL_AMSDU_SIZE_11K;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_BSS_START)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	if (enable)
+		priv->running_bsses |= (1 << mwl_vif->macid);
+	else
+		priv->running_bsses &= ~(1 << mwl_vif->macid);
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_beacon(struct ieee80211_hw *hw,
+			 struct ieee80211_vif *vif, u8 *beacon, int len)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct beacon_info *b_inf;
+	int rc;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+	b_inf = &mwl_vif->beacon_info;
+
+	mwl_fwcmd_parse_beacon(priv, mwl_vif, beacon, len);
+
+	if (!b_inf->valid)
+		goto err;
+
+	if (mwl_fwcmd_set_ies(priv, mwl_vif))
+		goto err;
+
+	if (mwl_fwcmd_set_wsc_ie(hw, b_inf->ie_wsc_len, b_inf->ie_wsc_ptr))
+		goto err;
+
+	if (mwl_fwcmd_set_ap_beacon(priv, mwl_vif, &vif->bss_conf))
+		goto err;
+
+	if (b_inf->cap_info & WLAN_CAPABILITY_SPECTRUM_MGMT)
+		rc = mwl_fwcmd_set_spectrum_mgmt(priv, true);
+	else
+		rc = mwl_fwcmd_set_spectrum_mgmt(priv, false);
+	if (rc)
+		goto err;
+
+	if (b_inf->power_constraint)
+		rc = mwl_fwcmd_set_power_constraint(priv,
+						    b_inf->power_constraint);
+	if (rc)
+		goto err;
+
+	if (mwl_fwcmd_set_country_code(priv, mwl_vif, &vif->bss_conf))
+		goto err;
+
+	b_inf->valid = false;
+
+	return 0;
+
+err:
+
+	b_inf->valid = false;
+
+	return -EIO;
+}
+
+int mwl_fwcmd_set_new_stn_add(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif,
+			      struct ieee80211_sta *sta)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct mwl_sta *sta_info;
+	struct hostcmd_cmd_set_new_stn *pcmd;
+	u32 rates;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+	sta_info = mwl_dev_get_sta(sta);
+
+	pcmd = (struct hostcmd_cmd_set_new_stn *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_NEW_STN);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+
+	pcmd->action = cpu_to_le16(HOSTCMD_ACT_STA_ACTION_ADD);
+	pcmd->aid = cpu_to_le16(sta->aid);
+	pcmd->stn_id = cpu_to_le16(sta_info->stnid);
+	if (priv->chip_type == MWL8997)
+		pcmd->if_type = cpu_to_le16(vif->type);
+	else
+		pcmd->if_type = cpu_to_le16(1);
+	ether_addr_copy(pcmd->mac_addr, sta->addr);
+
+	if (hw->conf.chandef.chan->band == NL80211_BAND_2GHZ)
+		rates = sta->supp_rates[NL80211_BAND_2GHZ];
+	else
+		rates = sta->supp_rates[NL80211_BAND_5GHZ] << 5;
+	pcmd->peer_info.legacy_rate_bitmap = cpu_to_le32(rates);
+
+	if (sta->ht_cap.ht_supported) {
+		int i;
+
+		for (i = 0; i < 4; i++) {
+			if (i < sta->rx_nss) {
+				pcmd->peer_info.ht_rates[i] =
+					sta->ht_cap.mcs.rx_mask[i];
+			} else {
+				pcmd->peer_info.ht_rates[i] = 0;
+			}
+		}
+		pcmd->peer_info.ht_cap_info = cpu_to_le16(sta->ht_cap.cap);
+		pcmd->peer_info.mac_ht_param_info =
+			(sta->ht_cap.ampdu_factor & 3) |
+			((sta->ht_cap.ampdu_density & 7) << 2);
+	}
+
+	if (sta->vht_cap.vht_supported) {
+		u32 rx_mcs_map_mask = 0;
+
+		rx_mcs_map_mask = ((0x0000FFFF) >> (sta->rx_nss * 2))
+			<< (sta->rx_nss * 2);
+		pcmd->peer_info.vht_max_rx_mcs =
+			cpu_to_le32((*((u32 *)
+			&sta->vht_cap.vht_mcs.rx_mcs_map)) | rx_mcs_map_mask);
+		pcmd->peer_info.vht_cap = cpu_to_le32(sta->vht_cap.cap);
+		pcmd->peer_info.vht_rx_channel_width = sta->bandwidth;
+	}
+
+	pcmd->is_qos_sta = sta->wme;
+	pcmd->qos_info = ((sta->uapsd_queues << 4) | (sta->max_sp << 1));
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_NEW_STN)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		ether_addr_copy(pcmd->mac_addr, mwl_vif->sta_mac);
+		pcmd->aid = cpu_to_le16(sta->aid + 1);
+		pcmd->stn_id = cpu_to_le16(sta_info->sta_stnid);
+		pcmd->if_type = cpu_to_le16(0);
+		if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_NEW_STN)) {
+			mutex_unlock(&priv->fwcmd_mutex);
+			return -EIO;
+		}
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_new_stn_add_sc4(struct ieee80211_hw *hw,
+				  struct ieee80211_vif *vif,
+				  struct ieee80211_sta *sta,
+				  u32 wds)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct mwl_sta *sta_info;
+	struct hostcmd_cmd_set_new_stn_sc4 *pcmd;
+	u32 rates;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+	sta_info = mwl_dev_get_sta(sta);
+
+	pcmd = (struct hostcmd_cmd_set_new_stn_sc4 *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_NEW_STN);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+
+	pcmd->action = cpu_to_le16(HOSTCMD_ACT_STA_ACTION_ADD);
+	pcmd->aid = cpu_to_le16(sta->aid);
+	pcmd->stn_id = cpu_to_le16(sta_info->stnid);
+	ether_addr_copy(pcmd->mac_addr, sta->addr);
+
+	if (hw->conf.chandef.chan->band == NL80211_BAND_2GHZ)
+		rates = sta->supp_rates[NL80211_BAND_2GHZ];
+	else
+		rates = sta->supp_rates[NL80211_BAND_5GHZ] << 5;
+	pcmd->peer_info.legacy_rate_bitmap = cpu_to_le32(rates);
+
+	if (sta->ht_cap.ht_supported) {
+		int i;
+
+		for (i = 0; i < 4; i++) {
+			if (i < sta->rx_nss) {
+				pcmd->peer_info.ht_rates[i] =
+					sta->ht_cap.mcs.rx_mask[i];
+			} else {
+				pcmd->peer_info.ht_rates[i] = 0;
+			}
+		}
+		pcmd->peer_info.ht_cap_info = cpu_to_le16(sta->ht_cap.cap);
+		pcmd->peer_info.mac_ht_param_info =
+			(sta->ht_cap.ampdu_factor & 3) |
+			((sta->ht_cap.ampdu_density & 7) << 2);
+	}
+
+	if (sta->vht_cap.vht_supported) {
+		u32 rx_mcs_map_mask = 0;
+
+		rx_mcs_map_mask = ((0x0000FFFF) >> (sta->rx_nss * 2))
+			<< (sta->rx_nss * 2);
+		pcmd->peer_info.vht_max_rx_mcs =
+			cpu_to_le32((*((u32 *)
+			&sta->vht_cap.vht_mcs.rx_mcs_map)) | rx_mcs_map_mask);
+		pcmd->peer_info.vht_cap = cpu_to_le32(sta->vht_cap.cap);
+		pcmd->peer_info.vht_rx_channel_width = sta->bandwidth;
+	}
+
+	pcmd->is_qos_sta = sta->wme;
+	pcmd->qos_info = ((sta->uapsd_queues << 4) | (sta->max_sp << 1));
+	pcmd->wds = cpu_to_le32(wds);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_NEW_STN)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		ether_addr_copy(pcmd->mac_addr, mwl_vif->sta_mac);
+		pcmd->aid = cpu_to_le16(sta->aid + 1);
+		pcmd->stn_id = cpu_to_le16(sta_info->sta_stnid);
+		if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_NEW_STN)) {
+			mutex_unlock(&priv->fwcmd_mutex);
+			return -EIO;
+		}
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_new_stn_wds_sc4(struct ieee80211_hw *hw, u8 *addr)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_new_stn_sc4 *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_new_stn_sc4 *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_NEW_STN);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+	pcmd->action = cpu_to_le16(HOSTCMD_ACT_STA_ACTION_MODIFY);
+	ether_addr_copy(pcmd->mac_addr, addr);
+	pcmd->wds = cpu_to_le32(WDS_MODE);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_NEW_STN)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_new_stn_add_self(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_set_new_stn *pcmd;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	pcmd = (struct hostcmd_cmd_set_new_stn *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	if (priv->chip_type == MWL8964) {
+		memset(pcmd, 0x00, sizeof(struct hostcmd_cmd_set_new_stn_sc4));
+		pcmd->cmd_hdr.len =
+			cpu_to_le16(sizeof(struct hostcmd_cmd_set_new_stn_sc4));
+	} else {
+		memset(pcmd, 0x00, sizeof(*pcmd));
+		pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	}
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_NEW_STN);
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+
+	pcmd->action = cpu_to_le16(HOSTCMD_ACT_STA_ACTION_ADD);
+	ether_addr_copy(pcmd->mac_addr, vif->addr);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_NEW_STN)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_new_stn_del(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif, u8 *addr)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_set_new_stn *pcmd;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	pcmd = (struct hostcmd_cmd_set_new_stn *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	if (priv->chip_type == MWL8964) {
+		memset(pcmd, 0x00, sizeof(struct hostcmd_cmd_set_new_stn_sc4));
+		pcmd->cmd_hdr.len =
+			cpu_to_le16(sizeof(struct hostcmd_cmd_set_new_stn_sc4));
+	} else {
+		memset(pcmd, 0x00, sizeof(*pcmd));
+		pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	}
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_NEW_STN);
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+
+	pcmd->action = cpu_to_le16(HOSTCMD_ACT_STA_ACTION_REMOVE);
+	ether_addr_copy(pcmd->mac_addr, addr);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_NEW_STN)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		ether_addr_copy(pcmd->mac_addr, mwl_vif->sta_mac);
+
+		if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_NEW_STN)) {
+			mutex_unlock(&priv->fwcmd_mutex);
+			return -EIO;
+		}
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_apmode(struct ieee80211_hw *hw, u8 apmode)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_apmode *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_apmode *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_APMODE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->apmode = apmode;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_APMODE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_switch_channel(struct ieee80211_hw *hw,
+				 struct ieee80211_channel_switch *ch_switch)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_switch_channel *pcmd;
+	struct cfg80211_chan_def *chandef = &ch_switch->chandef;
+	struct ieee80211_channel *channel = chandef->chan;
+	u32 chnl_flags, freq_band, chnl_width, act_primary, sec_chnl_offset;
+
+	if (priv->csa_active)
+		return 0;
+
+	if (channel->band == NL80211_BAND_2GHZ)
+		freq_band = FREQ_BAND_2DOT4GHZ;
+	else if (channel->band == NL80211_BAND_5GHZ)
+		freq_band = FREQ_BAND_5GHZ;
+	else
+		return -EINVAL;
+
+	switch (chandef->width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+	case NL80211_CHAN_WIDTH_20:
+		chnl_width = CH_20_MHZ_WIDTH;
+		act_primary = ACT_PRIMARY_CHAN_0;
+		sec_chnl_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;
+		break;
+	case NL80211_CHAN_WIDTH_40:
+		chnl_width = CH_40_MHZ_WIDTH;
+		if (chandef->center_freq1 > channel->center_freq) {
+			act_primary = ACT_PRIMARY_CHAN_0;
+			sec_chnl_offset = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;
+		} else {
+			act_primary = ACT_PRIMARY_CHAN_1;
+			sec_chnl_offset = IEEE80211_HT_PARAM_CHA_SEC_BELOW;
+		}
+		break;
+	case NL80211_CHAN_WIDTH_80:
+		chnl_width = CH_80_MHZ_WIDTH;
+		act_primary =
+			mwl_fwcmd_get_80m_pri_chnl(channel->hw_value);
+		if ((act_primary == ACT_PRIMARY_CHAN_0) ||
+		    (act_primary == ACT_PRIMARY_CHAN_2))
+			sec_chnl_offset = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;
+		else
+			sec_chnl_offset = IEEE80211_HT_PARAM_CHA_SEC_BELOW;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	chnl_flags = (freq_band & FREQ_BAND_MASK) |
+		((chnl_width << CHNL_WIDTH_SHIFT) & CHNL_WIDTH_MASK) |
+		((act_primary << ACT_PRIMARY_SHIFT) & ACT_PRIMARY_MASK);
+
+	pcmd = (struct hostcmd_cmd_set_switch_channel *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_SWITCH_CHANNEL);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->next_11h_chnl = cpu_to_le32(channel->hw_value);
+	pcmd->mode = cpu_to_le32(ch_switch->block_tx);
+	pcmd->init_count = cpu_to_le32(ch_switch->count + 1);
+	pcmd->chnl_flags = cpu_to_le32(chnl_flags);
+	pcmd->next_ht_extchnl_offset = cpu_to_le32(sec_chnl_offset);
+	pcmd->dfs_test_mode = cpu_to_le32(priv->dfs_test);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_SWITCH_CHANNEL)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	priv->csa_active = true;
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_update_encryption_enable(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       u8 *addr, u8 encr_type)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_update_encryption *pcmd;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	pcmd = (struct hostcmd_cmd_update_encryption *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_UPDATE_ENCRYPTION);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+
+	pcmd->action_type = cpu_to_le32(ENCR_ACTION_ENABLE_HW_ENCR);
+	ether_addr_copy(pcmd->mac_addr, addr);
+	pcmd->action_data[0] = encr_type;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_UPDATE_ENCRYPTION)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	if ((vif->type == NL80211_IFTYPE_STATION) &&
+	    (priv->chip_type != MWL8964)) {
+		if (ether_addr_equal(mwl_vif->bssid, addr))
+			ether_addr_copy(pcmd->mac_addr, mwl_vif->sta_mac);
+		else
+			ether_addr_copy(pcmd->mac_addr, mwl_vif->bssid);
+
+		if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_UPDATE_ENCRYPTION)) {
+			mutex_unlock(&priv->fwcmd_mutex);
+			return -EIO;
+		}
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_encryption_set_key(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif, u8 *addr,
+				 struct ieee80211_key_conf *key)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_set_key *pcmd;
+	int rc;
+	int keymlen;
+	u32 action;
+	u8 idx;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	pcmd = (struct hostcmd_cmd_set_key *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_UPDATE_ENCRYPTION);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+
+	rc = mwl_fwcmd_encryption_set_cmd_info(pcmd, addr, key);
+	if (rc) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		if (rc != 1)
+			wiphy_err(hw->wiphy, "encryption not support\n");
+		return rc;
+	}
+
+	idx = key->keyidx;
+
+	if (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)
+		action = ENCR_ACTION_TYPE_SET_KEY;
+	else {
+		action = ENCR_ACTION_TYPE_SET_GROUP_KEY;
+		if (vif->type == NL80211_IFTYPE_MESH_POINT &&
+		    !ether_addr_equal(mwl_vif->bssid, addr))
+			pcmd->key_param.key_info |=
+				cpu_to_le32(ENCR_KEY_FLAG_RXGROUPKEY);
+	}
+
+	switch (key->cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		if (!mwl_vif->wep_key_conf[idx].enabled) {
+			memcpy(mwl_vif->wep_key_conf[idx].key, key,
+			       sizeof(*key) + key->keylen);
+			mwl_vif->wep_key_conf[idx].enabled = 1;
+		}
+
+		keymlen = key->keylen;
+		action = ENCR_ACTION_TYPE_SET_KEY;
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		keymlen = MAX_ENCR_KEY_LENGTH + 2 * MIC_KEY_LENGTH;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		keymlen = key->keylen;
+		break;
+	default:
+		mutex_unlock(&priv->fwcmd_mutex);
+		wiphy_err(hw->wiphy, "encryption not support\n");
+		return -ENOTSUPP;
+	}
+
+	memcpy((void *)&pcmd->key_param.key, key->key, keymlen);
+	pcmd->action_type = cpu_to_le32(action);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_UPDATE_ENCRYPTION)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		if (ether_addr_equal(mwl_vif->bssid, addr))
+			ether_addr_copy(pcmd->key_param.mac_addr,
+					mwl_vif->sta_mac);
+		else
+			ether_addr_copy(pcmd->key_param.mac_addr,
+					mwl_vif->bssid);
+
+		if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_UPDATE_ENCRYPTION)) {
+			mutex_unlock(&priv->fwcmd_mutex);
+			return -EIO;
+		}
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_encryption_remove_key(struct ieee80211_hw *hw,
+				    struct ieee80211_vif *vif, u8 *addr,
+				    struct ieee80211_key_conf *key)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_set_key *pcmd;
+	int rc;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	pcmd = (struct hostcmd_cmd_set_key *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_UPDATE_ENCRYPTION);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+
+	rc = mwl_fwcmd_encryption_set_cmd_info(pcmd, addr, key);
+	if (rc) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		if (rc != 1)
+			wiphy_err(hw->wiphy, "encryption not support\n");
+		return rc;
+	}
+
+	pcmd->action_type = cpu_to_le32(ENCR_ACTION_TYPE_REMOVE_KEY);
+
+	if (key->cipher == WLAN_CIPHER_SUITE_WEP40 ||
+	    key->cipher == WLAN_CIPHER_SUITE_WEP104)
+		mwl_vif->wep_key_conf[key->keyidx].enabled = 0;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_UPDATE_ENCRYPTION)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_check_ba(struct ieee80211_hw *hw,
+		       struct mwl_ampdu_stream *stream,
+		       struct ieee80211_vif *vif,
+		       u32 direction)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_bastream *pcmd;
+	u32 ba_flags, ba_type, ba_direction;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	pcmd = (struct hostcmd_cmd_bastream *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_BASTREAM);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+	pcmd->cmd_hdr.result = cpu_to_le16(0xffff);
+
+	pcmd->action_type = cpu_to_le32(BA_CHECK_STREAM);
+	ether_addr_copy(&pcmd->ba_info.create_params.peer_mac_addr[0],
+			stream->sta->addr);
+	pcmd->ba_info.create_params.tid = stream->tid;
+	ba_type = BA_FLAG_IMMEDIATE_TYPE;
+	ba_direction = direction;
+	ba_flags = (ba_type & BA_TYPE_MASK) |
+		((ba_direction << BA_DIRECTION_SHIFT) & BA_DIRECTION_MASK);
+	pcmd->ba_info.create_params.flags = cpu_to_le32(ba_flags);
+	pcmd->ba_info.create_params.queue_id = stream->idx;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_BASTREAM)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	if (pcmd->cmd_hdr.result != 0) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_create_ba(struct ieee80211_hw *hw,
+			struct mwl_ampdu_stream *stream,
+			struct ieee80211_vif *vif,
+			u32 direction, u8 buf_size, u16 seqno, bool amsdu)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	struct hostcmd_cmd_bastream *pcmd;
+	u32 ba_flags, ba_type, ba_direction;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	pcmd = (struct hostcmd_cmd_bastream *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_BASTREAM);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_hdr.macid = mwl_vif->macid;
+	pcmd->cmd_hdr.result = cpu_to_le16(0xffff);
+
+	pcmd->action_type = cpu_to_le32(BA_CREATE_STREAM);
+	pcmd->ba_info.create_params.bar_thrs = cpu_to_le32(buf_size);
+	pcmd->ba_info.create_params.window_size = cpu_to_le32(buf_size);
+	pcmd->ba_info.create_params.idle_thrs = cpu_to_le32(0x22000);
+	ether_addr_copy(&pcmd->ba_info.create_params.peer_mac_addr[0],
+			stream->sta->addr);
+	pcmd->ba_info.create_params.tid = stream->tid;
+	ba_direction = direction;
+	if (priv->chip_type == MWL8964) {
+		ba_type = amsdu ? MWL_AMSDU_SIZE_11K : 0;
+		ba_flags = (ba_type & BA_TYPE_MASK_NDP) |
+			((ba_direction << BA_DIRECTION_SHIFT_NDP) &
+			BA_DIRECTION_MASK_NDP);
+	} else {
+		ba_type = BA_FLAG_IMMEDIATE_TYPE;
+		ba_flags = (ba_type & BA_TYPE_MASK) |
+			((ba_direction << BA_DIRECTION_SHIFT) &
+			BA_DIRECTION_MASK);
+	}
+	pcmd->ba_info.create_params.flags = cpu_to_le32(ba_flags);
+	pcmd->ba_info.create_params.queue_id = stream->idx;
+	pcmd->ba_info.create_params.param_info =
+		(stream->sta->ht_cap.ampdu_factor &
+		 IEEE80211_HT_AMPDU_PARM_FACTOR) |
+		((stream->sta->ht_cap.ampdu_density << 2) &
+		 IEEE80211_HT_AMPDU_PARM_DENSITY);
+	if (direction == BA_FLAG_DIRECTION_UP) {
+		pcmd->ba_info.create_params.reset_seq_no = 0;
+		pcmd->ba_info.create_params.current_seq = cpu_to_le16(seqno);
+	} else {
+		pcmd->ba_info.create_params.reset_seq_no = 1;
+		pcmd->ba_info.create_params.current_seq = cpu_to_le16(0);
+	}
+	if (priv->chip_type == MWL8964 &&
+	    stream->sta->vht_cap.vht_supported) {
+		pcmd->ba_info.create_params.vht_rx_factor =
+			cpu_to_le32((stream->sta->vht_cap.cap  &
+			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK) >>
+			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT);
+	}
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_BASTREAM)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	if (pcmd->cmd_hdr.result != 0) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		wiphy_err(hw->wiphy, "create ba result error %d\n",
+			  le16_to_cpu(pcmd->cmd_hdr.result));
+		return -EINVAL;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_destroy_ba(struct ieee80211_hw *hw,
+			 struct mwl_ampdu_stream *stream,
+			 u32 direction)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_bastream *pcmd;
+	u32 ba_flags, ba_type, ba_direction;
+
+	pcmd = (struct hostcmd_cmd_bastream *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_BASTREAM);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+	pcmd->action_type = cpu_to_le32(BA_DESTROY_STREAM);
+	ba_type = 0;
+	ba_direction = direction;
+	if (priv->chip_type == MWL8964)
+		ba_flags = (ba_type & BA_TYPE_MASK_NDP) |
+			((ba_direction << BA_DIRECTION_SHIFT_NDP) &
+			BA_DIRECTION_MASK_NDP);
+	else
+		ba_flags = (ba_type & BA_TYPE_MASK) |
+			((ba_direction << BA_DIRECTION_SHIFT) &
+			BA_DIRECTION_MASK);
+	pcmd->ba_info.destroy_params.flags = cpu_to_le32(ba_flags);
+	pcmd->ba_info.destroy_params.fw_ba_context.context =
+		cpu_to_le32(stream->idx);
+	pcmd->ba_info.destroy_params.tid = stream->tid;
+	ether_addr_copy(&pcmd->ba_info.destroy_params.peer_mac_addr[0],
+			stream->sta->addr);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_BASTREAM)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+/* caller must hold priv->stream_lock when calling the stream functions */
+struct mwl_ampdu_stream *mwl_fwcmd_add_stream(struct ieee80211_hw *hw,
+					      struct ieee80211_sta *sta,
+					      u8 tid)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_ampdu_stream *stream;
+	struct mwl_sta *sta_info = mwl_dev_get_sta(sta);
+	int idx;
+
+	if (priv->chip_type == MWL8964) {
+		idx = ((sta_info->stnid - 1) * SYSADPT_MAX_TID) + tid;
+
+		if (idx < priv->ampdu_num) {
+			stream = &priv->ampdu[idx];
+			stream->sta = sta;
+			stream->state = AMPDU_STREAM_NEW;
+			stream->tid = tid;
+			stream->idx = idx;
+			return stream;
+		}
+	} else {
+		for (idx = 0; idx < priv->ampdu_num; idx++) {
+			stream = &priv->ampdu[idx];
+
+			if (stream->state == AMPDU_NO_STREAM) {
+				stream->sta = sta;
+				stream->state = AMPDU_STREAM_NEW;
+				stream->tid = tid;
+				stream->idx = idx;
+				return stream;
+			}
+		}
+	}
+
+	return NULL;
+}
+
+void mwl_fwcmd_del_sta_streams(struct ieee80211_hw *hw,
+			       struct ieee80211_sta *sta)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_ampdu_stream *stream;
+	struct mwl_sta *sta_info = mwl_dev_get_sta(sta);
+	int i, idx;
+
+	spin_lock_bh(&priv->stream_lock);
+	if (priv->chip_type == MWL8964) {
+		idx = (sta_info->stnid - 1) * SYSADPT_MAX_TID;
+		for (i = 0; i < SYSADPT_MAX_TID; i++) {
+			stream = &priv->ampdu[idx + i];
+
+			if (stream->sta == sta) {
+				spin_unlock_bh(&priv->stream_lock);
+				mwl_fwcmd_destroy_ba(hw, stream,
+						     BA_FLAG_DIRECTION_UP);
+				spin_lock_bh(&priv->stream_lock);
+				mwl_fwcmd_remove_stream(hw, stream);
+			}
+		}
+	} else {
+		for (idx = 0; idx < priv->ampdu_num; idx++) {
+			stream = &priv->ampdu[idx];
+
+			if (stream->sta == sta) {
+				spin_unlock_bh(&priv->stream_lock);
+				mwl_fwcmd_destroy_ba(hw, stream,
+						     BA_FLAG_DIRECTION_UP);
+				spin_lock_bh(&priv->stream_lock);
+				mwl_fwcmd_remove_stream(hw, stream);
+			}
+		}
+	}
+	spin_unlock_bh(&priv->stream_lock);
+}
+
+int mwl_fwcmd_start_stream(struct ieee80211_hw *hw,
+			   struct mwl_ampdu_stream *stream)
+{
+	/* if the stream has already been started, don't start it again */
+	if (stream->state != AMPDU_STREAM_NEW)
+		return 0;
+
+	return ieee80211_start_tx_ba_session(stream->sta, stream->tid, 0);
+}
+
+void mwl_fwcmd_remove_stream(struct ieee80211_hw *hw,
+			     struct mwl_ampdu_stream *stream)
+{
+	memset(stream, 0, sizeof(*stream));
+}
+
+struct mwl_ampdu_stream *mwl_fwcmd_lookup_stream(struct ieee80211_hw *hw,
+						 struct ieee80211_sta *sta,
+						 u8 tid)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_ampdu_stream *stream;
+	struct mwl_sta *sta_info = mwl_dev_get_sta(sta);
+	int idx;
+
+	if (priv->chip_type == MWL8964) {
+		idx = ((sta_info->stnid - 1) * SYSADPT_MAX_TID) + tid;
+		if (idx < priv->ampdu_num)
+			return &priv->ampdu[idx];
+	} else {
+		for (idx = 0; idx < priv->ampdu_num; idx++) {
+			stream = &priv->ampdu[idx];
+			if (stream->state == AMPDU_NO_STREAM)
+				continue;
+
+			if ((stream->sta == sta) && (stream->tid == tid))
+				return stream;
+		}
+	}
+
+	return NULL;
+}
+
+bool mwl_fwcmd_ampdu_allowed(struct ieee80211_sta *sta, u8 tid)
+{
+	struct mwl_sta *sta_info;
+	struct mwl_tx_info *tx_stats;
+
+	if (WARN_ON(tid >= SYSADPT_MAX_TID))
+		return false;
+
+	sta_info = mwl_dev_get_sta(sta);
+
+	tx_stats = &sta_info->tx_stats[tid];
+
+	return (sta_info->is_ampdu_allowed &&
+		tx_stats->pkts > SYSADPT_AMPDU_PACKET_THRESHOLD);
+}
+
+int mwl_fwcmd_set_optimization_level(struct ieee80211_hw *hw, u8 opt_level)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_optimization_level *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_optimization_level *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_OPTIMIZATION_LEVEL);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->opt_level = opt_level;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_OPTIMIZATION_LEVEL)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_wsc_ie(struct ieee80211_hw *hw, u8 len, u8 *data)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_wsc_ie *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_wsc_ie *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_WSC_IE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->len = cpu_to_le16(len);
+	memcpy(pcmd->data, data, len);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_WSC_IE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	pcmd->ie_type = cpu_to_le16(WSC_IE_SET_PROBE_RESPONSE);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_WSC_IE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_get_ratetable(struct ieee80211_hw *hw, u8 *addr, u8 *rate_table,
+			    u32 size, u8 type)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_get_ratetable *pcmd;
+
+	pcmd = (struct hostcmd_cmd_get_ratetable *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_GET_RATETABLE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->type = type;
+	ether_addr_copy(pcmd->addr, addr);
+	memset(rate_table, 0x00, size);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_GET_RATETABLE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	memcpy(rate_table, &pcmd->sorted_rates_idx_map, size);
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_get_seqno(struct ieee80211_hw *hw,
+			struct mwl_ampdu_stream *stream, u16 *start_seqno)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_get_seqno *pcmd;
+
+	pcmd = (struct hostcmd_cmd_get_seqno *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_GET_SEQNO);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	ether_addr_copy(pcmd->mac_addr, stream->sta->addr);
+	pcmd->tid = stream->tid;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_GET_SEQNO)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	*start_seqno = le16_to_cpu(pcmd->seq_no);
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_dwds_stamode(struct ieee80211_hw *hw, bool enable)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_dwds_enable *pcmd;
+
+	pcmd = (struct hostcmd_cmd_dwds_enable *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_DWDS_ENABLE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->enable = cpu_to_le32(enable);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_DWDS_ENABLE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_fw_flush_timer(struct ieee80211_hw *hw, u32 value)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_fw_flush_timer *pcmd;
+
+	pcmd = (struct hostcmd_cmd_fw_flush_timer *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_FW_FLUSH_TIMER);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->value = cpu_to_le32(value);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_FW_FLUSH_TIMER)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_cdd(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_cdd *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_cdd *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_CDD);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->enable = cpu_to_le32(priv->cdd);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_CDD)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_bftype(struct ieee80211_hw *hw, int mode)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_bftype *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_bftype *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_BFTYPE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action = cpu_to_le32(WL_SET);
+	pcmd->mode = cpu_to_le32(mode);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_BFTYPE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_reg_cau(struct ieee80211_hw *hw, u8 flag, u32 reg, u32 *val)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_bbp_reg_access *pcmd;
+
+	pcmd = (struct hostcmd_cmd_bbp_reg_access *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_CAU_REG_ACCESS);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->offset = cpu_to_le16(reg);
+	pcmd->action = cpu_to_le16(flag);
+	pcmd->value = *val;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_CAU_REG_ACCESS)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	*val = pcmd->value;
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_get_temp(struct ieee80211_hw *hw, u32 *temp)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_get_temp *pcmd;
+
+	pcmd = (struct hostcmd_cmd_get_temp *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_GET_TEMP);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_GET_TEMP)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	*temp = le32_to_cpu(pcmd->celcius);
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_led_ctrl(struct ieee80211_hw *hw, u8 enable, u8 rate)
+{
+	struct hostcmd_cmd_led_ctrl  *pcmd;
+	struct mwl_priv *priv = hw->priv;
+
+	pcmd = (struct hostcmd_cmd_led_ctrl *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_LED_CTRL);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action = 1; /* 1: set */
+	pcmd->led_enable = enable;
+	pcmd->led_control = 1; /* 1: SW */
+
+	switch (rate) {
+	case LED_BLINK_RATE_LOW:
+	case LED_BLINK_RATE_MID:
+	case LED_BLINK_RATE_HIGH:
+		pcmd->led_blink_rate = rate;
+		break;
+	default:
+		if (enable) {
+			mutex_unlock(&priv->fwcmd_mutex);
+			return -EINVAL;
+		}
+		break;
+	}
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_LED_CTRL)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_get_fw_region_code(struct ieee80211_hw *hw,
+				 u32 *fw_region_code)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_get_fw_region_code *pcmd;
+	u16 cmd;
+	int status;
+
+	pcmd = (struct hostcmd_cmd_get_fw_region_code *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	cmd = HOSTCMD_CMD_GET_FW_REGION_CODE;
+	pcmd->cmd_hdr.cmd = cpu_to_le16(cmd);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+	if (mwl_hif_exec_cmd(hw, cmd)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	if (pcmd->cmd_hdr.result != 0) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EINVAL;
+	}
+
+	status = le32_to_cpu(pcmd->status);
+
+	if (!status)
+		*fw_region_code = le32_to_cpu(pcmd->fw_region_code);
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_get_device_pwr_tbl(struct ieee80211_hw *hw,
+				 struct mwl_device_pwr_tbl *device_ch_pwrtbl,
+				 u8 *region_code,
+				 u8 *number_of_channels,
+				 u32 channel_index)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_get_device_pwr_tbl *pcmd;
+	int status;
+	u16 cmd;
+
+	pcmd = (struct hostcmd_cmd_get_device_pwr_tbl *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	cmd = HOSTCMD_CMD_GET_DEVICE_PWR_TBL;
+	pcmd->cmd_hdr.cmd = cpu_to_le16(cmd);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->status = cpu_to_le16(cmd);
+	pcmd->current_channel_index = cpu_to_le32(channel_index);
+
+	if (mwl_hif_exec_cmd(hw, cmd)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	device_ch_pwrtbl->channel = pcmd->channel_pwr_tbl.channel;
+	memcpy(device_ch_pwrtbl->tx_pwr, pcmd->channel_pwr_tbl.tx_pwr,
+	       priv->pwr_level);
+	device_ch_pwrtbl->dfs_capable = pcmd->channel_pwr_tbl.dfs_capable;
+	device_ch_pwrtbl->ax_ant = pcmd->channel_pwr_tbl.ax_ant;
+	device_ch_pwrtbl->cdd = pcmd->channel_pwr_tbl.cdd;
+	*region_code = pcmd->region_code;
+	*number_of_channels = pcmd->number_of_channels;
+	status = le16_to_cpu(pcmd->status);
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return status;
+}
+
+int mwl_fwcmd_set_rate_drop(struct ieee80211_hw *hw, int enable,
+			    int value, int staid)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_set_rate_drop *pcmd;
+
+	pcmd = (struct hostcmd_cmd_set_rate_drop *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_SET_RATE_DROP);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->enable = cpu_to_le32(enable);
+	pcmd->rate_index = cpu_to_le32(value);
+	pcmd->sta_index = cpu_to_le32(staid);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_SET_RATE_DROP)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_newdp_dmathread_start(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_newdp_dmathread_start *pcmd;
+	u16 cmd;
+
+	pcmd = (struct hostcmd_cmd_newdp_dmathread_start *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	cmd = HOSTCMD_CMD_NEWDP_DMATHREAD_START;
+	pcmd->cmd_hdr.cmd = cpu_to_le16(cmd);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+	if (mwl_hif_exec_cmd(hw, cmd)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+
+int mwl_fwcmd_get_fw_region_code_sc4(struct ieee80211_hw *hw,
+				     u32 *fw_region_code)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_get_fw_region_code_sc4 *pcmd;
+	u16 cmd;
+
+	pcmd = (struct hostcmd_cmd_get_fw_region_code_sc4 *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	cmd = HOSTCMD_CMD_GET_FW_REGION_CODE_SC4;
+	pcmd->cmd_hdr.cmd = cpu_to_le16(cmd);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+	if (mwl_hif_exec_cmd(hw, cmd)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	if (pcmd->cmd_hdr.result != 0) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EINVAL;
+	}
+
+	if (pcmd->status)
+		*fw_region_code = (pcmd->status == 1) ? 0 : pcmd->status;
+	else
+		*fw_region_code = le32_to_cpu(pcmd->fw_region_code);
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_get_pwr_tbl_sc4(struct ieee80211_hw *hw,
+			      struct mwl_device_pwr_tbl *device_ch_pwrtbl,
+			      u8 *region_code,
+			      u8 *number_of_channels,
+			      u32 channel_index)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_get_device_pwr_tbl_sc4 *pcmd;
+	int status;
+	u16 cmd;
+
+	pcmd = (struct hostcmd_cmd_get_device_pwr_tbl_sc4 *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	cmd = HOSTCMD_CMD_GET_DEVICE_PWR_TBL_SC4;
+	pcmd->cmd_hdr.cmd = cpu_to_le16(cmd);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->status = cpu_to_le16(cmd);
+	pcmd->current_channel_index = cpu_to_le32(channel_index);
+
+	if (mwl_hif_exec_cmd(hw, cmd)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	device_ch_pwrtbl->channel = pcmd->channel_pwr_tbl.channel;
+	memcpy(device_ch_pwrtbl->tx_pwr, pcmd->channel_pwr_tbl.tx_pwr,
+	       SYSADPT_TX_PWR_LEVEL_TOTAL_SC4);
+	device_ch_pwrtbl->dfs_capable = pcmd->channel_pwr_tbl.dfs_capable;
+	device_ch_pwrtbl->ax_ant = pcmd->channel_pwr_tbl.ax_ant;
+	device_ch_pwrtbl->cdd = pcmd->channel_pwr_tbl.cdd;
+	*region_code = pcmd->region_code;
+	*number_of_channels = pcmd->number_of_channels;
+	status = le16_to_cpu(pcmd->status);
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return status;
+}
+
+int mwl_fwcmd_quiet_mode(struct ieee80211_hw *hw, bool enable, u32 period,
+			 u32 duration, u32 next_offset)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_quiet_mode *pcmd;
+
+	pcmd = (struct hostcmd_cmd_quiet_mode *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_QUIET_MODE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action = cpu_to_le16(WL_SET);
+	pcmd->enable = cpu_to_le32(enable);
+	if (enable) {
+		pcmd->period = cpu_to_le32(period);
+		pcmd->duration = cpu_to_le32(duration);
+		pcmd->next_offset = cpu_to_le32(next_offset);
+	}
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_QUIET_MODE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_core_dump_diag_mode(struct ieee80211_hw *hw, u16 status)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_core_dump_diag_mode *pcmd;
+
+	pcmd = (struct hostcmd_cmd_core_dump_diag_mode *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_CORE_DUMP_DIAG_MODE);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->status = cpu_to_le16(status);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_CORE_DUMP_DIAG_MODE)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_get_fw_core_dump(struct ieee80211_hw *hw,
+			       struct coredump_cmd *core_dump, char *buff)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_get_fw_core_dump *pcmd;
+
+	if (priv->chip_type != MWL8964)
+		return -EPERM;
+
+	pcmd = (struct hostcmd_cmd_get_fw_core_dump *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_GET_FW_CORE_DUMP);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->cmd_data.coredump.context = core_dump->context;
+	pcmd->cmd_data.coredump.buffer = cpu_to_le32(priv->pphys_cmd_buf +
+		sizeof(struct hostcmd_cmd_get_fw_core_dump) -
+		sizeof(struct hostcmd_cmd_get_fw_core_dump_));
+	pcmd->cmd_data.coredump.buffer_len = cpu_to_le32(MAX_CORE_DUMP_BUFFER);
+	pcmd->cmd_data.coredump.size_kb = core_dump->size_kb;
+	pcmd->cmd_data.coredump.flags = core_dump->flags;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_GET_FW_CORE_DUMP)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	/* update core dump buffer */
+	core_dump->context = pcmd->cmd_data.coredump.context;
+	core_dump->size_kb = pcmd->cmd_data.coredump.size_kb;
+	core_dump->flags = pcmd->cmd_data.coredump.flags;
+	memcpy(buff,
+	       (const void *)((u32)pcmd +
+	       sizeof(struct hostcmd_cmd_get_fw_core_dump) -
+	       sizeof(struct hostcmd_cmd_get_fw_core_dump_)),
+	       MAX_CORE_DUMP_BUFFER);
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_slot_time(struct ieee80211_hw *hw, bool short_slot)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_802_11_slot_time *pcmd;
+
+	wiphy_debug(priv->hw->wiphy, "%s(): short_slot_time=%d\n",
+		    __func__, short_slot);
+
+	pcmd = (struct hostcmd_cmd_802_11_slot_time *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_802_11_SLOT_TIME);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action = cpu_to_le16(WL_SET);
+	pcmd->short_slot = cpu_to_le16(short_slot ? 1 : 0);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_802_11_SLOT_TIME)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_config_EDMACCtrl(struct ieee80211_hw *hw, int EDMAC_Ctrl)
+{
+	struct hostcmd_cmd_edmac_ctrl *pcmd;
+	struct mwl_priv *priv = hw->priv;
+
+	pcmd = (struct hostcmd_cmd_edmac_ctrl *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_EDMAC_CTRL);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->action = cpu_to_le16(WL_SET);
+	pcmd->ed_ctrl_2g = cpu_to_le16((EDMAC_Ctrl & EDMAC_2G_ENABLE_MASK)
+				       >> EDMAC_2G_ENABLE_SHIFT);
+	pcmd->ed_ctrl_5g = cpu_to_le16((EDMAC_Ctrl & EDMAC_5G_ENABLE_MASK)
+				       >> EDMAC_5G_ENABLE_SHIFT);
+	pcmd->ed_offset_2g = cpu_to_le16((EDMAC_Ctrl &
+					 EDMAC_2G_THRESHOLD_OFFSET_MASK)
+					 >> EDMAC_2G_THRESHOLD_OFFSET_SHIFT);
+	pcmd->ed_offset_5g = cpu_to_le16((EDMAC_Ctrl &
+					 EDMAC_5G_THRESHOLD_OFFSET_MASK)
+					 >> EDMAC_5G_THRESHOLD_OFFSET_SHIFT);
+	pcmd->ed_bitmap_txq_lock = cpu_to_le16((EDMAC_Ctrl &
+					       EDMAC_QLOCK_BITMAP_MASK)
+					       >> EDMAC_QLOCK_BITMAP_SHIFT);
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_EDMAC_CTRL)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+int mwl_fwcmd_set_txpwrlmt_cfg_data(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_txpwrlmt_cfg *pcmd;
+	struct mwl_txpwrlmt_cfg_entry_hdr hdr;
+	u16 id, parsed_len, size;
+	__le32 txpwr_cfg_sig;
+	u8 version[TXPWRLMT_CFG_VERSION_INFO_LEN];
+	const u8 *ptr;
+
+	if (!priv->txpwrlmt_file)
+		return 0;
+
+	ptr = priv->txpwrlmt_file->data;
+	size = priv->txpwrlmt_file->size;
+
+	/* Parsing TxPwrLmit Conf file Signature */
+	parsed_len = mwl_fwcmd_parse_txpwrlmt_cfg(ptr, size,
+						  TXPWRLMT_CFG_SIG_LEN,
+						  (u8 *)&txpwr_cfg_sig);
+	ptr += parsed_len;
+	size -= parsed_len;
+
+	if (le32_to_cpu(txpwr_cfg_sig) != TXPWRLMT_CFG_SIGNATURE) {
+		wiphy_err(hw->wiphy,
+			  "txpwrlmt config signature mismatch\n");
+		release_firmware(priv->txpwrlmt_file);
+		priv->txpwrlmt_file = NULL;
+		return 0;
+	}
+
+	/* Parsing TxPwrLmit Conf file Version */
+	parsed_len = mwl_fwcmd_parse_txpwrlmt_cfg(ptr, size,
+						  TXPWRLMT_CFG_VERSION_INFO_LEN,
+						  version);
+	ptr += parsed_len;
+	size -= parsed_len;
+
+	for (id = 0; id < TXPWRLMT_CFG_MAX_SUBBAND_INFO; id++) {
+		u16 data_len;
+
+		/*Parsing tx pwr cfg subband header info*/
+		parsed_len = sizeof(struct mwl_txpwrlmt_cfg_entry_hdr);
+		parsed_len = mwl_fwcmd_parse_txpwrlmt_cfg(ptr, size,
+							  parsed_len,
+							  (u8 *)&hdr);
+		ptr += parsed_len;
+		size -= parsed_len;
+		data_len = le16_to_cpu(hdr.len) -
+			sizeof(struct mwl_txpwrlmt_cfg_entry_hdr);
+
+		pcmd = (struct hostcmd_cmd_txpwrlmt_cfg *)&priv->pcmd_buf[0];
+
+		mutex_lock(&priv->fwcmd_mutex);
+
+		memset(pcmd, 0x00, sizeof(*pcmd));
+		pcmd->action = cpu_to_le16(HOSTCMD_ACT_GEN_SET);
+		pcmd->subband_id = hdr.id;
+		pcmd->data_len = cpu_to_le16(data_len);
+		pcmd->num_entries = hdr.num_entries;
+
+		/* Parsing tx pwr cfg subband header info */
+		parsed_len = mwl_fwcmd_parse_txpwrlmt_cfg(ptr, size,
+							  data_len, pcmd->data);
+		ptr += parsed_len;
+		size -= parsed_len;
+
+		pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_TXPWRLMT_CFG);
+		pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd) +
+			data_len - sizeof(pcmd->data));
+
+		if (size < sizeof(struct mwl_txpwrlmt_cfg_entry_hdr))
+			pcmd->cfgComplete = 1;
+
+		if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_TXPWRLMT_CFG)) {
+			mutex_unlock(&priv->fwcmd_mutex);
+			release_firmware(priv->txpwrlmt_file);
+			priv->txpwrlmt_file = NULL;
+			return -EIO;
+		}
+
+		mutex_unlock(&priv->fwcmd_mutex);
+	}
+
+	release_firmware(priv->txpwrlmt_file);
+	priv->txpwrlmt_file = NULL;
+
+	return 0;
+}
+
+int mwl_fwcmd_get_txpwrlmt_cfg_data(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_txpwrlmt_cfg *pcmd;
+	u16 subband_len, total_len = 0;
+	u8 id;
+
+	for (id = 0; id < TXPWRLMT_CFG_MAX_SUBBAND_INFO; id++) {
+		pcmd = (struct hostcmd_cmd_txpwrlmt_cfg *)&priv->pcmd_buf[0];
+
+		mutex_lock(&priv->fwcmd_mutex);
+
+		memset(pcmd, 0x00, sizeof(*pcmd));
+		pcmd->action = 0;
+		pcmd->subband_id = id;
+		pcmd->data_len = 0;
+		pcmd->num_entries = 0;
+
+		pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_TXPWRLMT_CFG);
+		pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+
+		if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_TXPWRLMT_CFG)) {
+			mutex_unlock(&priv->fwcmd_mutex);
+			return -EIO;
+		}
+
+		mutex_unlock(&priv->fwcmd_mutex);
+
+		subband_len = le16_to_cpu(pcmd->cmd_hdr.len) -
+			sizeof(struct hostcmd_header) - 2;
+		if (total_len <= SYSADPT_TXPWRLMT_CFG_BUF_SIZE) {
+			wiphy_debug(hw->wiphy, "Subband len = %d\n",
+				    subband_len);
+			memcpy(priv->txpwrlmt_data.buf + total_len,
+			       &pcmd->subband_id, subband_len);
+			total_len += subband_len;
+			priv->txpwrlmt_data.buf[total_len] = '\n';
+			total_len++;
+			priv->txpwrlmt_data.len = total_len;
+		} else {
+			wiphy_err(hw->wiphy,
+				  "TxPwrLmt cfg buf size is not enough\n");
+		}
+	}
+
+	return 0;
+}
+
+int mwl_fwcmd_mcast_cts(struct ieee80211_hw *hw, u8 enable)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct hostcmd_cmd_mcast_cts *pcmd;
+
+	pcmd = (struct hostcmd_cmd_mcast_cts *)&priv->pcmd_buf[0];
+
+	mutex_lock(&priv->fwcmd_mutex);
+
+	memset(pcmd, 0x00, sizeof(*pcmd));
+	pcmd->cmd_hdr.cmd = cpu_to_le16(HOSTCMD_CMD_MCAST_CTS);
+	pcmd->cmd_hdr.len = cpu_to_le16(sizeof(*pcmd));
+	pcmd->enable = enable;
+
+	if (mwl_hif_exec_cmd(hw, HOSTCMD_CMD_MCAST_CTS)) {
+		mutex_unlock(&priv->fwcmd_mutex);
+		return -EIO;
+	}
+
+	mutex_unlock(&priv->fwcmd_mutex);
+
+	return 0;
+}
+
+void mwl_fwcmd_get_survey(struct ieee80211_hw *hw, int idx)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct ieee80211_conf *conf = &hw->conf;
+	struct mwl_survey_info *survey_info;
+
+	if (idx)
+		survey_info = &priv->survey_info[idx - 1];
+	else
+		survey_info = &priv->cur_survey_info;
+
+	memcpy(&survey_info->channel, conf->chandef.chan,
+	       sizeof(struct ieee80211_channel));
+	mwl_hif_get_survey(hw, survey_info);
+}
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/fwcmd.h b/drivers/net/wireless/marvell/mwlwifi/hif/fwcmd.h
new file mode 100644
index 000000000000..9565cc447dc6
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/fwcmd.h
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines firmware host command related
+ * functions.
+ */
+
+#ifndef _FWCMD_H_
+#define _FWCMD_H_
+
+#include "hif/hostcmd.h"
+
+/*  Define OpMode for SoftAP/Station mode
+ *
+ *  The following mode signature has to be written to PCI scratch register#0
+ *  right after successfully downloading the last block of firmware and
+ *  before waiting for firmware ready signature
+ */
+
+#define HOSTCMD_STA_MODE                0x5A
+#define HOSTCMD_SOFTAP_MODE             0xA5
+
+#define HOSTCMD_STA_FWRDY_SIGNATURE     0xF0F1F2F4
+#define HOSTCMD_SOFTAP_FWRDY_SIGNATURE  0xF1F2F4A5
+
+#define GUARD_INTERVAL_STANDARD         1
+#define GUARD_INTERVAL_SHORT            2
+#define GUARD_INTERVAL_AUTO             3
+
+#define	LINK_CS_STATE_CONSERV           0
+#define	LINK_CS_STATE_AGGR              1
+#define	LINK_CS_STATE_AUTO              2
+#define	LINK_CS_STATE_AUTO_DISABLED     3
+
+#define STOP_DETECT_RADAR               0
+#define CAC_START                       1
+#define MONITOR_START                   3
+
+#define WDS_MODE                        4
+
+enum {
+	WL_ANTENNATYPE_RX = 1,
+	WL_ANTENNATYPE_TX = 2,
+};
+
+enum encr_type {
+	ENCR_TYPE_WEP = 0,
+	ENCR_TYPE_DISABLE = 1,
+	ENCR_TYPE_TKIP = 4,
+	ENCR_TYPE_AES = 6,
+	ENCR_TYPE_MIX = 7,
+};
+
+char *mwl_fwcmd_get_cmd_string(unsigned short cmd);
+
+const struct hostcmd_get_hw_spec
+*mwl_fwcmd_get_hw_specs(struct ieee80211_hw *hw);
+
+int mwl_fwcmd_set_hw_specs(struct ieee80211_hw *hw,
+			   struct hostcmd_set_hw_spec *spec);
+
+int mwl_fwcmd_get_stat(struct ieee80211_hw *hw,
+		       struct ieee80211_low_level_stats *stats);
+
+int mwl_fwcmd_reg_bb(struct ieee80211_hw *hw, u8 flag, u32 reg, u32 *val);
+
+int mwl_fwcmd_reg_rf(struct ieee80211_hw *hw, u8 flag, u32 reg, u32 *val);
+
+int mwl_fwcmd_radio_enable(struct ieee80211_hw *hw);
+
+int mwl_fwcmd_radio_disable(struct ieee80211_hw *hw);
+
+int mwl_fwcmd_set_radio_preamble(struct ieee80211_hw *hw,
+				 bool short_preamble);
+
+int mwl_fwcmd_get_addr_value(struct ieee80211_hw *hw, u32 addr, u32 len,
+			     u32 *val, u16 set);
+
+int mwl_fwcmd_max_tx_power(struct ieee80211_hw *hw,
+			   struct ieee80211_conf *conf, u8 fraction);
+
+int mwl_fwcmd_tx_power(struct ieee80211_hw *hw,
+		       struct ieee80211_conf *conf, u8 fraction);
+
+int mwl_fwcmd_rf_antenna(struct ieee80211_hw *hw, int dir, int antenna);
+
+int mwl_fwcmd_broadcast_ssid_enable(struct ieee80211_hw *hw,
+				    struct ieee80211_vif *vif, bool enable);
+
+int mwl_fwcmd_set_cfg_data(struct ieee80211_hw *hw, u16 type);
+
+int mwl_fwcmd_set_rf_channel(struct ieee80211_hw *hw,
+			     struct ieee80211_conf *conf);
+
+int mwl_fwcmd_set_aid(struct ieee80211_hw *hw,
+		      struct ieee80211_vif *vif, u8 *bssid, u16 aid);
+
+int mwl_fwcmd_set_infra_mode(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif);
+
+int mwl_fwcmd_set_rts_threshold(struct ieee80211_hw *hw,
+				int threshold);
+
+int mwl_fwcmd_set_edca_params(struct ieee80211_hw *hw, u8 index,
+			      u16 cw_min, u16 cw_max, u8 aifs, u16 txop);
+
+int mwl_fwcmd_set_radar_detect(struct ieee80211_hw *hw, u16 action);
+
+int mwl_fwcmd_set_wmm_mode(struct ieee80211_hw *hw, bool enable);
+
+int mwl_fwcmd_ht_guard_interval(struct ieee80211_hw *hw, u32 gi_type);
+
+int mwl_fwcmd_use_fixed_rate(struct ieee80211_hw *hw,
+			     int mcast, int mgmt);
+
+int mwl_fwcmd_set_linkadapt_cs_mode(struct ieee80211_hw *hw,
+				    u16 cs_mode);
+
+int mwl_fwcmd_dump_otp_data(struct ieee80211_hw *hw);
+
+int mwl_fwcmd_set_rate_adapt_mode(struct ieee80211_hw *hw,
+				  u16 mode);
+
+int mwl_fwcmd_set_mac_addr_client(struct ieee80211_hw *hw,
+				  struct ieee80211_vif *vif, u8 *mac_addr);
+
+int mwl_fwcmd_get_watchdog_bitmap(struct ieee80211_hw *hw,
+				  u8 *bitmap);
+
+int mwl_fwcmd_remove_mac_addr(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif, u8 *mac_addr);
+
+int mwl_fwcmd_bss_start(struct ieee80211_hw *hw,
+			struct ieee80211_vif *vif, bool enable);
+
+int mwl_fwcmd_set_beacon(struct ieee80211_hw *hw,
+			 struct ieee80211_vif *vif, u8 *beacon, int len);
+
+int mwl_fwcmd_set_new_stn_add(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif,
+			      struct ieee80211_sta *sta);
+
+int mwl_fwcmd_set_new_stn_add_sc4(struct ieee80211_hw *hw,
+				  struct ieee80211_vif *vif,
+				  struct ieee80211_sta *sta,
+				  u32 wds);
+
+int mwl_fwcmd_set_new_stn_wds_sc4(struct ieee80211_hw *hw, u8 *addr);
+
+int mwl_fwcmd_set_new_stn_add_self(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif);
+
+int mwl_fwcmd_set_new_stn_del(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif, u8 *addr);
+
+int mwl_fwcmd_set_apmode(struct ieee80211_hw *hw, u8 apmode);
+
+int mwl_fwcmd_set_switch_channel(struct ieee80211_hw *hw,
+				 struct ieee80211_channel_switch *ch_switch);
+
+int mwl_fwcmd_update_encryption_enable(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       u8 *addr, u8 encr_type);
+
+int mwl_fwcmd_encryption_set_key(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif, u8 *addr,
+				 struct ieee80211_key_conf *key);
+
+int mwl_fwcmd_encryption_remove_key(struct ieee80211_hw *hw,
+				    struct ieee80211_vif *vif, u8 *addr,
+				    struct ieee80211_key_conf *key);
+
+int mwl_fwcmd_check_ba(struct ieee80211_hw *hw,
+		       struct mwl_ampdu_stream *stream,
+		       struct ieee80211_vif *vif,
+		       u32 direction);
+
+int mwl_fwcmd_create_ba(struct ieee80211_hw *hw,
+			struct mwl_ampdu_stream *stream,
+			struct ieee80211_vif *vif,
+			u32 direction, u8 buf_size, u16 seqno, bool amsdu);
+
+int mwl_fwcmd_destroy_ba(struct ieee80211_hw *hw,
+			 struct mwl_ampdu_stream *stream,
+			 u32 direction);
+
+struct mwl_ampdu_stream *mwl_fwcmd_add_stream(struct ieee80211_hw *hw,
+					      struct ieee80211_sta *sta,
+					      u8 tid);
+
+void mwl_fwcmd_del_sta_streams(struct ieee80211_hw *hw,
+			       struct ieee80211_sta *sta);
+
+int mwl_fwcmd_start_stream(struct ieee80211_hw *hw,
+			   struct mwl_ampdu_stream *stream);
+
+void mwl_fwcmd_remove_stream(struct ieee80211_hw *hw,
+			     struct mwl_ampdu_stream *stream);
+
+struct mwl_ampdu_stream *mwl_fwcmd_lookup_stream(struct ieee80211_hw *hw,
+						 struct ieee80211_sta *sta,
+						 u8 tid);
+
+bool mwl_fwcmd_ampdu_allowed(struct ieee80211_sta *sta, u8 tid);
+
+int mwl_fwcmd_set_optimization_level(struct ieee80211_hw *hw, u8 opt_level);
+
+int mwl_fwcmd_set_wsc_ie(struct ieee80211_hw *hw, u8 len, u8 *data);
+
+int mwl_fwcmd_get_ratetable(struct ieee80211_hw *hw, u8 *addr, u8 *rate_table,
+			    u32 size, u8 type);
+
+int mwl_fwcmd_get_seqno(struct ieee80211_hw *hw,
+			struct mwl_ampdu_stream *stream, u16 *start_seqno);
+
+int mwl_fwcmd_set_dwds_stamode(struct ieee80211_hw *hw, bool enable);
+
+int mwl_fwcmd_set_fw_flush_timer(struct ieee80211_hw *hw, u32 value);
+
+int mwl_fwcmd_set_cdd(struct ieee80211_hw *hw);
+
+int mwl_fwcmd_set_bftype(struct ieee80211_hw *hw, int mode);
+
+int mwl_fwcmd_reg_cau(struct ieee80211_hw *hw, u8 flag, u32 reg, u32 *val);
+
+int mwl_fwcmd_get_temp(struct ieee80211_hw *hw, u32 *temp);
+
+int mwl_fwcmd_led_ctrl(struct ieee80211_hw *hw, u8 enable, u8 rate);
+
+int mwl_fwcmd_get_fw_region_code(struct ieee80211_hw *hw,
+				 u32 *fw_region_code);
+
+int mwl_fwcmd_get_device_pwr_tbl(struct ieee80211_hw *hw,
+				 struct mwl_device_pwr_tbl *device_ch_pwrtbl,
+				 u8 *region_code,
+				 u8 *number_of_channels,
+				 u32 channel_index);
+
+int mwl_fwcmd_set_rate_drop(struct ieee80211_hw *hw, int enable,
+			    int value, int staid);
+
+int mwl_fwcmd_newdp_dmathread_start(struct ieee80211_hw *hw);
+
+int mwl_fwcmd_get_fw_region_code_sc4(struct ieee80211_hw *hw,
+				     u32 *fw_region_code);
+
+int mwl_fwcmd_get_pwr_tbl_sc4(struct ieee80211_hw *hw,
+			      struct mwl_device_pwr_tbl *device_ch_pwrtbl,
+			      u8 *region_code,
+			      u8 *number_of_channels,
+			      u32 channel_index);
+
+int mwl_fwcmd_quiet_mode(struct ieee80211_hw *hw, bool enable, u32 period,
+			 u32 duration, u32 next_offset);
+
+int mwl_fwcmd_core_dump_diag_mode(struct ieee80211_hw *hw, u16 status);
+
+int mwl_fwcmd_get_fw_core_dump(struct ieee80211_hw *hw,
+			       struct coredump_cmd *core_dump, char *buff);
+
+int mwl_fwcmd_set_slot_time(struct ieee80211_hw *hw, bool short_slot);
+
+int mwl_fwcmd_config_EDMACCtrl(struct ieee80211_hw *hw, int EDMAC_Ctrl);
+
+int mwl_fwcmd_set_txpwrlmt_cfg_data(struct ieee80211_hw *hw);
+
+int mwl_fwcmd_get_txpwrlmt_cfg_data(struct ieee80211_hw *hw);
+
+int mwl_fwcmd_mcast_cts(struct ieee80211_hw *hw, u8 enable);
+
+void mwl_fwcmd_get_survey(struct ieee80211_hw *hw, int idx);
+
+#endif /* _FWCMD_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/hif-ops.h b/drivers/net/wireless/marvell/mwlwifi/hif/hif-ops.h
new file mode 100644
index 000000000000..f5c7144b3c1b
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/hif-ops.h
@@ -0,0 +1,297 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines host interface related operations. */
+
+#ifndef _HIF_OPS_H_
+#define _HIF_OPS_H_
+static inline const char *mwl_hif_get_driver_name(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	return priv->hif.ops->driver_name;
+}
+
+static inline const char *mwl_hif_get_driver_version(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	return priv->hif.ops->driver_version;
+}
+
+static inline unsigned int mwl_hif_get_tx_head_room(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	return priv->hif.ops->tx_head_room;
+}
+
+static inline unsigned int mwl_hif_get_ampdu_num(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	return priv->hif.ops->ampdu_num;
+}
+
+static inline void mwl_hif_reset(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->reset)
+		priv->hif.ops->reset(hw);
+}
+
+static inline int mwl_hif_init(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->init)
+		return priv->hif.ops->init(hw);
+	else
+		return -ENOTSUPP;
+}
+
+static inline void mwl_hif_deinit(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->deinit)
+		priv->hif.ops->deinit(hw);
+}
+
+static inline int mwl_hif_get_info(struct ieee80211_hw *hw,
+				   char *buf, size_t size)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->get_info)
+		return priv->hif.ops->get_info(hw, buf, size);
+	else
+		return 0;
+}
+
+static inline int mwl_hif_get_tx_status(struct ieee80211_hw *hw,
+					char *buf, size_t size)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->get_tx_status)
+		return priv->hif.ops->get_tx_status(hw, buf, size);
+	else
+		return 0;
+}
+
+static inline int mwl_hif_get_rx_status(struct ieee80211_hw *hw,
+					char *buf, size_t size)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->get_rx_status)
+		return priv->hif.ops->get_rx_status(hw, buf, size);
+	else
+		return 0;
+}
+
+static inline void mwl_hif_enable_data_tasks(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->enable_data_tasks)
+		priv->hif.ops->enable_data_tasks(hw);
+}
+
+static inline void mwl_hif_disable_data_tasks(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->disable_data_tasks)
+		priv->hif.ops->disable_data_tasks(hw);
+}
+
+static inline int mwl_hif_exec_cmd(struct ieee80211_hw *hw, unsigned short cmd)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->exec_cmd)
+		return priv->hif.ops->exec_cmd(hw, cmd);
+	else
+		return -ENOTSUPP;
+}
+
+static inline int mwl_hif_get_irq_num(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->get_irq_num)
+		return priv->hif.ops->get_irq_num(hw);
+	else
+		return -ENOTSUPP;
+}
+
+static inline irqreturn_t mwl_hif_irq_handler(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->irq_handler)
+		return priv->hif.ops->irq_handler(hw);
+	else
+		return -ENOTSUPP;
+}
+
+static inline void mwl_hif_irq_enable(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->irq_enable)
+		priv->hif.ops->irq_enable(hw);
+}
+
+static inline void mwl_hif_irq_disable(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->irq_disable)
+		priv->hif.ops->irq_disable(hw);
+}
+
+static inline int mwl_hif_download_firmware(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->download_firmware)
+		return priv->hif.ops->download_firmware(hw);
+	else
+		return -ENOTSUPP;
+}
+
+static inline void mwl_hif_timer_routine(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->timer_routine)
+		priv->hif.ops->timer_routine(hw);
+}
+
+static inline void mwl_hif_tx_xmit(struct ieee80211_hw *hw,
+				   struct ieee80211_tx_control *control,
+				   struct sk_buff *skb)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->tx_xmit)
+		priv->hif.ops->tx_xmit(hw, control, skb);
+}
+
+static inline void mwl_hif_tx_del_pkts_via_vif(struct ieee80211_hw *hw,
+					       struct ieee80211_vif *vif)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->tx_del_pkts_via_vif)
+		priv->hif.ops->tx_del_pkts_via_vif(hw, vif);
+}
+
+static inline void mwl_hif_tx_del_pkts_via_sta(struct ieee80211_hw *hw,
+					       struct ieee80211_sta *sta)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->tx_del_pkts_via_sta)
+		priv->hif.ops->tx_del_pkts_via_sta(hw, sta);
+}
+
+static inline void mwl_hif_tx_del_ampdu_pkts(struct ieee80211_hw *hw,
+					     struct ieee80211_sta *sta, u8 tid)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->tx_del_ampdu_pkts)
+		priv->hif.ops->tx_del_ampdu_pkts(hw, sta, tid);
+}
+
+static inline void mwl_hif_tx_del_sta_amsdu_pkts(struct ieee80211_hw *hw,
+						 struct ieee80211_sta *sta)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->tx_del_sta_amsdu_pkts)
+		priv->hif.ops->tx_del_sta_amsdu_pkts(hw, sta);
+}
+
+static inline void mwl_hif_tx_return_pkts(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->tx_return_pkts)
+		priv->hif.ops->tx_return_pkts(hw);
+}
+
+static inline struct device_node *mwl_hif_device_node(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->get_device_node)
+		return priv->hif.ops->get_device_node(hw);
+	else
+		return NULL;
+}
+
+static inline void mwl_hif_get_survey(struct ieee80211_hw *hw,
+				      struct mwl_survey_info *survey_info)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->get_survey)
+		priv->hif.ops->get_survey(hw, survey_info);
+}
+
+static inline int mwl_hif_reg_access(struct ieee80211_hw *hw, bool write)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->reg_access)
+		return priv->hif.ops->reg_access(hw, write);
+	else
+		return -ENOTSUPP;
+}
+
+static inline void mwl_hif_set_sta_id(struct ieee80211_hw *hw,
+				      struct ieee80211_sta *sta,
+				      bool sta_mode, bool set)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->set_sta_id)
+		priv->hif.ops->set_sta_id(hw, sta, sta_mode, set);
+}
+
+static inline void mwl_hif_process_account(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->process_account)
+		priv->hif.ops->process_account(hw);
+}
+
+static inline int mwl_hif_mcast_cts(struct ieee80211_hw *hw, bool enable)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->hif.ops->mcast_cts)
+		return priv->hif.ops->mcast_cts(hw, enable);
+	else
+		return -ENOTSUPP;
+}
+#endif /* _HIF_OPS_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/hif.h b/drivers/net/wireless/marvell/mwlwifi/hif/hif.h
new file mode 100644
index 000000000000..6ea6192ac5e0
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/hif.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines host interface data structure. */
+
+#ifndef _HIF_H_
+#define _HIF_H_
+
+/* memory/register access */
+#define MWL_ACCESS_MAC        1
+#define MWL_ACCESS_RF         2
+#define MWL_ACCESS_BBP        3
+#define MWL_ACCESS_CAU        4
+#define MWL_ACCESS_ADDR0      5
+#define MWL_ACCESS_ADDR1      6
+#define MWL_ACCESS_ADDR       7
+
+struct mwl_survey_info {
+	struct ieee80211_channel channel;
+	u32 filled;
+	u32 time_period;
+	u32 time_busy;
+	u32 time_tx;
+	s8 noise;
+};
+
+struct mwl_hif_ops {
+	const char *driver_name;
+	const char *driver_version;
+	unsigned int tx_head_room;
+	int ampdu_num;
+	void (*reset)(struct ieee80211_hw *hw);
+	int (*init)(struct ieee80211_hw *hw);
+	void (*deinit)(struct ieee80211_hw *hw);
+	int (*get_info)(struct ieee80211_hw *hw, char *buf, size_t size);
+	int (*get_tx_status)(struct ieee80211_hw *hw, char *buf, size_t size);
+	int (*get_rx_status)(struct ieee80211_hw *hw, char *buf, size_t size);
+	void (*enable_data_tasks)(struct ieee80211_hw *hw);
+	void (*disable_data_tasks)(struct ieee80211_hw *hw);
+	int (*exec_cmd)(struct ieee80211_hw *hw, unsigned short cmd);
+	int (*get_irq_num)(struct ieee80211_hw *hw);
+	irqreturn_t (*irq_handler)(struct ieee80211_hw *hw);
+	void (*irq_enable)(struct ieee80211_hw *hw);
+	void (*irq_disable)(struct ieee80211_hw *hw);
+	int (*download_firmware)(struct ieee80211_hw *hw);
+	void (*timer_routine)(struct ieee80211_hw *hw);
+	void (*tx_xmit)(struct ieee80211_hw *hw,
+			struct ieee80211_tx_control *control,
+			struct sk_buff *skb);
+	void (*tx_del_pkts_via_vif)(struct ieee80211_hw *hw,
+				    struct ieee80211_vif *vif);
+	void (*tx_del_pkts_via_sta)(struct ieee80211_hw *hw,
+				    struct ieee80211_sta *sta);
+	void (*tx_del_ampdu_pkts)(struct ieee80211_hw *hw,
+				  struct ieee80211_sta *sta, u8 tid);
+	void (*tx_del_sta_amsdu_pkts)(struct ieee80211_hw *hw,
+				      struct ieee80211_sta *sta);
+	void (*tx_return_pkts)(struct ieee80211_hw *hw);
+	struct device_node *(*get_device_node)(struct ieee80211_hw *hw);
+	void (*get_survey)(struct ieee80211_hw *hw,
+			   struct mwl_survey_info *survey_info);
+	int (*reg_access)(struct ieee80211_hw *hw, bool write);
+	void (*set_sta_id)(struct ieee80211_hw *hw,
+			   struct ieee80211_sta *sta,
+			   bool sta_mode, bool set);
+	void (*process_account)(struct ieee80211_hw *hw);
+	int (*mcast_cts)(struct ieee80211_hw *hw, bool enable);
+};
+#endif /* _HIF_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/hostcmd.h b/drivers/net/wireless/marvell/mwlwifi/hif/hostcmd.h
new file mode 100644
index 000000000000..b14f161f1410
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/hostcmd.h
@@ -0,0 +1,1285 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines firmware host command related
+ * structure.
+ */
+
+#ifndef _HOSTCMD_H_
+#define _HOSTCMD_H_
+
+/* 16 bit host command code */
+#define HOSTCMD_CMD_GET_HW_SPEC                 0x0003
+#define HOSTCMD_CMD_SET_HW_SPEC                 0x0004
+#define HOSTCMD_CMD_802_11_GET_STAT             0x0014
+#define HOSTCMD_CMD_BBP_REG_ACCESS              0x001a
+#define HOSTCMD_CMD_RF_REG_ACCESS               0x001b
+#define HOSTCMD_CMD_802_11_RADIO_CONTROL        0x001c
+#define HOSTCMD_CMD_MEM_ADDR_ACCESS             0x001d
+#define HOSTCMD_CMD_802_11_TX_POWER             0x001f
+#define HOSTCMD_CMD_802_11_RF_ANTENNA           0x0020
+#define HOSTCMD_CMD_BROADCAST_SSID_ENABLE       0x0050 /* per-vif */
+#define HOSTCMD_CMD_SET_CFG                     0x008f
+#define HOSTCMD_CMD_SET_RF_CHANNEL              0x010a
+#define HOSTCMD_CMD_SET_AID                     0x010d /* per-vif */
+#define HOSTCMD_CMD_SET_INFRA_MODE              0x010e /* per-vif */
+#define HOSTCMD_CMD_802_11_RTS_THSD             0x0113
+#define HOSTCMD_CMD_SET_EDCA_PARAMS             0x0115
+#define HOSTCMD_CMD_802_11H_DETECT_RADAR        0x0120
+#define HOSTCMD_CMD_SET_WMM_MODE                0x0123
+#define HOSTCMD_CMD_HT_GUARD_INTERVAL           0x0124
+#define HOSTCMD_CMD_SET_FIXED_RATE              0x0126
+#define HOSTCMD_CMD_SET_IES                     0x0127
+#define HOSTCMD_CMD_SET_LINKADAPT_CS_MODE       0x0129
+#define HOSTCMD_CMD_DUMP_OTP_DATA               0x0142
+#define HOSTCMD_CMD_SET_MAC_ADDR                0x0202 /* per-vif */
+#define HOSTCMD_CMD_SET_RATE_ADAPT_MODE         0x0203
+#define HOSTCMD_CMD_GET_WATCHDOG_BITMAP         0x0205
+#define HOSTCMD_CMD_DEL_MAC_ADDR                0x0206 /* per-vif */
+#define HOSTCMD_CMD_BSS_START                   0x1100 /* per-vif */
+#define HOSTCMD_CMD_AP_BEACON                   0x1101 /* per-vif */
+#define HOSTCMD_CMD_SET_NEW_STN                 0x1111 /* per-vif */
+#define HOSTCMD_CMD_SET_APMODE                  0x1114
+#define HOSTCMD_CMD_SET_SWITCH_CHANNEL          0x1121
+#define HOSTCMD_CMD_UPDATE_ENCRYPTION           0x1122 /* per-vif */
+#define HOSTCMD_CMD_BASTREAM                    0x1125
+#define HOSTCMD_CMD_SET_SPECTRUM_MGMT           0x1128
+#define HOSTCMD_CMD_SET_POWER_CONSTRAINT        0x1129
+#define HOSTCMD_CMD_SET_COUNTRY_CODE            0x1130
+#define HOSTCMD_CMD_SET_OPTIMIZATION_LEVEL      0x1133
+#define HOSTCMD_CMD_SET_WSC_IE                  0x1136 /* per-vif */
+#define HOSTCMD_CMD_GET_RATETABLE               0x1137
+#define HOSTCMD_CMD_GET_SEQNO                   0x1143
+#define HOSTCMD_CMD_DWDS_ENABLE                 0x1144
+#define HOSTCMD_CMD_FW_FLUSH_TIMER              0x1148
+#define HOSTCMD_CMD_SET_CDD                     0x1150
+#define HOSTCMD_CMD_SET_BFTYPE                  0x1155
+#define HOSTCMD_CMD_CAU_REG_ACCESS              0x1157
+#define HOSTCMD_CMD_GET_TEMP                    0x1159
+#define HOSTCMD_CMD_LED_CTRL                    0x1169
+#define HOSTCMD_CMD_GET_FW_REGION_CODE          0x116A
+#define HOSTCMD_CMD_GET_DEVICE_PWR_TBL          0x116B
+#define HOSTCMD_CMD_SET_RATE_DROP               0x1172
+#define HOSTCMD_CMD_NEWDP_DMATHREAD_START       0x1189
+#define HOSTCMD_CMD_GET_FW_REGION_CODE_SC4      0x118A
+#define HOSTCMD_CMD_GET_DEVICE_PWR_TBL_SC4      0x118B
+#define HOSTCMD_CMD_QUIET_MODE                  0x1201
+#define HOSTCMD_CMD_CORE_DUMP_DIAG_MODE         0x1202
+#define HOSTCMD_CMD_802_11_SLOT_TIME            0x1203
+#define HOSTCMD_CMD_GET_FW_CORE_DUMP            0x1203
+#define HOSTCMD_CMD_EDMAC_CTRL                  0x1204
+#define HOSTCMD_CMD_TXPWRLMT_CFG                0x1211
+#define HOSTCMD_CMD_MCAST_CTS                   0x4001
+
+/* Define general result code for each command */
+#define HOSTCMD_RESULT_OK                       0x0000
+/* General error */
+#define HOSTCMD_RESULT_ERROR                    0x0001
+/* Command is not valid */
+#define HOSTCMD_RESULT_NOT_SUPPORT              0x0002
+/* Command is pending (will be processed) */
+#define HOSTCMD_RESULT_PENDING                  0x0003
+/* System is busy (command ignored) */
+#define HOSTCMD_RESULT_BUSY                     0x0004
+/* Data buffer is not big enough */
+#define HOSTCMD_RESULT_PARTIAL_DATA             0x0005
+
+/* Define channel related constants */
+#define FREQ_BAND_2DOT4GHZ                      0x1
+#define FREQ_BAND_4DOT9GHZ                      0x2
+#define FREQ_BAND_5GHZ                          0x4
+#define FREQ_BAND_5DOT2GHZ                      0x8
+#define CH_AUTO_WIDTH	                        0
+#define CH_10_MHZ_WIDTH                         0x1
+#define CH_20_MHZ_WIDTH                         0x2
+#define CH_40_MHZ_WIDTH                         0x4
+#define CH_80_MHZ_WIDTH                         0x5
+#define CH_160_MHZ_WIDTH                        0x6
+#define EXT_CH_ABOVE_CTRL_CH                    0x1
+#define EXT_CH_AUTO                             0x2
+#define EXT_CH_BELOW_CTRL_CH                    0x3
+#define NO_EXT_CHANNEL                          0x0
+
+#define ACT_PRIMARY_CHAN_0                      0
+#define ACT_PRIMARY_CHAN_1                      1
+#define ACT_PRIMARY_CHAN_2                      2
+#define ACT_PRIMARY_CHAN_3                      3
+#define ACT_PRIMARY_CHAN_4                      4
+#define ACT_PRIMARY_CHAN_5                      5
+#define ACT_PRIMARY_CHAN_6                      6
+#define ACT_PRIMARY_CHAN_7                      7
+
+/* Define rate related constants */
+#define HOSTCMD_ACT_NOT_USE_FIXED_RATE          0x0002
+
+/* Define station related constants */
+#define HOSTCMD_ACT_STA_ACTION_ADD              0
+#define HOSTCMD_ACT_STA_ACTION_MODIFY           1
+#define HOSTCMD_ACT_STA_ACTION_REMOVE           2
+
+/* Define key related constants */
+#define MAX_ENCR_KEY_LENGTH                     16
+#define MIC_KEY_LENGTH                          8
+
+#define KEY_TYPE_ID_WEP                         0x00
+#define KEY_TYPE_ID_TKIP                        0x01
+#define KEY_TYPE_ID_AES	                        0x02
+
+/* Group key for RX only */
+#define ENCR_KEY_FLAG_RXGROUPKEY                0x00000002
+#define ENCR_KEY_FLAG_TXGROUPKEY                0x00000004
+#define ENCR_KEY_FLAG_PAIRWISE                  0x00000008
+#define ENCR_KEY_FLAG_TSC_VALID                 0x00000040
+#define ENCR_KEY_FLAG_WEP_TXKEY                 0x01000000
+#define ENCR_KEY_FLAG_MICKEY_VALID              0x02000000
+
+/* Define block ack related constants */
+#define BA_FLAG_IMMEDIATE_TYPE                  1
+#define BA_FLAG_DIRECTION_UP                    0
+#define BA_FLAG_DIRECTION_DOWN                  1
+
+/* Define general purpose action */
+#define HOSTCMD_ACT_GEN_SET                     0x0001
+#define HOSTCMD_ACT_GEN_SET_LIST                0x0002
+#define HOSTCMD_ACT_GEN_GET_LIST                0x0003
+
+/* Define TXPower control action*/
+#define HOSTCMD_ACT_GET_TARGET_TX_PWR           0x0000
+#define HOSTCMD_ACT_GET_MAX_TX_PWR              0x0001
+#define HOSTCMD_ACT_SET_TARGET_TX_PWR           0x0002
+#define HOSTCMD_ACT_SET_MAX_TX_PWR              0x0003
+
+/* Misc */
+#define WSC_IE_MAX_LENGTH                       251
+#define WSC_IE_SET_BEACON                       0
+#define WSC_IE_SET_PROBE_RESPONSE               1
+
+#define HW_SET_PARMS_FEATURES_HOST_PROBE_RESP   0x00000020
+
+#define EDMAC_2G_ENABLE_MASK                    0x00000001
+#define EDMAC_2G_ENABLE_SHIFT                   0x0
+#define EDMAC_5G_ENABLE_MASK                    0x00000002
+#define EDMAC_5G_ENABLE_SHIFT                   0x1
+#define EDMAC_2G_THRESHOLD_OFFSET_MASK          0x00000FF0
+#define EDMAC_2G_THRESHOLD_OFFSET_SHIFT         0x4
+#define EDMAC_5G_THRESHOLD_OFFSET_MASK          0x000FF000
+#define EDMAC_5G_THRESHOLD_OFFSET_SHIFT         0xC
+#define EDMAC_QLOCK_BITMAP_MASK                 0x0FF00000
+#define EDMAC_QLOCK_BITMAP_SHIFT                0x14
+
+enum {
+	WL_DISABLE = 0,
+	WL_ENABLE = 1,
+	WL_DISABLE_VMAC = 0x80,
+};
+
+enum {
+	WL_GET = 0,
+	WL_SET = 1,
+	WL_RESET = 2,
+};
+
+enum {
+	WL_LONG_PREAMBLE = 1,
+	WL_SHORT_PREAMBLE = 3,
+	WL_AUTO_PREAMBLE = 5,
+};
+
+enum encr_action_type {
+	/* request to enable/disable HW encryption */
+	ENCR_ACTION_ENABLE_HW_ENCR,
+	/* request to set encryption key */
+	ENCR_ACTION_TYPE_SET_KEY,
+	/* request to remove one or more keys */
+	ENCR_ACTION_TYPE_REMOVE_KEY,
+	ENCR_ACTION_TYPE_SET_GROUP_KEY,
+};
+
+enum ba_action_type {
+	BA_CREATE_STREAM,
+	BA_UPDATE_STREAM,
+	BA_DESTROY_STREAM,
+	BA_FLUSH_STREAM,
+	BA_CHECK_STREAM,
+};
+
+enum mac_type {
+	WL_MAC_TYPE_PRIMARY_CLIENT,
+	WL_MAC_TYPE_SECONDARY_CLIENT,
+	WL_MAC_TYPE_PRIMARY_AP,
+	WL_MAC_TYPE_SECONDARY_AP,
+};
+
+/* General host command header */
+struct hostcmd_header {
+	__le16 cmd;
+	__le16 len;
+	u8 seq_num;
+	u8 macid;
+	__le16 result;
+} __packed;
+
+/* HOSTCMD_CMD_GET_HW_SPEC */
+struct hostcmd_get_hw_spec {
+	u8 version;                  /* version of the HW                    */
+	u8 host_if;                  /* host interface                       */
+	__le16 num_wcb;              /* Max. number of WCB FW can handle     */
+	__le16 num_mcast_addr;       /* MaxNbr of MC addresses FW can handle */
+	u8 permanent_addr[ETH_ALEN]; /* MAC address programmed in HW         */
+	__le16 region_code;
+	__le16 num_antenna;          /* Number of antenna used      */
+	__le32 fw_release_num;       /* 4 byte of FW release number */
+	__le32 wcb_base0;
+	__le32 rxpd_wr_ptr;
+	__le32 rxpd_rd_ptr;
+	__le32 fw_awake_cookie;
+	__le32 wcb_base[SYSADPT_TOTAL_TX_QUEUES - 1];
+} __packed;
+
+struct hostcmd_cmd_get_hw_spec {
+	struct hostcmd_header cmd_hdr;
+	struct hostcmd_get_hw_spec hw_spec;
+} __packed;
+
+/* HOSTCMD_CMD_SET_HW_SPEC */
+struct hostcmd_set_hw_spec {
+	/* HW revision */
+	u8 version;
+	/* Host interface */
+	u8 host_if;
+	/* Max. number of Multicast address FW can handle */
+	__le16 num_mcast_addr;
+	/* MAC address */
+	u8 permanent_addr[ETH_ALEN];
+	/* Region Code */
+	__le16 region_code;
+	/* 4 byte of FW release number, example 0x1234=1.2.3.4 */
+	__le32 fw_release_num;
+	/* Firmware awake cookie - used to ensure that the device
+	 * is not in sleep mode
+	 */
+	__le32 fw_awake_cookie;
+	/* Device capabilities (see above) */
+	__le32 device_caps;
+	/* Rx shared memory queue */
+	__le32 rxpd_wr_ptr;
+	/* Actual number of TX queues in WcbBase array */
+	__le32 num_tx_queues;
+	/* TX WCB Rings */
+	__le32 wcb_base[4 + SYSADPT_NUM_OF_AP];
+	/* Max AMSDU size (00 - AMSDU Disabled,
+	 * 01 - 4K, 10 - 8K, 11 - not defined)
+	 */
+	__le32 features;
+	__le32 tx_wcb_num_per_queue;
+	__le32 total_rx_wcb;
+	__le32 acnt_buf_size;
+	__le32 acnt_base_addr;
+} __packed;
+
+struct hostcmd_cmd_set_hw_spec {
+	struct hostcmd_header cmd_hdr;
+	struct hostcmd_set_hw_spec hw_spec;
+} __packed;
+
+/* HOSTCMD_CMD_802_11_GET_STAT */
+struct hostcmd_cmd_802_11_get_stat {
+	struct hostcmd_header cmd_hdr;
+	__le32 tx_retry_successes;
+	__le32 tx_multiple_retry_successes;
+	__le32 tx_failures;
+	__le32 rts_successes;
+	__le32 rts_failures;
+	__le32 ack_failures;
+	__le32 rx_duplicate_frames;
+	__le32 rx_fcs_errors;
+	__le32 tx_watchdog_timeouts;
+	__le32 rx_overflows;
+	__le32 rx_frag_errors;
+	__le32 rx_mem_errors;
+	__le32 pointer_errors;
+	__le32 tx_underflows;
+	__le32 tx_done;
+	__le32 tx_done_buf_try_put;
+	__le32 tx_done_buf_put;
+	/* Put size of requested buffer in here */
+	__le32 wait_for_tx_buf;
+	__le32 tx_attempts;
+	__le32 tx_successes;
+	__le32 tx_fragments;
+	__le32 tx_multicasts;
+	__le32 rx_non_ctl_pkts;
+	__le32 rx_multicasts;
+	__le32 rx_undecryptable_frames;
+	__le32 rx_icv_errors;
+	__le32 rx_excluded_frames;
+	__le32 rx_weak_iv_count;
+	__le32 rx_unicasts;
+	__le32 rx_bytes;
+	__le32 rx_errors;
+	__le32 rx_rts_count;
+	__le32 tx_cts_count;
+} __packed;
+
+/* HOSTCMD_CMD_BBP_REG_ACCESS */
+struct hostcmd_cmd_bbp_reg_access {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	__le16 offset;
+	u8 value;
+	u8 reserverd[3];
+} __packed;
+
+/* HOSTCMD_CMD_RF_REG_ACCESS */
+struct hostcmd_cmd_rf_reg_access {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	__le16 offset;
+	u8 value;
+	u8 reserverd[3];
+} __packed;
+
+/* HOSTCMD_CMD_802_11_RADIO_CONTROL */
+struct hostcmd_cmd_802_11_radio_control {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	/* @bit0: 1/0,on/off, @bit1: 1/0, long/short @bit2: 1/0,auto/fix */
+	__le16 control;
+	__le16 radio_on;
+} __packed;
+
+/* HOSTCMD_CMD_MEM_ADDR_ACCESS */
+struct hostcmd_cmd_mem_addr_access {
+	struct hostcmd_header cmd_hdr;
+	__le32 address;
+	__le16 length;
+	__le16 reserved;
+	__le32 value[64];
+} __packed;
+
+/* HOSTCMD_CMD_802_11_TX_POWER */
+struct hostcmd_cmd_802_11_tx_power {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	__le16 band;
+	__le16 ch;
+	__le16 bw;
+	__le16 sub_ch;
+	__le16 power_level_list[SYSADPT_TX_POWER_LEVEL_TOTAL];
+} __packed;
+
+struct hostcmd_cmd_802_11_tx_power_kf2 {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	__le16 band;
+	__le16 ch;
+	__le16 bw;
+	__le16 sub_ch;
+	__le16 power_level_list[SYSADPT_TX_GRP_PWR_LEVEL_TOTAL];
+} __packed;
+
+/* HOSTCMD_CMD_802_11_RF_ANTENNA */
+struct hostcmd_cmd_802_11_rf_antenna {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	__le16 antenna_mode;     /* Number of antennas or 0xffff(diversity) */
+} __packed;
+
+/* HOSTCMD_CMD_BROADCAST_SSID_ENABLE */
+struct hostcmd_cmd_broadcast_ssid_enable {
+	struct hostcmd_header cmd_hdr;
+	__le32 enable;
+	__le32 hidden_ssid_info;
+} __packed;
+
+/* HOSTCMD_CMD_SET_CFG */
+struct hostcmd_cmd_set_cfg {
+	struct hostcmd_header cmd_hdr;
+	/* Action */
+	__le16 action;
+	/* Type */
+	__le16 type;
+	/* Data length */
+	__le16 data_len;
+	/* Data */
+	u8 data[1];
+} __packed;
+
+/* HOSTCMD_CMD_SET_RF_CHANNEL */
+#define FREQ_BAND_MASK     0x0000003f
+#define CHNL_WIDTH_MASK    0x000007c0
+#define CHNL_WIDTH_SHIFT   6
+#define ACT_PRIMARY_MASK   0x00003800
+#define ACT_PRIMARY_SHIFT  11
+
+struct hostcmd_cmd_set_rf_channel {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	u8 curr_chnl;
+	__le32 chnl_flags;
+} __packed;
+
+struct hostcmd_cmd_set_rf_channel_kf2 {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	u8 curr_chnl;
+	__le32 chnl_flags;
+	u8 remain_on_chan;
+} __packed;
+
+/* HOSTCMD_CMD_SET_AID */
+struct hostcmd_cmd_set_aid {
+	struct hostcmd_header cmd_hdr;
+	__le16 aid;
+	u8 mac_addr[ETH_ALEN];       /* AP's Mac Address(BSSID) */
+	__le32 gprotect;
+	u8 ap_rates[SYSADPT_MAX_DATA_RATES_G];
+} __packed;
+
+/* HOSTCMD_CMD_SET_INFRA_MODE */
+struct hostcmd_cmd_set_infra_mode {
+	struct hostcmd_header cmd_hdr;
+} __packed;
+
+/* HOSTCMD_CMD_802_11_RTS_THSD */
+struct hostcmd_cmd_802_11_rts_thsd {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	__le16	threshold;
+} __packed;
+
+/* HOSTCMD_CMD_SET_EDCA_PARAMS */
+struct hostcmd_cmd_set_edca_params {
+	struct hostcmd_header cmd_hdr;
+	/* 0 = get all, 0x1 =set CWMin/Max,  0x2 = set TXOP , 0x4 =set AIFSN */
+	__le16 action;
+	__le16 txop;                 /* in unit of 32 us */
+	__le32 cw_max;               /* 0~15 */
+	__le32 cw_min;               /* 0~15 */
+	u8 aifsn;
+	u8 txq_num;                  /* Tx Queue number. */
+} __packed;
+
+/* HOSTCMD_CMD_802_11H_DETECT_RADAR */
+#define RADAR_TYPE_CODE_0    0
+#define RADAR_TYPE_CODE_53   53
+#define RADAR_TYPE_CODE_56   56
+#define RADAR_TYPE_CODE_ETSI 151
+
+struct hostcmd_cmd_802_11h_detect_radar {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	__le16 radar_type_code;
+	__le16 min_chirp_cnt;
+	__le16 chirp_time_intvl;
+	__le16 pw_filter;
+	__le16 min_num_radar;
+	__le16 pri_min_num;
+} __packed;
+
+/* HOSTCMD_CMD_SET_WMM_MODE */
+struct hostcmd_cmd_set_wmm_mode {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;               /* 0->unset, 1->set */
+} __packed;
+
+/* HOSTCMD_CMD_HT_GUARD_INTERVAL */
+struct hostcmd_cmd_ht_guard_interval {
+	struct hostcmd_header cmd_hdr;
+	__le32 action;
+	__le32 gi_type;
+} __packed;
+
+/* HOSTCMD_CMD_SET_FIXED_RATE */
+struct fix_rate_flag {           /* lower rate after the retry count */
+	/* 0: legacy, 1: HT */
+	__le32 fix_rate_type;
+	/* 0: retry count is not valid, 1: use retry count specified */
+	__le32 retry_count_valid;
+} __packed;
+
+struct fix_rate_entry {
+	struct fix_rate_flag fix_rate_type_flags;
+	/* depending on the flags above, this can be either a legacy
+	 * rate(not index) or an MCS code.
+	 */
+	__le32 fixed_rate;
+	__le32 retry_count;
+} __packed;
+
+struct hostcmd_cmd_set_fixed_rate {
+	struct hostcmd_header cmd_hdr;
+	/* HOSTCMD_ACT_NOT_USE_FIXED_RATE 0x0002 */
+	__le32 action;
+	/* use fixed rate specified but firmware can drop to */
+	__le32 allow_rate_drop;
+	__le32 entry_count;
+	struct fix_rate_entry fixed_rate_table[4];
+	u8 multicast_rate;
+	u8 multi_rate_tx_type;
+	u8 management_rate;
+} __packed;
+
+/* HOSTCMD_CMD_SET_IES */
+struct hostcmd_cmd_set_ies {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;               /* 0->unset, 1->set */
+	__le16 ie_list_len_ht;
+	__le16 ie_list_len_vht;
+	__le16 ie_list_len_proprietary;
+	/*Buffer size same as Generic_Beacon*/
+	u8 ie_list_ht[148];
+	u8 ie_list_vht[24];
+	u8 ie_list_proprietary[112];
+} __packed;
+
+/* HOSTCMD_CMD_SET_LINKADAPT_CS_MODE */
+struct hostcmd_cmd_set_linkadapt_cs_mode {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	__le16 cs_mode;
+} __packed;
+
+/* HOSTCMD_CMD_DUMP_OTP_DATA */
+struct hostcmd_cmd_dump_otp_data {
+	struct hostcmd_header cmd_hdr;
+	u8 pload[0];
+} __packed;
+
+/* HOSTCMD_CMD_SET_MAC_ADDR, HOSTCMD_CMD_DEL_MAC_ADDR */
+struct hostcmd_cmd_set_mac_addr {
+	struct hostcmd_header cmd_hdr;
+	__le16 mac_type;
+	u8 mac_addr[ETH_ALEN];
+} __packed;
+
+/* HOSTCMD_CMD_SET_RATE_ADAPT_MODE */
+struct hostcmd_cmd_set_rate_adapt_mode {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	__le16 rate_adapt_mode;      /* 0:Indoor, 1:Outdoor */
+} __packed;
+
+/* HOSTCMD_CMD_GET_WATCHDOG_BITMAP */
+struct hostcmd_cmd_get_watchdog_bitmap {
+	struct hostcmd_header cmd_hdr;
+	u8 watchdog_bitmap;          /* for SW/BA */
+} __packed;
+
+/* HOSTCMD_CMD_BSS_START */
+struct hostcmd_cmd_bss_start {
+	struct hostcmd_header cmd_hdr;
+	__le32 enable;                  /* FALSE: Disable or TRUE: Enable */
+	u8 amsdu;
+} __packed;
+
+/* HOSTCMD_CMD_AP_BEACON */
+struct cf_params {
+	u8 elem_id;
+	u8 len;
+	u8 cfp_cnt;
+	u8 cfp_period;
+	__le16 cfp_max_duration;
+	__le16 cfp_duration_remaining;
+} __packed;
+
+struct ibss_params {
+	u8 elem_id;
+	u8 len;
+	__le16	atim_window;
+} __packed;
+
+union ss_params {
+	struct cf_params cf_param_set;
+	struct ibss_params ibss_param_set;
+} __packed;
+
+struct fh_params {
+	u8 elem_id;
+	u8 len;
+	__le16 dwell_time;
+	u8 hop_set;
+	u8 hop_pattern;
+	u8 hop_index;
+} __packed;
+
+struct ds_params {
+	u8 elem_id;
+	u8 len;
+	u8 current_chnl;
+} __packed;
+
+union phy_params {
+	struct fh_params fh_param_set;
+	struct ds_params ds_param_set;
+} __packed;
+
+struct rsn_ie {
+	u8 elem_id;
+	u8 len;
+	u8 oui_type[4];              /* 00:50:f2:01 */
+	u8 ver[2];
+	u8 grp_key_cipher[4];
+	u8 pws_key_cnt[2];
+	u8 pws_key_cipher_list[4];
+	u8 auth_key_cnt[2];
+	u8 auth_key_list[4];
+} __packed;
+
+struct rsn48_ie {
+	u8 elem_id;
+	u8 len;
+	u8 ver[2];
+	u8 grp_key_cipher[4];
+	u8 pws_key_cnt[2];
+	u8 pws_key_cipher_list[4];
+	u8 auth_key_cnt[2];
+	u8 auth_key_list[4];
+	u8 rsn_cap[2];
+	u8 pmk_id_cnt[2];
+	u8 pmk_id_list[16];          /* Should modify to 16 * S */
+	u8 reserved[8];
+} __packed;
+
+struct ac_param_rcd {
+	u8 aci_aifsn;
+	u8 ecw_min_max;
+	__le16 txop_lim;
+} __packed;
+
+struct wmm_param_elem {
+	u8 elem_id;
+	u8 len;
+	u8 oui[3];
+	u8 type;
+	u8 sub_type;
+	u8 version;
+	u8 qos_info;
+	u8 rsvd;
+	struct ac_param_rcd ac_be;
+	struct ac_param_rcd ac_bk;
+	struct ac_param_rcd ac_vi;
+	struct ac_param_rcd ac_vo;
+} __packed;
+
+struct channel_info {
+	u8 first_channel_num;
+	u8 num_channels;
+	u8 max_tx_pwr_level;
+} __packed;
+
+struct country {
+	u8 elem_id;
+	u8 len;
+	u8 country_str[3];
+	struct channel_info channel_info[40];
+} __packed;
+
+struct start_cmd {
+	u8 sta_mac_addr[ETH_ALEN];
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+	u8 bss_type;
+	__le16 bcn_period;
+	u8 dtim_period;
+	union ss_params ss_param_set;
+	union phy_params phy_param_set;
+	__le16 probe_delay;
+	__le16 cap_info;
+	u8 b_rate_set[SYSADPT_MAX_DATA_RATES_G];
+	u8 op_rate_set[SYSADPT_MAX_DATA_RATES_G];
+	struct rsn_ie rsn_ie;
+	struct rsn48_ie rsn48_ie;
+	struct wmm_param_elem wmm_param;
+	struct country country;
+	__le32 ap_rf_type;           /* 0->B, 1->G, 2->Mixed, 3->A, 4->11J */
+	u8 rsvd[3];
+	u8 bssid[ETH_ALEN];          /* only for 88W8997                   */
+} __packed;
+
+struct hostcmd_cmd_ap_beacon {
+	struct hostcmd_header cmd_hdr;
+	struct start_cmd start_cmd;
+} __packed;
+
+/* HOSTCMD_CMD_SET_NEW_STN */
+struct add_ht_info {
+	u8 control_chnl;
+	u8 add_chnl;
+	__le16 op_mode;
+	__le16 stbc;
+} __packed;
+
+struct peer_info {
+	__le32 legacy_rate_bitmap;
+	u8 ht_rates[4];
+	__le16 cap_info;
+	__le16 ht_cap_info;
+	u8 mac_ht_param_info;
+	u8 mrvl_sta;
+	struct add_ht_info add_ht_info;
+	__le32 tx_bf_capabilities;   /* EXBF_SUPPORT */
+	__le32 vht_max_rx_mcs;
+	__le32 vht_cap;
+	/* 0:20Mhz, 1:40Mhz, 2:80Mhz, 3:160 or 80+80Mhz */
+	u8 vht_rx_channel_width;
+} __packed;
+
+struct hostcmd_cmd_set_new_stn {
+	struct hostcmd_header cmd_hdr;
+	__le16 aid;
+	u8 mac_addr[ETH_ALEN];
+	__le16 stn_id;
+	__le16 action;
+	__le16 if_type;
+	struct peer_info peer_info;
+	/* UAPSD_SUPPORT */
+	u8 qos_info;
+	u8 is_qos_sta;
+	__le32 fw_sta_ptr;
+} __packed;
+
+struct retry_cnt_qos {
+	u8 retry_cfg_enable;
+	u8 retry_cnt_BK;
+	u8 retry_cnt_BE;
+	u8 retry_cnt_VI;
+	u8 retry_cnt_VO;
+} __packed;
+
+struct peer_info_sc4 {
+	__le32 legacy_rate_bitmap;
+	u8 ht_rates[4];
+	__le16 cap_info;
+	__le16 ht_cap_info;
+	u8 mac_ht_param_info;
+	u8 mrvl_sta;
+	struct add_ht_info add_ht_info;
+	__le32 tx_bf_capabilities;   /* EXBF_SUPPORT */
+	__le32 vht_max_rx_mcs;
+	__le32 vht_cap;
+	/* 0:20Mhz, 1:40Mhz, 2:80Mhz, 3:160 or 80+80Mhz */
+	u8 vht_rx_channel_width;
+	struct retry_cnt_qos retry_cnt_qos;
+	u8 assoc_rssi;
+} __packed;
+
+struct hostcmd_cmd_set_new_stn_sc4 {
+	struct hostcmd_header cmd_hdr;
+	__le16 aid;
+	u8 mac_addr[ETH_ALEN];
+	__le16 stn_id;
+	__le16 action;
+	__le16 reserved;
+	struct peer_info_sc4 peer_info;
+	/* UAPSD_SUPPORT */
+	u8 qos_info;
+	u8 is_qos_sta;
+	__le32 fw_sta_ptr;
+	__le32 wds;
+} __packed;
+
+/* HOSTCMD_CMD_SET_APMODE */
+struct hostcmd_cmd_set_apmode {
+	struct hostcmd_header cmd_hdr;
+	u8 apmode;
+} __packed;
+
+/* HOSTCMD_CMD_SET_SWITCH_CHANNEL */
+struct hostcmd_cmd_set_switch_channel {
+	struct hostcmd_header cmd_hdr;
+	__le32 next_11h_chnl;
+	__le32 mode;
+	__le32 init_count;
+	__le32 chnl_flags;
+	__le32 next_ht_extchnl_offset;
+	__le32 dfs_test_mode;
+} __packed;
+
+/* HOSTCMD_CMD_UPDATE_ENCRYPTION */
+struct hostcmd_cmd_update_encryption {
+	struct hostcmd_header cmd_hdr;
+	/* Action type - see encr_action_type */
+	__le32 action_type;          /* encr_action_type */
+	/* size of the data buffer attached. */
+	__le32 data_length;
+	u8 mac_addr[ETH_ALEN];
+	u8 action_data[1];
+} __packed;
+
+struct wep_type_key {
+	/* WEP key material (max 128bit) */
+	u8 key_material[MAX_ENCR_KEY_LENGTH];
+} __packed;
+
+struct encr_tkip_seqcnt {
+	__le16 low;
+	__le32 high;
+} __packed;
+
+struct tkip_type_key {
+	/* TKIP Key material. Key type (group or pairwise key) is
+	 * determined by flags
+	 */
+	/* in KEY_PARAM_SET structure. */
+	u8 key_material[MAX_ENCR_KEY_LENGTH];
+	/* MIC keys */
+	u8 tkip_tx_mic_key[MIC_KEY_LENGTH];
+	u8 tkip_rx_mic_key[MIC_KEY_LENGTH];
+	struct encr_tkip_seqcnt	tkip_rsc;
+	struct encr_tkip_seqcnt	tkip_tsc;
+} __packed;
+
+struct aes_type_key {
+	/* AES Key material */
+	u8 key_material[MAX_ENCR_KEY_LENGTH];
+} __packed;
+
+union mwl_key_type {
+	struct wep_type_key  wep_key;
+	struct tkip_type_key tkip_key;
+	struct aes_type_key  aes_key;
+} __packed;
+
+struct key_param_set {
+	/* Total length of this structure (Key is variable size array) */
+	__le16 length;
+	/* Key type - WEP, TKIP or AES-CCMP. */
+	/* See definitions above */
+	__le16 key_type_id;
+	/* key flags (ENCR_KEY_FLAG_XXX_ */
+	__le32 key_info;
+	/* For WEP only - actual key index */
+	__le32 key_index;
+	/* Size of the key */
+	__le16 key_len;
+	/* Key material (variable size array) */
+	union mwl_key_type key;
+	u8 mac_addr[ETH_ALEN];
+} __packed;
+
+struct hostcmd_cmd_set_key {
+	struct hostcmd_header cmd_hdr;
+	/* Action type - see encr_action_type */
+	__le32 action_type;          /* encr_action_type */
+	/* size of the data buffer attached. */
+	__le32 data_length;
+	/* data buffer - maps to one KEY_PARAM_SET structure */
+	struct key_param_set key_param;
+} __packed;
+
+/* HOSTCMD_CMD_BASTREAM */
+#define BA_TYPE_MASK           0x00000001
+#define BA_DIRECTION_MASK      0x0000000e
+#define BA_DIRECTION_SHIFT     1
+
+#define BA_TYPE_MASK_NDP       0x00000003
+#define BA_DIRECTION_MASK_NDP  0x0000001c
+#define BA_DIRECTION_SHIFT_NDP 2
+
+struct ba_context {
+	__le32 context;
+} __packed;
+
+/* parameters for block ack creation */
+struct create_ba_params {
+	/* BA Creation flags - see above */
+	__le32 flags;
+	/* idle threshold */
+	__le32 idle_thrs;
+	/* block ack transmit threshold (after how many pkts should we
+	 * send BAR?)
+	 */
+	__le32 bar_thrs;
+	/* receiver window size */
+	__le32 window_size;
+	/* MAC Address of the BA partner */
+	u8 peer_mac_addr[ETH_ALEN];
+	/* Dialog Token */
+	u8 dialog_token;
+	/* TID for the traffic stream in this BA */
+	u8 tid;
+	/* shared memory queue ID (not sure if this is required) */
+	u8 queue_id;
+	u8 param_info;
+	/* returned by firmware - firmware context pointer. */
+	/* this context pointer will be passed to firmware for all
+	 * future commands.
+	 */
+	struct ba_context fw_ba_context;
+	u8 reset_seq_no;             /** 0 or 1**/
+	__le16 current_seq;
+	__le32 vht_rx_factor;
+	/* This is for virtual station in Sta proxy mode for V6FW */
+	u8 sta_src_mac_addr[ETH_ALEN];
+} __packed;
+
+/* new transmit sequence number information */
+struct ba_update_seq_num {
+	/* BA flags - see above */
+	__le32 flags;
+	/* returned by firmware in the create ba stream response */
+	struct ba_context fw_ba_context;
+	/* new sequence number for this block ack stream */
+	__le16 ba_seq_num;
+} __packed;
+
+struct ba_stream_context {
+	/* BA Stream flags */
+	__le32 flags;
+	/* returned by firmware in the create ba stream response */
+	struct ba_context fw_ba_context;
+	u8 tid;
+	u8 peer_mac_addr[ETH_ALEN];
+} __packed;
+
+union ba_info {
+	/* information required to create BA Stream... */
+	struct create_ba_params	create_params;
+	/* update starting/new sequence number etc. */
+	struct ba_update_seq_num updt_seq_num;
+	/* destroy an existing stream... */
+	struct ba_stream_context destroy_params;
+	/* destroy an existing stream... */
+	struct ba_stream_context flush_params;
+} __packed;
+
+struct hostcmd_cmd_bastream {
+	struct hostcmd_header cmd_hdr;
+	__le32 action_type;
+	union ba_info ba_info;
+} __packed;
+
+/* HOSTCMD_CMD_SET_SPECTRUM_MGMT */
+struct hostcmd_cmd_set_spectrum_mgmt {
+	struct hostcmd_header cmd_hdr;
+	__le32 spectrum_mgmt;
+} __packed;
+
+/* HOSTCMD_CMD_SET_POWER_CONSTRAINT */
+struct hostcmd_cmd_set_power_constraint {
+	struct hostcmd_header cmd_hdr;
+	__le32 power_constraint;
+} __packed;
+
+/* HOSTCMD_CMD_SET_COUNTRY_CODE */
+struct domain_chnl_entry {
+	u8 first_chnl_num;
+	u8 chnl_num;
+	u8 max_transmit_pw;
+} __packed;
+
+struct domain_country_info {
+	u8 country_string[3];
+	u8 g_chnl_len;
+	struct domain_chnl_entry domain_entry_g[1];
+	u8 a_chnl_len;
+	struct domain_chnl_entry domain_entry_a[20];
+} __packed;
+
+struct hostcmd_cmd_set_country_code {
+	struct hostcmd_header cmd_hdr;
+	__le32 action ; /* 0 -> unset, 1 ->set */
+	struct domain_country_info domain_info;
+} __packed;
+
+/* HOSTCMD_CMD_SET_OPTIMIZATION_LEVEL */
+struct hostcmd_cmd_set_optimization_level {
+	struct hostcmd_header cmd_hdr;
+	u8 opt_level;
+} __packed;
+
+/* HOSTCMD_CMD_SET_WSC_IE */
+struct hostcmd_cmd_set_wsc_ie {
+	struct hostcmd_header cmd_hdr;
+	__le16 ie_type;              /* 0 -- beacon. or 1 -- probe response. */
+	__le16 len;
+	u8 data[WSC_IE_MAX_LENGTH];
+} __packed;
+
+/* HOSTCMD_CMD_GET_RATETABLE */
+struct hostcmd_cmd_get_ratetable {
+	struct hostcmd_header cmd_hdr;
+	u8 addr[ETH_ALEN];
+	u8 type;                     /* 0: SU, 1: MU */
+	/* multiply 2 because 2 DWORD in rate info   */
+	__le32 sorted_rates_idx_map[2 * SYSADPT_MAX_RATE_ADAPT_RATES];
+} __packed;
+
+/* HOSTCMD_CMD_GET_SEQNO */
+struct hostcmd_cmd_get_seqno {
+	struct hostcmd_header cmd_hdr;
+	u8 mac_addr[ETH_ALEN];
+	u8 tid;
+	__le16 seq_no;
+	u8 reserved;
+} __packed;
+
+/* HOSTCMD_CMD_DWDS_ENABLE */
+struct hostcmd_cmd_dwds_enable {
+	struct hostcmd_header cmd_hdr;
+	__le32 enable;               /* 0 -- Disable. or 1 -- Enable. */
+} __packed;
+
+/* HOSTCMD_CMD_FW_FLUSH_TIMER */
+struct hostcmd_cmd_fw_flush_timer {
+	struct hostcmd_header cmd_hdr;
+	/* 0 -- Disable. > 0 -- holds time value in usecs. */
+	__le32 value;
+} __packed;
+
+/* HOSTCMD_CMD_SET_CDD */
+struct hostcmd_cmd_set_cdd {
+	struct hostcmd_header cmd_hdr;
+	__le32 enable;
+} __packed;
+
+/* HOSTCMD_CMD_SET_BFTYPE */
+struct hostcmd_cmd_set_bftype {
+	struct hostcmd_header cmd_hdr;
+	__le32 action;
+	__le32 mode;
+} __packed;
+
+/* HOSTCMD_CMD_GET_TEMP */
+struct hostcmd_cmd_get_temp {
+	struct hostcmd_header cmd_hdr;
+	__le32 celcius;
+	__le32 raw_data;
+} __packed;
+
+/* HOSTCMD_CMD_LED_CTRL */
+struct hostcmd_cmd_led_ctrl {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;     /* 0: GET, 1: SET (only SET is supported) */
+	u8 led_enable;     /* 0: Disable, 1: Enable                  */
+	u8 led_control;    /* 0: HW 1: SW (only SW is supported)     */
+	u8 led_blink_rate; /* 1: Slow, 2: Medium, 3: Fast blink      */
+	u8 reserved;
+} __packed;
+
+/* HOSTCMD_CMD_GET_FW_REGION_CODE */
+struct hostcmd_cmd_get_fw_region_code {
+	struct hostcmd_header cmd_hdr;
+	__le32 status; /* 0 = Found, 1 = Error */
+	__le32 fw_region_code;
+} __packed;
+
+/* HOSTCMD_CMD_GET_DEVICE_PWR_TBL */
+#define HAL_TRPC_ID_MAX    16
+
+struct channel_power_tbl {
+	u8 channel;
+	u8 tx_pwr[HAL_TRPC_ID_MAX];
+	u8 dfs_capable;
+	u8 ax_ant;
+	u8 cdd;
+} __packed;
+
+struct hostcmd_cmd_get_device_pwr_tbl {
+	struct hostcmd_header cmd_hdr;
+	__le16 status; /* 0 = Found, 1 = Error */
+	u8 region_code;
+	u8 number_of_channels;
+	__le32 current_channel_index;
+	/* Only for 1 channel, so, 1 channel at a time */
+	struct channel_power_tbl channel_pwr_tbl;
+} __packed;
+
+/* HOSTCMD_CMD_SET_RATE_DROP */
+struct hostcmd_cmd_set_rate_drop {
+	struct hostcmd_header cmd_hdr;
+	__le32 enable;
+	__le32 rate_index;
+	__le32 sta_index;
+} __packed;
+
+/* HOSTCMD_CMD_NEWDP_DMATHREAD_START */
+struct hostcmd_cmd_newdp_dmathread_start {
+	struct hostcmd_header cmd_hdr;
+} __packed;
+
+/* HOSTCMD_CMD_GET_FW_REGION_CODE_SC4 */
+struct hostcmd_cmd_get_fw_region_code_sc4 {
+	struct hostcmd_header cmd_hdr;
+	__le32 status; /* 0 = Found, 1 = Error */
+	__le32 fw_region_code;
+} __packed;
+
+/* HOSTCMD_CMD_GET_DEVICE_PWR_TBL_SC4 */
+#define HAL_TRPC_ID_MAX_SC4        32
+#define MAX_GROUP_PER_CHANNEL_5G   39
+#define MAX_GROUP_PER_CHANNEL_2G   21
+#define	MAX(a, b) (((a) > (b)) ? (a) : (b))
+#define MAX_GROUP_PER_CHANNEL_RATE \
+	MAX(MAX_GROUP_PER_CHANNEL_5G, MAX_GROUP_PER_CHANNEL_2G)
+
+struct channel_power_tbl_sc4 {
+	u8 channel;
+	u8 grp_pwr[MAX_GROUP_PER_CHANNEL_RATE];
+	u8 tx_pwr[HAL_TRPC_ID_MAX_SC4];
+	u8 dfs_capable;
+	u8 ax_ant;
+	u8 cdd;
+	u8 rsvd;
+} __packed;
+
+struct hostcmd_cmd_get_device_pwr_tbl_sc4 {
+	struct hostcmd_header cmd_hdr;
+	__le16 status; /* 0 = Found, 1 = Error */
+	u8 region_code;
+	u8 number_of_channels;
+	__le32 current_channel_index;
+	/* Only for 1 channel, so, 1 channel at a time */
+	struct channel_power_tbl_sc4 channel_pwr_tbl;
+} __packed;
+
+/* HOSTCMD_CMD_QUIET_MODE */
+struct hostcmd_cmd_quiet_mode {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	__le32 enable;
+	__le32 period;
+	__le32 duration;
+	__le32 next_offset;
+} __packed;
+
+/* HOSTCMD_CMD_CORE_DUMP_DIAG_MODE */
+struct hostcmd_cmd_core_dump_diag_mode {
+	struct hostcmd_header cmd_hdr;
+	__le16 status;
+} __packed;
+
+/* HOSTCMD_CMD_GET_FW_CORE_DUMP */
+#define MAX_CORE_REGIONS       20
+#define MAX_CORE_SYMBOLS       30
+#define MVL_COREDUMP_DIAG_MODE 0x00000001
+#define MVL_COREDUMP_INCL_EXT  0x00000002
+#define MAX_CORE_DUMP_BUFFER   2048
+
+struct core_region {
+	__le32 address;
+	__le32 length;
+} __packed;
+
+struct core_symbol {
+	u8 name[16];
+	__le32 address;
+	__le32 length;
+	__le16 entries;
+} __packed;
+
+struct coredump {
+	u8 version_major;
+	u8 version_minor;
+	u8 version_patch;
+	u8 hdr_version;
+	u8 num_regions;
+	u8 num_symbols;
+	u8 fill[2];
+	struct core_region region[MAX_CORE_REGIONS];
+	struct core_symbol symbol[MAX_CORE_SYMBOLS];
+	__le32 fill_end[40];
+} __packed;
+
+struct coredump_cmd {
+	__le32 context;
+	__le32 buffer;
+	__le32 buffer_len;
+	__le16 size_kb;
+	__le16 flags;
+} __packed;
+
+struct debug_mem_cmd {
+	__le32 set;
+	__le32 type;
+	__le32 addr;
+	__le32 val;
+} __packed;
+
+struct hostcmd_cmd_get_fw_core_dump {
+	struct hostcmd_header cmd_hdr;
+	union {
+		struct coredump_cmd coredump;
+		struct debug_mem_cmd debug_mem;
+	} cmd_data;
+	/*Buffer where F/W Copies the Core Dump*/
+	char buffer[MAX_CORE_DUMP_BUFFER];
+} __packed;
+
+struct hostcmd_cmd_get_fw_core_dump_ {
+	struct hostcmd_header cmd_hdr;
+	union {
+		struct coredump_cmd coredump;
+		struct debug_mem_cmd debug_mem;
+	} cmd_data;
+} __packed;
+
+/* HOSTCMD_CMD_802_11_SLOT_TIME */
+struct hostcmd_cmd_802_11_slot_time {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	/* 0:long slot; 1:short slot */
+	__le16 short_slot;
+} __packed;
+
+/* HOSTCMD_CMD_EDMAC_CTRL */
+struct hostcmd_cmd_edmac_ctrl {
+	struct hostcmd_header cmd_hdr;
+	__le16 action;
+	__le16 ed_ctrl_2g;
+	__le16 ed_offset_2g;
+	__le16 ed_ctrl_5g;
+	__le16 ed_offset_5g;
+	__le16 ed_bitmap_txq_lock;
+} __packed;
+
+/* HOSTCMD_CMD_TXPWRLMT_CFG */
+#define TXPWRLMT_CFG_VERSION_INFO_LEN 0x4
+#define TXPWRLMT_CFG_MAX_SUBBAND_INFO 0x5
+#define TXPWRLMT_CFG_SIG_LEN          0x4
+#define TXPWRLMT_CFG_SIGNATURE        0xA1240E01
+
+struct hostcmd_cmd_txpwrlmt_cfg {
+	struct hostcmd_header cmd_hdr;
+	/* Action */
+	__le16 action;
+	/*Sub band id*/
+	u8 subband_id;
+	/* Cfg Complete Info*/
+	u8 cfgComplete;
+	/* Data length */
+	__le16 data_len;
+	/*number of entries*/
+	__le16 num_entries;
+	/* Data */
+	u8 data[1];
+} __packed;
+
+struct mwl_txpwrlmt_cfg_entry_hdr {
+	/* subband id */
+	__le16 id;
+	/* length */
+	__le16 len;
+	/* number of entries */
+	__le16 num_entries;
+} __packed;
+
+/* HOSTCMD_CMD_MCAST_CTS */
+struct hostcmd_cmd_mcast_cts {
+	struct hostcmd_header cmd_hdr;
+	u8 enable;            /* 1:enable, 0:disable */
+} __packed;
+
+#endif /* _HOSTCMD_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/dev.h b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/dev.h
new file mode 100644
index 000000000000..2c26bff80683
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/dev.h
@@ -0,0 +1,1032 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines device related information. */
+
+#ifndef _DEV_H_
+#define _DEV_H_
+
+#include <linux/version.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <net/mac80211.h>
+
+#define PCIE_DRV_NAME    KBUILD_MODNAME
+#define PCIE_DRV_VERSION "10.3.8.0-20181210"
+
+#define PCIE_MIN_BYTES_HEADROOM   64
+#define PCIE_MIN_TX_HEADROOM_KF2  96
+#define PCIE_NUM_OF_DESC_DATA     SYSADPT_TOTAL_TX_QUEUES
+#define PCIE_AMPDU_QUEUES         4
+#define PCIE_MAX_NUM_TX_DESC      256
+#define PCIE_TX_QUEUE_LIMIT       (3 * PCIE_MAX_NUM_TX_DESC)
+#define PCIE_TX_WAKE_Q_THRESHOLD  (2 * PCIE_MAX_NUM_TX_DESC)
+#define PCIE_DELAY_FREE_Q_LIMIT   PCIE_MAX_NUM_TX_DESC
+#define PCIE_MAX_NUM_RX_DESC      256
+#define PCIE_RECEIVE_LIMIT        64
+
+enum {
+	IEEE_TYPE_MANAGEMENT = 0,
+	IEEE_TYPE_CONTROL,
+	IEEE_TYPE_DATA
+};
+
+#define MAC_REG_ADDR(offset)      (offset)
+#define MAC_REG_ADDR_PCI(offset)  ((pcie_priv->iobase1 + 0xA000) + offset)
+
+#define MCU_CCA_CNT               MAC_REG_ADDR(0x06A0)
+#define MCU_TXPE_CNT              MAC_REG_ADDR(0x06A4)
+#define MCU_LAST_READ             MAC_REG_ADDR(0x06A8)
+
+/* Map to 0x80000000 (Bus control) on BAR0 */
+#define MACREG_REG_H2A_INTERRUPT_EVENTS      0x00000C18 /* (From host to ARM) */
+#define MACREG_REG_H2A_INTERRUPT_CAUSE       0x00000C1C /* (From host to ARM) */
+#define MACREG_REG_H2A_INTERRUPT_MASK        0x00000C20 /* (From host to ARM) */
+#define MACREG_REG_H2A_INTERRUPT_CLEAR_SEL   0x00000C24 /* (From host to ARM) */
+#define MACREG_REG_H2A_INTERRUPT_STATUS_MASK 0x00000C28 /* (From host to ARM) */
+
+#define MACREG_REG_A2H_INTERRUPT_EVENTS      0x00000C2C /* (From ARM to host) */
+#define MACREG_REG_A2H_INTERRUPT_CAUSE       0x00000C30 /* (From ARM to host) */
+#define MACREG_REG_A2H_INTERRUPT_MASK        0x00000C34 /* (From ARM to host) */
+#define MACREG_REG_A2H_INTERRUPT_CLEAR_SEL   0x00000C38 /* (From ARM to host) */
+#define MACREG_REG_A2H_INTERRUPT_STATUS_MASK 0x00000C3C /* (From ARM to host) */
+
+/* Map to 0x80000000 on BAR1 */
+#define MACREG_REG_GEN_PTR                  0x00000C10
+#define MACREG_REG_INT_CODE                 0x00000C14
+
+/* Bit definition for MACREG_REG_A2H_INTERRUPT_CAUSE (A2HRIC) */
+#define MACREG_A2HRIC_BIT_TX_DONE           BIT(0)
+#define MACREG_A2HRIC_BIT_RX_RDY            BIT(1)
+#define MACREG_A2HRIC_BIT_OPC_DONE          BIT(2)
+#define MACREG_A2HRIC_BIT_MAC_EVENT         BIT(3)
+#define MACREG_A2HRIC_BIT_RX_PROBLEM        BIT(4)
+#define MACREG_A2HRIC_BIT_RADIO_OFF         BIT(5)
+#define MACREG_A2HRIC_BIT_RADIO_ON          BIT(6)
+#define MACREG_A2HRIC_BIT_RADAR_DETECT      BIT(7)
+#define MACREG_A2HRIC_BIT_ICV_ERROR         BIT(8)
+#define MACREG_A2HRIC_BIT_WEAKIV_ERROR      BIT(9)
+#define MACREG_A2HRIC_BIT_QUE_EMPTY         BIT(10)
+#define MACREG_A2HRIC_BIT_QUE_FULL          BIT(11)
+#define MACREG_A2HRIC_BIT_CHAN_SWITCH       BIT(12)
+#define MACREG_A2HRIC_BIT_TX_WATCHDOG       BIT(13)
+#define MACREG_A2HRIC_BA_WATCHDOG           BIT(14)
+/* 15 taken by ISR_TXACK */
+#define MACREG_A2HRIC_BIT_SSU_DONE          BIT(16)
+#define MACREG_A2HRIC_CONSEC_TXFAIL         BIT(17)
+
+#define ISR_SRC_BITS        (MACREG_A2HRIC_BIT_RX_RDY | \
+			     MACREG_A2HRIC_BIT_TX_DONE | \
+			     MACREG_A2HRIC_BIT_OPC_DONE | \
+			     MACREG_A2HRIC_BIT_MAC_EVENT | \
+			     MACREG_A2HRIC_BIT_WEAKIV_ERROR | \
+			     MACREG_A2HRIC_BIT_ICV_ERROR | \
+			     MACREG_A2HRIC_BIT_SSU_DONE | \
+			     MACREG_A2HRIC_BIT_RADAR_DETECT | \
+			     MACREG_A2HRIC_BIT_CHAN_SWITCH | \
+			     MACREG_A2HRIC_BIT_TX_WATCHDOG | \
+			     MACREG_A2HRIC_BIT_QUE_EMPTY | \
+			     MACREG_A2HRIC_BA_WATCHDOG | \
+			     MACREG_A2HRIC_CONSEC_TXFAIL)
+
+#define MACREG_A2HRIC_BIT_MASK      ISR_SRC_BITS
+
+/* Bit definition for MACREG_REG_H2A_INTERRUPT_CAUSE (H2ARIC) */
+#define MACREG_H2ARIC_BIT_PPA_READY         BIT(0)
+#define MACREG_H2ARIC_BIT_DOOR_BELL         BIT(1)
+#define MACREG_H2ARIC_BIT_PS                BIT(2)
+#define MACREG_H2ARIC_BIT_PSPOLL            BIT(3)
+#define ISR_RESET                           BIT(15)
+#define ISR_RESET_AP33                      BIT(26)
+
+/* Data descriptor related constants */
+#define EAGLE_RXD_CTRL_DRIVER_OWN           0x00
+#define EAGLE_RXD_CTRL_DMA_OWN              0x80
+
+#define EAGLE_RXD_STATUS_OK                 0x01
+
+#define EAGLE_TXD_STATUS_IDLE               0x00000000
+#define EAGLE_TXD_STATUS_OK                 0x00000001
+#define EAGLE_TXD_STATUS_FW_OWNED           0x80000000
+
+struct pcie_tx_desc {
+	u8 data_rate;
+	u8 tx_priority;
+	__le16 qos_ctrl;
+	__le32 pkt_ptr;
+	__le16 pkt_len;
+	u8 dest_addr[ETH_ALEN];
+	__le32 pphys_next;
+	__le32 sap_pkt_info;
+	__le32 rate_info;
+	u8 type;
+	u8 xmit_control;     /* bit 0: use rateinfo, bit 1: disable ampdu */
+	__le16 reserved;
+	__le32 tcpack_sn;
+	__le32 tcpack_src_dst;
+	__le32 reserved1;
+	__le32 reserved2;
+	u8 reserved3[2];
+	u8 packet_info;
+	u8 packet_id;
+	__le16 packet_len_and_retry;
+	__le16 packet_rate_info;
+	__le32 flags;
+	__le32 status;
+} __packed;
+
+struct pcie_tx_hndl {
+	struct sk_buff *psk_buff;
+	struct pcie_tx_desc *pdesc;
+	struct pcie_tx_hndl *pnext;
+};
+
+/* Receive rate information constants */
+#define RX_RATE_INFO_FORMAT_11A       0
+#define RX_RATE_INFO_FORMAT_11B       1
+#define RX_RATE_INFO_FORMAT_11N       2
+#define RX_RATE_INFO_FORMAT_11AC      4
+
+#define RX_RATE_INFO_HT20             0
+#define RX_RATE_INFO_HT40             1
+#define RX_RATE_INFO_HT80             2
+#define RX_RATE_INFO_HT160            3
+
+#define RX_RATE_INFO_LONG_INTERVAL    0
+#define RX_RATE_INFO_SHORT_INTERVAL   1
+
+#define MWL_RX_RATE_FORMAT_MASK       0x0007
+#define MWL_RX_RATE_NSS_MASK          0x0018
+#define MWL_RX_RATE_NSS_SHIFT         3
+#define MWL_RX_RATE_BW_MASK           0x0060
+#define MWL_RX_RATE_BW_SHIFT          5
+#define MWL_RX_RATE_GI_MASK           0x0080
+#define MWL_RX_RATE_GI_SHIFT          7
+#define MWL_RX_RATE_RT_MASK           0xFF00
+#define MWL_RX_RATE_RT_SHIFT          8
+
+struct pcie_rx_desc {
+	__le16 pkt_len;              /* total length of received data      */
+	__le16 rate;                 /* receive rate information           */
+	__le32 pphys_buff_data;      /* physical address of payload data   */
+	__le32 pphys_next;           /* physical address of next RX desc   */
+	__le16 qos_ctrl;             /* received QosCtrl field variable    */
+	__le16 ht_sig2;              /* like name states                   */
+	__le32 hw_rssi_info;
+	__le32 hw_noise_floor_info;
+	u8 noise_floor;
+	u8 reserved[3];
+	u8 rssi;                     /* received signal strengt indication */
+	u8 status;                   /* status field containing USED bit   */
+	u8 channel;                  /* channel this pkt was received on   */
+	u8 rx_control;               /* the control element of the desc    */
+	__le32 reserved1[3];
+} __packed;
+
+struct pcie_rx_hndl {
+	struct sk_buff *psk_buff;    /* associated sk_buff for Linux       */
+	struct pcie_rx_desc *pdesc;
+	struct pcie_rx_hndl *pnext;
+};
+
+struct pcie_desc_data {
+	dma_addr_t pphys_tx_ring;          /* ptr to first TX desc (phys.)    */
+	struct pcie_tx_desc *ptx_ring;     /* ptr to first TX desc (virt.)    */
+	struct pcie_tx_hndl *tx_hndl;
+	struct pcie_tx_hndl *pnext_tx_hndl;/* next TX handle that can be used */
+	struct pcie_tx_hndl *pstale_tx_hndl;/* the staled TX handle           */
+	dma_addr_t pphys_rx_ring;          /* ptr to first RX desc (phys.)    */
+	struct pcie_rx_desc *prx_ring;     /* ptr to first RX desc (virt.)    */
+	struct pcie_rx_hndl *rx_hndl;
+	struct pcie_rx_hndl *pnext_rx_hndl;/* next RX handle that can be used */
+	u32 wcb_base;                      /* FW base offset for registers    */
+	u32 rx_desc_write;                 /* FW descriptor write position    */
+	u32 rx_desc_read;                  /* FW descriptor read position     */
+	u32 rx_buf_size;                   /* length of the RX buffers        */
+};
+
+/* DMA header used by firmware and hardware. */
+struct pcie_dma_data {
+	__le16 fwlen;
+	struct ieee80211_hdr wh;
+	char data[0];
+} __packed;
+
+/* New Data Path */
+#define MACREG_REG_SCRATCH3                0x00000C44
+#define MACREG_REG_TXSENDHEAD              0x00000CD0
+#define MACREG_REG_TXSEDNTAIL              0x00000CD4
+#define MACREG_REG_TXDONEHEAD              0x00000CD8
+#define MACREG_REG_TXDONETAIL              0x00000CDC
+#define MACREG_REG_RXDESCHEAD              0x00000CE0
+#define MACREG_REG_RXDESCTAIL              0x00000CE4
+#define MACREG_REG_RXDONEHEAD              0x00000CE8
+#define MACREG_REG_RXDONETAIL              0x00000CEC
+#define MACREG_REG_ACNTHEAD                0x00000CF0
+#define MACREG_REG_ACNTTAIL                0x00000CF4
+
+/* Buff removed from Tx Send Ring */
+#define MACREG_A2HRIC_TX_DESC_TAIL_RDY     (1<<9)
+/* Buff added to Tx Done Ring */
+#define MACREG_A2HRIC_TX_DONE_HEAD_RDY     (1<<10)
+/* Records added to Accounting Ring */
+#define MACREG_A2HRIC_ACNT_HEAD_RDY        (1<<12)
+/* Buff removed from Rx Desc Ring */
+#define MACREG_A2HRIC_RX_DESC_TAIL_RDY     (1<<17)
+/* Buff added to Rx Done Ring */
+#define MACREG_A2HRIC_RX_DONE_HEAD_RDY     (1<<18)
+#define MACREG_A2HRIC_NEWDP_DFS            (1<<19)
+#define MACREG_A2HRIC_NEWDP_CHANNEL_SWITCH (1<<20)
+
+#define ISR_SRC_BITS_NDP     ((MACREG_A2HRIC_ACNT_HEAD_RDY) | \
+			      (MACREG_A2HRIC_RX_DONE_HEAD_RDY) | \
+			      (MACREG_A2HRIC_NEWDP_DFS)     | \
+			      (MACREG_A2HRIC_NEWDP_CHANNEL_SWITCH))
+
+#define MACREG_A2HRIC_BIT_MASK_NDP ISR_SRC_BITS_NDP
+
+#define MIN_BYTES_RX_HEADROOM  (64 + 2)
+#define AMPDU_QUEUES_NDP       (SYSADPT_MAX_STA_SC4 * \
+				SYSADPT_MAX_TID)
+#define MAX_NUM_TX_DESC        1024
+#define MAX_NUM_RX_DESC        (1024 * 16)
+#define MAX_TX_RING_SEND_SIZE  (4 * MAX_NUM_TX_DESC)
+#define MAX_TX_RING_DONE_SIZE  MAX_NUM_TX_DESC
+#define MAX_RX_RING_SEND_SIZE  MAX_NUM_RX_DESC
+#define MAX_RX_RING_DONE_SIZE  MAX_NUM_RX_DESC
+#define DEFAULT_ACNT_RING_SIZE 0x10000
+#define MAX_AGGR_SIZE          1900
+#define TX_QUEUE_LIMIT         MAX_NUM_TX_DESC
+#define TX_WAKE_Q_THRESHOLD    (MAX_NUM_TX_DESC - 256)
+
+/* RateCode usage notes:
+ * * General
+ *     * No error checking is provided on RateCodes, so usage of invalid values
+ *       or rates not supported by HW can result in undefined operation.
+ *     * Some values are not allowed by Std, but are included to sanitize the
+ *       table;
+ *     * MaxPwr should only be used for rates that can be sent using Max Power,
+ *       such as for TxEVM limits or regulatory. It is only valid for Host
+ *       Generated frames, and not for DRA, etc.
+ * * VHT
+ *     * Need to reconsile MU.
+ * * HT
+ *     * MCS and SS are made to mimic 11ac, so MCS=mcs[2:0] and SS=mcs[4:3];
+ *     * MCS32 is selected by providing MCS=10;
+ * * Legacy
+ *     * MCS0..7  = 6/9/12/18/24/36/48/54;
+ *     * MCS8..15 = 1S/1L/2S/2L/5.5S/5.5L/11S/11L;
+ *     * BW is used to request legacy duplicate modes;
+ */
+#define RATECODE_DEFAULT        0xFFFF  /* Don't override the Rate            */
+#define RATECODE_TYPE_MASK      0xC000  /* Mask  to extract Type              */
+#define RATECODE_TYPE_SHIFT     14      /* Shift to extract Type              */
+#define RATECODE_TYPE_VHT       0x8000  /* Use VHT rates                      */
+#define RATECODE_TYPE_HT        0x4000  /* Use HT rates                       */
+#define RATECODE_TYPE_LEGACY    0x0000  /* Use Legacy (a/b/g) rates           */
+#define RATECODE_MAXPWR         0x2000  /* Send at Max Power / Off Channel    */
+#define RATECODE_RSVD           0x1000  /* Unused                             */
+#define RATECODE_STBC           0x0800  /* Use Space Time Block Codes         */
+#define RATECODE_BFMR           0x0400  /* Use Beamforming                    */
+#define RATECODE_SS_MASK        0x0300  /* Mask  to extract nSS-1             */
+#define RATECODE_SS_SHIFT       8       /* Shift to extract nSS-1             */
+#define RATECODE_MCS_MASK       0x00F0  /* Mask  to extract MCS rate          */
+#define RATECODE_MCS_SHIFT      4       /* Shift to extract MCS rate          */
+#define RATECODE_BW_MASK        0x000C  /* Mask  to extract Channel BW        */
+#define RATECODE_BW_SHIFT       2       /* Shift to extract Channel BW        */
+#define RATECODE_BW_160MHZ      0x000C  /* Send 160M wide packet (or 80+80)   */
+#define RATECODE_BW_80MHZ       0x0008  /* Send  80M wide packet              */
+#define RATECODE_BW_40MHZ       0x0004  /* Send  40M wide packet              */
+#define RATECODE_BW_20MHZ       0x0000  /* Send  20M wide packet              */
+#define RATECODE_LDPC           0x0002  /* Use Low Density Parity Codes       */
+#define RATECODE_SGI            0x0001  /* Use Short Guard Interval           */
+
+#define TXRING_CTRL_LEN_SHIFT   0      /* PCIe Payload size (Starts w/ SNAP)  */
+#define TXRING_CTRL_LEN_MASK    0x3FFF /* PCIe Payload size (Starts w/ SNAP)  */
+#define TXRING_CTRL_QID_SHIFT   14     /* Queue ID (STA*UP, Mcast, MC2UC, etc)*/
+#define TXRING_CTRL_QID_MASK    0xFFF  /* Queue ID (STA*UP, Mcast, MC2UC, etc)*/
+#define TXRING_CTRL_TAG_SHIFT   26     /* Tags for special Processing         */
+#define TXRING_CTRL_TAG_MASK    0x3F   /* Tags for special Processing         */
+#define TXRING_CTRL_TAG_MGMT    0x01   /* Has Host generated dot11 Header     */
+#define TXRING_CTRL_TAG_EAP     0x02   /* Tag for EAPOL frames                */
+#define TXRING_CTRL_TAG_TCP_ACK 0x4
+#define TXRING_CTRL_TAG_RSVD    0x3C   /* Unused                              */
+
+struct tx_info { /* Tx INFO used by MAC HW */
+	__le32 reserved0[10];
+	__le32 rate_info;
+	__le32 reserved1[14];
+} __packed;
+
+struct pcie_tx_desc_ndp {
+	union { /* Union for Tx DA/SA or Mgmt Overrides */
+		struct { /* Fields for Data frames     */
+			u8 da[ETH_ALEN];  /* L2 Destination Address         */
+			u8 sa[ETH_ALEN];  /* L2 Source Address              */
+		};
+		struct { /* Fields when marked as Mgmt */
+			__le16 rate_code; /* Rate Code: Table + Index       */
+			u8 max_retry;
+			u8 pad[5];        /* Unused                         */
+			__le32 call_back; /* Used for Packet returned to FW */
+		};
+	} u;
+	__le32 ctrl; /* Bit fields (TXRING_CTRL_*)            */
+	__le32 data; /* PCIe Payload Pointer (Starts w/ SNAP) */
+	__le32 user; /* Value returned to Host when done      */
+	__le32 tcp_dst_src;
+	__le32 tcp_sn;
+} __packed;
+
+struct tx_ring_done {
+	__le32 user;
+} __packed;
+
+#define RXRING_CTRL_CASE_SHIFT  0     /* What is in the buffer(RXRING_CASE_*) */
+#define RXRING_CTRL_CASE_MASK   0x1F  /* What is in the buffer(RXRING_CASE_*) */
+#define RXRING_CTRL_STA_SHIFT   5     /* STA information (or Mcast group)     */
+#define RXRING_CTRL_STA_MASK    0x1FF /* STA information (or Mcast group)     */
+#define RXRING_CTRL_STA_UNKNOWN 0x1FF /* STA Idx for packets from Unknown STA */
+#define RXRING_CTRL_STA_FROMDS  0x1FE /* STA Idx for packets from DS          */
+#define RXRING_CTRL_TID_SHIFT   14    /* TID/UP for QoS Data frames           */
+#define RXRING_CTRL_TID_MASK    0xF   /* TID/UP for QoS Data frames           */
+#define RXRING_CTRL_KEY_SHIFT   18    /* Key Type used (KEY_TYPE_*)           */
+#define RXRING_CTRL_KEY_MASK    0xF   /* Key Type used (KEY_TYPE_*)           */
+#define RXRING_CTRL_TRUNC       (1UL<<31) /* Packet Truncated                 */
+
+/* Rx Buffer Formats
+ *    Each Case listed above will indicate the format used, and each format will
+ *    carry their length in the packet buffer. Should the packet be too big for
+ *    the buffer, it will be truncated, but the full length will still be
+ *    indicated. Currently only a single, fixed size Rx Pool is envisioned.
+ *
+ * Fmt0 is used for Slow path, when some processing of dot11 headers may still
+ * be required, or for promiscuous mode captures. It is in the HW RxINFO
+ * (rx_info_t) format including dot11_t followed by Payload. The Length field in
+ * the dot11_t is updated to only include Payload bytes, and is in Little Endian
+ * format. If the frame is too big, it is truncated to the buffer size, and
+ * promiscuous packets may also be configured for truncation to reduce load. The
+ * mark field is replaced with software status, and the RSSI will be updated to
+ * apply Rx calibration.
+ *
+ * Fmt1 is used for fast path Data packets in the run state, where all rx
+ * processing of dot11 headers is performed from radio FW. It has an AMSDU
+ * centric format of DA/SA/Len followed by SNAP, with the Length in Big Endian
+ * Format. In most cases conversion to Ethernet format is accomplished by
+ * copying 12 bytes to drop 8 bytes in the middle.
+ *
+ * Fmt2 is used for fast path AMSDU packets that are malformed. They just
+ * contain the dot11 header (dot11_t) containing the residual Len (Little
+ * Endian) after any valid MSDU have been extracted. The header is followed by
+ * the first invalid MSDU which will be truncated to 64 bytes.
+ */
+enum { /* What is in Rx Buffer and why it was delivered */
+	/* Data for Assoc Clients in Run State on Channel [Fmt1]              */
+	RXRING_CASE_FAST_DATA,
+	RXRING_CASE_FAST_BAD_AMSDU, /* Fast Data with bad AMSDU Header [Fmt2] */
+	/* Data for Assoc Clients using unconfigured queue [Fmt0]             */
+	RXRING_CASE_SLOW_NOQUEUE,
+	/* Data for Assoc Clients not matching Run State [Fmt0]               */
+	RXRING_CASE_SLOW_NORUN,
+	/* Data for filtered Multicast groups [Fmt0]                          */
+	RXRING_CASE_SLOW_MCAST,
+	RXRING_CASE_SLOW_BAD_STA,   /* Data for Unassoc Clients [Fmt0]        */
+	RXRING_CASE_SLOW_BAD_MIC,   /* Decrypt failure [Fmt0]                 */
+	RXRING_CASE_SLOW_BAD_PN,    /* Decrypt PN replay [Fmt0]               */
+	RXRING_CASE_SLOW_MGMT,      /* Mgmt traffic to this AP or Bcast [Fmt0]*/
+	RXRING_CASE_SLOW_PROMISC,   /* Packets captured promiscuously [Fmt0]  */
+	RXRING_CASE_SLOW_DEL_DONE,  /* Client has been deleted [N/A]          */
+	RXRING_CASE_DROP,           /* Buffer returned to Host [N/A]          */
+};
+
+enum { /* Type of Key */
+	KEY_TYPE_NONE,      /* Bypass (never stored in real keys)     */
+	KEY_TYPE_WEP40,     /* WEP with  40 bit key + 24 bit IV =  64 */
+	KEY_TYPE_WEP104,    /* WEP with 104 bit key + 24 bit IV = 128 */
+	KEY_TYPE_TKIP,      /* TKIP                                   */
+	KEY_TYPE_CCMP128,   /* CCMP with 128 bit Key                  */
+	KEY_TYPE_CCMP256,   /* CCMP with 256 bit Key + 16 byte MIC    */
+	KEY_TYPE_WAPI,      /* WAPI                                   */
+	KEY_TYPE_UNKNOWN,   /* Not known what key was used (Rx Only)  */
+	KEY_TYPE_GCMP128,   /* GCMP with 128 bit Key                  */
+	KEY_TYPE_GCMP256,   /* GCMP with 256 bit Key + 16 byte MIC    */
+};
+
+#define RXINFO_RSSI_X_SHIFT     24
+#define RXINFO_RSSI_X_MASK      0xFF
+#define RXINFO_HT_SIG1_SHIFT    0
+#define RXINFO_HT_SIG1_MASK     0xFFFFFF
+#define RXINFO_HT_SIG2_SHIFT    0
+#define RXINFO_HT_SIG2_MASK     0x3FFFF
+#define RXINFO_RATE_SHIFT       24
+#define RXINFO_RATE_MASK        0xFF
+#define RXINFO_NF_A_SHIFT       12
+#define RXINFO_NF_A_MASK        0xFFF
+#define RXINFO_NF_B_SHIFT       0
+#define RXINFO_NF_B_MASK        0xFFF
+#define RXINFO_NF_C_SHIFT       12
+#define RXINFO_NF_C_MASK        0xFFF
+#define RXINFO_NF_D_SHIFT       0
+#define RXINFO_NF_D_MASK        0xFFF
+#define RXINFO_PARAM_SHIFT      0
+#define RXINFO_PARAM_MASK       0xFFFFFF
+
+struct rx_info { /* HW Rx buffer */
+	__le32 reserved0[2];
+	__le32 rssi_x;
+	__le32 reserved1[2];
+	__le32 ht_sig1;
+	__le32 ht_sig2_rate;
+	__le32 reserved2[6];
+	__le32 nf_a_b;
+	__le32 nf_c_d;
+	__le32 reserved3[6];
+	__le32 param;
+	__le32 reserved4[2];
+	__le32 hdr[0]; /* Len from HW includes rx_info w/ hdr */
+} __packed;
+
+struct pcie_rx_desc_ndp { /* ToNIC Rx Empty Buffer Ring Entry */
+	__le32 data; /* PCIe Payload Pointer               */
+	__le32 user; /* Value returned to Host when done   */
+} __packed;
+
+struct rx_ring_done { /* FromNIC Rx Done Ring Entry */
+	__le32 user; /* Value returned to Host when done   */
+	__le32 tsf;  /* Rx Radio Timestamp from MAC        */
+	__le32 ctrl; /* Bit fields (RXRING_CTRL_*)         */
+} __packed;
+
+struct pcie_desc_data_ndp {
+	dma_addr_t pphys_tx_ring;         /* ptr to first TX desc (phys.)    */
+	struct pcie_tx_desc_ndp *ptx_ring;/* ptr to first TX desc (virt.)    */
+	dma_addr_t pphys_rx_ring;         /* ptr to first RX desc (phys.)    */
+	struct pcie_rx_desc_ndp *prx_ring;/* ptr to first RX desc (virt.)    */
+	u32 wcb_base;                     /* FW base offset for registers    */
+	u32 rx_buf_size;                  /* length of the RX buffers        */
+	u32 tx_sent_tail;                 /* index to the TX desc FW used    */
+	u32 tx_sent_head;                 /* index to next TX desc to be used*/
+	u32 tx_done_tail;                 /* index to Tx Done queue tail     */
+	/* keept the skb owned by fw */
+	dma_addr_t pphys_tx_buflist[MAX_TX_RING_SEND_SIZE];
+	struct sk_buff *tx_vbuflist[MAX_TX_RING_SEND_SIZE];
+	u32 tx_vbuflist_idx;              /* idx to empty slot in tx_vbuflist*/
+	struct sk_buff *rx_vbuflist[MAX_NUM_RX_DESC];
+	struct tx_ring_done *ptx_ring_done;
+	dma_addr_t pphys_tx_ring_done; /* ptr to first TX done desc (phys.)  */
+	struct rx_ring_done *prx_ring_done;
+	dma_addr_t pphys_rx_ring_done; /* ptr to first RX done desc (phys.)  */
+	dma_addr_t pphys_acnt_ring;    /* ptr to first account record (phys.)*/
+	u8 *pacnt_ring;                /* ptr to first accounting record     */
+	u32 tx_desc_busy_cnt;
+	u8 *pacnt_buf;
+	u32 acnt_ring_size;
+};
+
+struct ndp_rx_counter {
+	u32 fast_data_cnt;
+	u32 fast_bad_amsdu_cnt;
+	u32 slow_noqueue_cnt;
+	u32 slow_norun_cnt;
+	u32 slow_mcast_cnt;
+	u32 slow_bad_sta_cnt;
+	u32 slow_bad_mic_cnt;
+	u32 slow_bad_pn_cnt;
+	u32 slow_mgmt_cnt;
+	u32 slow_promisc_cnt;
+	u32 drop_cnt;
+	u32 offch_promisc_cnt;
+	u32 mu_pkt_cnt;
+};
+
+/* KF2 - 88W8997 */
+#define PCIE_MAX_TXRX_BD                0x20
+/* PCIE read data pointer for queue 0 and 1 */
+#define PCIE_RD_DATA_PTR_Q0_Q1          0xC1A4  /* 0x8000C1A4          */
+/* PCIE read data pointer for queue 2 and 3 */
+#define PCIE_RD_DATA_PTR_Q2_Q3          0xC1A8  /* 0x8000C1A8          */
+/* PCIE write data pointer for queue 0 and 1 */
+#define PCIE_WR_DATA_PTR_Q0_Q1          0xC174  /* 0x8000C174          */
+/* PCIE write data pointer for queue 2 and 3 */
+#define PCIE_WR_DATA_PTR_Q2_Q3          0xC178  /* 0x8000C178          */
+
+/* TX buffer description read pointer */
+#define REG_TXBD_RDPTR                  PCIE_RD_DATA_PTR_Q0_Q1
+/* TX buffer description write pointer */
+#define REG_TXBD_WRPTR                  PCIE_WR_DATA_PTR_Q0_Q1
+
+#define PCIE_TX_START_PTR               16
+
+#define PCIE_TXBD_MASK                  0x0FFF0000
+#define PCIE_TXBD_WRAP_MASK             0x1FFF0000
+
+#define PCIE_BD_FLAG_RX_ROLLOVER_IND    BIT(12)
+#define PCIE_BD_FLAG_TX_START_PTR       BIT(16)
+#define PCIE_BD_FLAG_TX_ROLLOVER_IND    BIT(28)
+#define PCIE_BD_FLAG_TX2_START_PTR      BIT(0)
+#define PCIE_BD_FLAG_TX2_ROLLOVER_IND   BIT(12)
+
+#define PCIE_BD_FLAG_FIRST_DESC         BIT(0)
+#define PCIE_BD_FLAG_LAST_DESC          BIT(1)
+
+#define PCIE_TX_WCB_FLAGS_DONT_ENCRYPT  0x00000001
+#define PCIE_TX_WCB_FLAGS_NO_CCK_RATE   0x00000002
+
+#define PCIE_TXBD_NOT_FULL(wrptr, rdptr) \
+	(((wrptr & PCIE_TXBD_MASK) != (rdptr & PCIE_TXBD_MASK)) \
+	 || ((wrptr & PCIE_BD_FLAG_TX_ROLLOVER_IND) ==          \
+	     (rdptr & PCIE_BD_FLAG_TX_ROLLOVER_IND)))
+
+struct pcie_data_buf {
+	/* Buffer descriptor flags */
+	__le16 flags;
+	/* Offset of fragment/pkt to start of ip header */
+	__le16 offset;
+	/* Fragment length of the buffer */
+	__le16 frag_len;
+	/* Length of the buffer */
+	__le16 len;
+	/* Physical address of the buffer */
+	__le64 paddr;
+	/* Reserved */
+	__le32 reserved;
+} __packed;
+
+struct pcie_pfu_dma_data {
+	struct pcie_tx_desc tx_desc;
+	struct pcie_dma_data dma_data;
+} __packed;
+
+struct pcie_priv {
+	struct mwl_priv *mwl_priv;
+	struct pci_dev *pdev;
+	void __iomem *iobase0; /* MEM Base Address Register 0  */
+	void __iomem *iobase1; /* MEM Base Address Register 1  */
+	u32 next_bar_num;
+
+	struct sk_buff_head txq[PCIE_NUM_OF_DESC_DATA];
+
+	spinlock_t int_mask_lock ____cacheline_aligned_in_smp;
+	struct tasklet_struct tx_task;
+	struct tasklet_struct tx_done_task;
+	struct tasklet_struct rx_task;
+	struct tasklet_struct qe_task;
+	unsigned int tx_head_room;
+	int txq_limit;
+	int txq_wake_threshold;
+	bool is_tx_schedule;
+	bool is_tx_done_schedule;
+	int recv_limit;
+	bool is_rx_schedule;
+	bool is_qe_schedule;
+	u32 qe_trig_num;
+	unsigned long qe_trig_time;
+
+	/* various descriptor data */
+	/* for tx descriptor data  */
+	spinlock_t tx_desc_lock ____cacheline_aligned_in_smp;
+	struct pcie_desc_data desc_data[PCIE_NUM_OF_DESC_DATA];
+	int delay_q_idx;
+	struct sk_buff *delay_q[PCIE_DELAY_FREE_Q_LIMIT];
+	/* number of descriptors owned by fw at any one time */
+	int fw_desc_cnt[PCIE_NUM_OF_DESC_DATA];
+
+	/* new data path */
+	struct pcie_desc_data_ndp desc_data_ndp;
+	int tx_done_cnt;
+	struct ieee80211_sta *sta_link[SYSADPT_MAX_STA_SC4 + 1];
+	struct sk_buff_head rx_skb_trace;
+	struct ndp_rx_counter rx_cnts;
+	u32 rx_skb_unlink_err;
+	u32 signature_err;
+	u32 recheck_rxringdone;
+	u32 acnt_busy;
+	u32 acnt_wrap;
+	u32 acnt_drop;
+
+	/* KF2 - 88W8997 */
+	struct firmware *cal_data;
+	/* Write pointer for TXBD ring */
+	u32 txbd_wrptr;
+	/* Shadow copy of TXBD read pointer */
+	u32 txbd_rdptr;
+	/* TXBD ring size */
+	u32 txbd_ring_size;
+	/* Virtual base address of txbd_ring */
+	u8 *txbd_ring_vbase;
+	/* Physical base address of txbd_ring */
+	dma_addr_t txbd_ring_pbase;
+	/* Ring of buffer descriptors for TX */
+	struct pcie_data_buf *txbd_ring[PCIE_MAX_TXRX_BD];
+	struct sk_buff *tx_buf_list[PCIE_MAX_TXRX_BD];
+};
+
+enum { /* Definition of accounting record codes */
+	ACNT_CODE_BUSY = 0,   /* Marked busy until filled in                  */
+	ACNT_CODE_WRAP,       /* Used to pad when wrapping                    */
+	ACNT_CODE_DROP,       /* Count of dropped records                     */
+	ACNT_CODE_TX_ENQUEUE, /* TXINFO when added to TCQ (acnt_tx_s)         */
+	ACNT_CODE_RX_PPDU,    /* RXINFO for each PPDu (acnt_rx_s)             */
+	ACNT_CODE_TX_FLUSH,   /* Flush Tx Queue                               */
+	ACNT_CODE_RX_RESET,   /* Channel Change / Rx Reset                    */
+	ACNT_CODE_TX_RESET,   /* TCQ reset                                    */
+	ACNT_CODE_QUOTE_LEVEL,/* Quota Level changes                          */
+	ACNT_CODE_TX_DONE,    /* Tx status when done                          */
+	ACNT_CODE_RA_STATS,   /* rateinfo PER (acnt_ra_s)                     */
+	ACNT_CODE_BA_STATS,   /* BA stats (acnt_ba_s)                         */
+	ACNT_CODE_BF_MIMO_CTRL,/* BF Mimo Ctrl Field Log (acnt_bf_mimo_ctrl_s)*/
+};
+
+struct acnt_s { /* Baseline Accounting Record format */
+	__le16 code;          /* Unique code for each type                    */
+	u8 len;               /* Length in DWORDS, including header           */
+	u8 pad;               /* Alignment for generic, but specific can reuse*/
+	__le32 tsf;           /* Timestamp for Entry (when len>1)             */
+} __packed;
+
+struct acnt_tx_s { /* Accounting Record For Tx (at Enqueue time) */
+	__le16 code;          /* Unique code for each type                    */
+	u8 len;               /* Length in DWORDS, including header           */
+	u8 tcq;               /* Which TCQ was used                           */
+	__le32 tsf;           /* Timestamp for Entry (when len>1)             */
+	__le64 bitmap;        /* Map of SeqNr when AMPDU                      */
+	__le16 air_time;      /* Air Time used by PPDU                        */
+	__le16 npkts;         /* Number of Descriptors sent (AMPDU&AMSDU)     */
+	__le16 qid;           /* Transmit Queue ID                            */
+	__le16 latency;       /* Latency of oldest frame in AMPDU (128us)     */
+	__le16 rate1;         /* Rate Code for sending data                   */
+	__le16 rate2;         /* Rate Code for sending RTS/CTS protection     */
+	u8 rate_tbl_index;    /* Rate table index for this TxInfo rate        */
+	u8 type;              /* SU:0 or MU:1                                 */
+	u8 pad[1];            /* Unused                                       */
+	u8 retries;           /* Number of retries of oldest frame in AMPDU   */
+	__le32 tx_cnt;        /* No. of pkt sent                              */
+	struct tx_info tx_info;/* Transmit parameters used for 1st MPDU/AMPDU */
+	struct pcie_dma_data hdr;/* Dot11 header used for 1st MPDU in AMPDU   */
+	u8 payload[0];        /* Variable Payload by use case                 */
+} __packed;
+
+struct acnt_rx_s { /* Accounting Record for Rx PPDU */
+	__le16 code;          /* Unique code for each type                    */
+	u8 len;               /* Length in DWORDS, including header           */
+	u8 flags;             /* Flags (ACNTRX_*)                             */
+	__le32 tsf;           /* Timestamp for Entry (when len>1)             */
+	__le64 bitmap;        /* Map of SeqNr when AMPDU                      */
+	__le16 air_time;      /* Air Time used by PPDU (no CSMA overhead)     */
+	__le16 rate;          /* Rate Code for receiving data                 */
+	struct rx_info rx_info;/* Receive parameters from 1st valid MPDU/AMPDU*/
+} __packed;
+
+struct acnt_ra_s { /* Accounting Record w/ rateinfo PER */
+	__le16 code;          /* Unique code for each type                    */
+	u8 len;               /* Length in DWORDS, including header           */
+	u8 per;               /* PER for this rateinfo                        */
+	__le32 tsf;           /* Timestamp for Entry (when len>1)             */
+	__le16 stn_id;        /* sta index this rateinfo is tied to           */
+	u8 type;              /* SU:0 or MU:1                                 */
+	u8 rate_tbl_index;    /* ratetbl index                                */
+	__le32 rate_info;     /* rateinfo for this ratetbl index              */
+	__le32 tx_attempt_cnt;/* Total tx pkt during rate adapt interval      */
+} __packed;
+
+struct acnt_ba_s { /* Accounting Record w/ rateinfo PER */
+	__le16 code;          /* Unique code for each type                    */
+	u8 len;               /* Length in DWORDS, including header           */
+	u8 ba_hole;           /* Total missing pkt in a BA                    */
+	__le32 tsf;           /* Timestamp for Entry (when len>1)             */
+	__le16 stnid;         /* sta index for this BA                        */
+	u8 no_ba;             /* No BA received                               */
+	u8 ba_expected;       /* Total expected pkt to be BA'd                */
+	u8 type;              /* SU:0 or MU:1                                 */
+	u8 pad[3];            /* Unused                                       */
+} __packed;
+
+struct acnt_bf_mimo_ctrl_s {/* Accounting Record w/ BF MIMO Control Field Data*/
+	__le16 code;          /* Unique code for each type                    */
+	u8 len;               /* Length in DWORDS, including header           */
+	u8 type;              /* SU:0, MU:1                                   */
+	__le32 tsf;           /* Timestamp for Entry (when len>1)             */
+	u8 rec_mac[6];        /* Received Packet Source MAC Address           */
+	__le16 pad;           /* Padding                                      */
+	__le32 mimo_ctrl;     /* BF MIMO Control Field Data                   */
+	__le64 comp_bf_rep;   /* First 8 bytes of Compressed BF Report        */
+} __packed;
+
+static inline void pcie_tx_add_dma_header(struct mwl_priv *priv,
+					 struct sk_buff *skb,
+					 int head_pad,
+					 int tail_pad)
+{
+	struct ieee80211_hdr *wh;
+	int dma_hdrlen;
+	int hdrlen;
+	int reqd_hdrlen;
+	int needed_room;
+	struct pcie_dma_data *dma_data;
+
+	dma_hdrlen = (priv->chip_type == MWL8997) ?
+		sizeof(struct pcie_pfu_dma_data) :
+		sizeof(struct pcie_dma_data);
+
+	/* Add a firmware DMA header; the firmware requires that we
+	 * present a 2-byte payload length followed by a 4-address
+	 * header (without QoS field), followed (optionally) by any
+	 * WEP/ExtIV header (but only filled in for CCMP).
+	 */
+	wh = (struct ieee80211_hdr *)skb->data;
+
+	hdrlen = ieee80211_hdrlen(wh->frame_control);
+
+	reqd_hdrlen = dma_hdrlen + head_pad;
+
+	if (hdrlen != reqd_hdrlen) {
+		needed_room = reqd_hdrlen - hdrlen;
+		if (skb_headroom(skb) < needed_room) {
+			wiphy_debug(priv->hw->wiphy, "headroom is short: %d %d",
+				    skb_headroom(skb), needed_room);
+			skb_cow(skb, needed_room);
+		}
+		skb_push(skb, needed_room);
+	}
+
+	if (ieee80211_is_data_qos(wh->frame_control))
+		hdrlen -= IEEE80211_QOS_CTL_LEN;
+
+	if (priv->chip_type == MWL8997)
+		dma_data = &((struct pcie_pfu_dma_data *)skb->data)->dma_data;
+	else
+		dma_data = (struct pcie_dma_data *)skb->data;
+
+	if (wh != &dma_data->wh)
+		memmove(&dma_data->wh, wh, hdrlen);
+
+	if (hdrlen != sizeof(dma_data->wh))
+		memset(((void *)&dma_data->wh) + hdrlen, 0,
+		       sizeof(dma_data->wh) - hdrlen);
+
+	/* Firmware length is the length of the fully formed "802.11
+	 * payload".  That is, everything except for the 802.11 header.
+	 * This includes all crypto material including the MIC.
+	 */
+	dma_data->fwlen =
+		cpu_to_le16(skb->len - dma_hdrlen + tail_pad);
+}
+
+static inline void pcie_tx_encapsulate_frame(struct mwl_priv *priv,
+					     struct sk_buff *skb,
+					     struct ieee80211_key_conf *k_conf,
+					     bool *ccmp)
+{
+	int head_pad = 0;
+	int data_pad = 0;
+
+	/* Make sure the packet header is in the DMA header format (4-address
+	 * without QoS), and add head & tail padding when HW crypto is enabled.
+	 *
+	 * We have the following trailer padding requirements:
+	 * - WEP: 4 trailer bytes (ICV)
+	 * - TKIP: 12 trailer bytes (8 MIC + 4 ICV)
+	 * - CCMP: 8 trailer bytes (MIC)
+	 */
+
+	if (k_conf) {
+		head_pad = k_conf->iv_len;
+
+		switch (k_conf->cipher) {
+		case WLAN_CIPHER_SUITE_WEP40:
+		case WLAN_CIPHER_SUITE_WEP104:
+			data_pad = 4;
+			break;
+		case WLAN_CIPHER_SUITE_TKIP:
+			data_pad = 12;
+			break;
+		case WLAN_CIPHER_SUITE_CCMP:
+			data_pad = 8;
+			if (ccmp)
+				*ccmp = true;
+			break;
+		}
+	}
+
+	pcie_tx_add_dma_header(priv, skb, head_pad, data_pad);
+}
+
+static inline void pcie_tx_prepare_info(struct mwl_priv *priv, u32 rate,
+					struct ieee80211_tx_info *info)
+{
+	u32 format, bandwidth, short_gi, rate_id;
+
+	ieee80211_tx_info_clear_status(info);
+
+	info->status.rates[0].idx = -1;
+	info->status.rates[0].count = 0;
+	info->status.rates[0].flags = 0;
+	info->flags &= ~IEEE80211_TX_CTL_AMPDU;
+	info->flags |= IEEE80211_TX_STAT_ACK;
+
+	if (rate) {
+		/* Prepare rate information */
+		format = rate & MWL_TX_RATE_FORMAT_MASK;
+		bandwidth =
+			(rate & MWL_TX_RATE_BANDWIDTH_MASK) >>
+			MWL_TX_RATE_BANDWIDTH_SHIFT;
+		short_gi = (rate & MWL_TX_RATE_SHORTGI_MASK) >>
+			MWL_TX_RATE_SHORTGI_SHIFT;
+		rate_id = (rate & MWL_TX_RATE_RATEIDMCS_MASK) >>
+			MWL_TX_RATE_RATEIDMCS_SHIFT;
+
+		info->status.rates[0].idx = rate_id;
+		if (format == TX_RATE_FORMAT_LEGACY) {
+			if (priv->hw->conf.chandef.chan->hw_value >
+			    BAND_24_CHANNEL_NUM) {
+				info->status.rates[0].idx -= 5;
+			}
+		}
+		if (format == TX_RATE_FORMAT_11N)
+			info->status.rates[0].flags |=
+				IEEE80211_TX_RC_MCS;
+		if (format == TX_RATE_FORMAT_11AC)
+			info->status.rates[0].flags |=
+				IEEE80211_TX_RC_VHT_MCS;
+		if (bandwidth == TX_RATE_BANDWIDTH_40)
+			info->status.rates[0].flags |=
+				IEEE80211_TX_RC_40_MHZ_WIDTH;
+		if (bandwidth == TX_RATE_BANDWIDTH_80)
+			info->status.rates[0].flags |=
+				IEEE80211_TX_RC_80_MHZ_WIDTH;
+		if (bandwidth == TX_RATE_BANDWIDTH_160)
+			info->status.rates[0].flags |=
+				IEEE80211_TX_RC_160_MHZ_WIDTH;
+		if (short_gi == TX_RATE_INFO_SHORT_GI)
+			info->status.rates[0].flags |=
+				IEEE80211_TX_RC_SHORT_GI;
+		info->status.rates[0].count = 1;
+		info->status.rates[1].idx = -1;
+	}
+}
+
+static inline void pcie_tx_count_packet(struct ieee80211_sta *sta, u8 tid)
+{
+	struct mwl_sta *sta_info;
+	struct mwl_tx_info *tx_stats;
+
+	if (WARN_ON(tid >= SYSADPT_MAX_TID))
+		return;
+
+	sta_info = mwl_dev_get_sta(sta);
+
+	tx_stats = &sta_info->tx_stats[tid];
+
+	if (tx_stats->start_time == 0)
+		tx_stats->start_time = jiffies;
+
+	/* reset the packet count after each second elapses.  If the number of
+	 * packets ever exceeds the ampdu_min_traffic threshold, we will allow
+	 * an ampdu stream to be started.
+	 */
+	if (jiffies - tx_stats->start_time > HZ) {
+		tx_stats->pkts = 0;
+		tx_stats->start_time = jiffies;
+	} else {
+		tx_stats->pkts++;
+	}
+}
+
+static inline void pcie_rx_prepare_status(struct mwl_priv *priv, u16 format,
+					  u16 nss, u16 bw, u16 gi, u16 rate,
+					  struct ieee80211_rx_status *status)
+{
+#ifdef RX_ENC_FLAG_STBC_SHIFT
+	switch (format) {
+	case RX_RATE_INFO_FORMAT_11N:
+		status->encoding = RX_ENC_HT;
+		status->bw = RATE_INFO_BW_20;
+		if (bw == RX_RATE_INFO_HT40)
+			status->bw = RATE_INFO_BW_40;
+		if (gi == RX_RATE_INFO_SHORT_INTERVAL)
+			status->enc_flags |= RX_ENC_FLAG_SHORT_GI;
+		break;
+	case RX_RATE_INFO_FORMAT_11AC:
+		status->encoding = RX_ENC_VHT;
+		status->bw = RATE_INFO_BW_20;
+		if (bw == RX_RATE_INFO_HT40)
+			status->bw = RATE_INFO_BW_40;
+		if (bw == RX_RATE_INFO_HT80)
+			status->bw = RATE_INFO_BW_80;
+		if (bw == RX_RATE_INFO_HT160)
+			status->bw = RATE_INFO_BW_160;
+		if (gi == RX_RATE_INFO_SHORT_INTERVAL)
+			status->enc_flags |= RX_ENC_FLAG_SHORT_GI;
+		status->nss = (nss + 1);
+		break;
+	}
+#else
+	switch (format) {
+	case RX_RATE_INFO_FORMAT_11N:
+		status->flag |= RX_FLAG_HT;
+		if (bw == RX_RATE_INFO_HT40)
+			status->flag |= RX_FLAG_40MHZ;
+		if (gi == RX_RATE_INFO_SHORT_INTERVAL)
+			status->flag |= RX_FLAG_SHORT_GI;
+		break;
+	case RX_RATE_INFO_FORMAT_11AC:
+		status->flag |= RX_FLAG_VHT;
+		if (bw == RX_RATE_INFO_HT40)
+			status->flag |= RX_FLAG_40MHZ;
+		if (bw == RX_RATE_INFO_HT80)
+			status->vht_flag |= RX_VHT_FLAG_80MHZ;
+		if (bw == RX_RATE_INFO_HT160)
+			status->vht_flag |= RX_VHT_FLAG_160MHZ;
+		if (gi == RX_RATE_INFO_SHORT_INTERVAL)
+			status->flag |= RX_FLAG_SHORT_GI;
+		status->vht_nss = (nss + 1);
+		break;
+	}
+#endif
+	status->rate_idx = rate;
+
+	if (priv->hw->conf.chandef.chan->hw_value >
+	    BAND_24_CHANNEL_NUM) {
+		status->band = NL80211_BAND_5GHZ;
+#ifdef RX_ENC_FLAG_STBC_SHIFT
+		if ((!(status->encoding == RX_ENC_HT)) &&
+		    (!(status->encoding == RX_ENC_VHT))) {
+#else
+		if ((!(status->flag & RX_FLAG_HT)) &&
+		    (!(status->flag & RX_FLAG_VHT))) {
+#endif
+			status->rate_idx -= 5;
+			if (status->rate_idx >= BAND_50_RATE_NUM)
+				status->rate_idx = BAND_50_RATE_NUM - 1;
+		}
+	} else {
+		status->band = NL80211_BAND_2GHZ;
+#ifdef RX_ENC_FLAG_STBC_SHIFT
+		if ((!(status->encoding == RX_ENC_HT)) &&
+		    (!(status->encoding == RX_ENC_VHT))) {
+#else
+		if ((!(status->flag & RX_FLAG_HT)) &&
+		    (!(status->flag & RX_FLAG_VHT))) {
+#endif
+			if (status->rate_idx >= BAND_24_RATE_NUM)
+				status->rate_idx = BAND_24_RATE_NUM - 1;
+		}
+	}
+}
+
+static inline void pcie_rx_remove_dma_header(struct sk_buff *skb, __le16 qos)
+{
+	struct pcie_dma_data *dma_data;
+	int hdrlen;
+
+	dma_data = (struct pcie_dma_data *)skb->data;
+	hdrlen = ieee80211_hdrlen(dma_data->wh.frame_control);
+
+	if (hdrlen != sizeof(dma_data->wh)) {
+		if (ieee80211_is_data_qos(dma_data->wh.frame_control)) {
+			memmove(dma_data->data - hdrlen,
+				&dma_data->wh, hdrlen - 2);
+			*((__le16 *)(dma_data->data - 2)) = qos;
+		} else {
+			memmove(dma_data->data - hdrlen, &dma_data->wh, hdrlen);
+		}
+	}
+
+	if (hdrlen != sizeof(*dma_data))
+		skb_pull(skb, sizeof(*dma_data) - hdrlen);
+}
+
+static inline void pcie_mask_int(struct pcie_priv *pcie_priv,
+				 u32 mask_bit, bool set)
+{
+	unsigned long flags;
+	void __iomem *int_status_mask;
+	u32 status;
+
+	spin_lock_irqsave(&pcie_priv->int_mask_lock, flags);
+	int_status_mask = pcie_priv->iobase1 +
+		MACREG_REG_A2H_INTERRUPT_STATUS_MASK;
+	status = readl(int_status_mask);
+	if (set)
+		writel((status | mask_bit), int_status_mask);
+	else
+		writel((status & ~mask_bit), int_status_mask);
+	spin_unlock_irqrestore(&pcie_priv->int_mask_lock, flags);
+}
+
+#endif /* _DEV_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/fwdl.c b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/fwdl.c
new file mode 100644
index 000000000000..939ed54133c7
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/fwdl.c
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements firmware download related
+ * functions.
+ */
+
+#include <linux/io.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "hif/fwcmd.h"
+#include "hif/pcie/dev.h"
+#include "hif/pcie/sc4_ddr.h"
+#include "hif/pcie/fwdl.h"
+
+#define FW_DOWNLOAD_BLOCK_SIZE          256
+#define FW_CHECK_MSECS                  3
+
+#define FW_MAX_NUM_CHECKS               0xffff
+
+static void pcie_trigger_pcicmd_bootcode(struct pcie_priv *pcie_priv)
+{
+	writel(pcie_priv->mwl_priv->pphys_cmd_buf,
+	       pcie_priv->iobase1 + MACREG_REG_GEN_PTR);
+	writel(0x00, pcie_priv->iobase1 + MACREG_REG_INT_CODE);
+	writel(MACREG_H2ARIC_BIT_DOOR_BELL,
+	       pcie_priv->iobase1 + MACREG_REG_H2A_INTERRUPT_EVENTS);
+}
+
+static bool pcie_download_ddr_init(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = (struct pcie_priv *)priv->hif.priv;
+	u32 size_ddr_init = sizeof(sc4_ddr_init);
+	u8 *p = (u8 *)&sc4_ddr_init[0];
+	u32 curr_iteration = 0;
+	u32 size_ddr_init_downloaded = 0;
+	u32 int_code = 0;
+	u32 len = 0;
+
+	/* download ddr init code */
+	wiphy_debug(priv->hw->wiphy, "ddr init: download start\n");
+
+	while (size_ddr_init_downloaded < size_ddr_init) {
+		len = readl(pcie_priv->iobase1 + 0xc40);
+
+		if (!len)
+			break;
+
+		/* this copies the next chunk of fw binary to be delivered */
+		memcpy((char *)&priv->pcmd_buf[0], p, len);
+		/* this is arbitrary per your platform; we use 0xffff */
+		curr_iteration = (FW_MAX_NUM_CHECKS * 500);
+		/* this function writes pdata to c10, then write 2 to c18 */
+		pcie_trigger_pcicmd_bootcode(pcie_priv);
+
+		/* NOTE: the following back to back checks on C1C is time
+		 * sensitive, hence may need to be tweaked dependent on host
+		 * processor. Time for SC2 to go from the write of event 2 to
+		 * C1C == 2 is ~1300 nSec. Hence the checkings on host has to
+		 * consider how efficient your code can be to meet this timing,
+		 * or you can alternatively tweak this routines to fit your
+		 * platform
+		 */
+		do {
+			int_code = readl(pcie_priv->iobase1 + 0xc1c);
+			if (int_code != 0)
+				break;
+			cond_resched();
+			curr_iteration--;
+		} while (curr_iteration);
+
+		do {
+			int_code = readl(pcie_priv->iobase1 + 0xc1c);
+			if ((int_code & MACREG_H2ARIC_BIT_DOOR_BELL) !=
+			    MACREG_H2ARIC_BIT_DOOR_BELL)
+				break;
+			cond_resched();
+			curr_iteration--;
+		} while (curr_iteration);
+
+		if (curr_iteration == 0) {
+			/* This limited loop check allows you to exit gracefully
+			 * without locking up your entire system just because fw
+			 * download failed
+			 */
+			wiphy_err(priv->hw->wiphy,
+				  "Exhausted curr_iteration during download\n");
+			return false;
+		}
+
+		p += len;
+		size_ddr_init_downloaded += len;
+	}
+
+	wiphy_debug(priv->hw->wiphy, "ddr init: download complete\n");
+
+	return true;
+}
+
+void pcie_reset(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	u32 regval;
+
+	regval = readl(pcie_priv->iobase1 + MACREG_REG_INT_CODE);
+	if (regval == 0xffffffff) {
+		wiphy_err(priv->hw->wiphy, "adapter does not exist\n");
+		return;
+	}
+
+	writel(ISR_RESET, pcie_priv->iobase1 + MACREG_REG_H2A_INTERRUPT_EVENTS);
+}
+
+int pcie_download_firmware(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	const struct firmware *fw = priv->fw_ucode;
+	u32 curr_iteration = 0;
+	u32 size_fw_downloaded = 0;
+	u32 int_code = 0;
+	u32 len = 0;
+	u32 fwreadysignature = HOSTCMD_SOFTAP_FWRDY_SIGNATURE;
+
+	pcie_reset(hw);
+
+	/* FW before jumping to boot rom, it will enable PCIe transaction retry,
+	 * wait for boot code to stop it.
+	 */
+	usleep_range(FW_CHECK_MSECS * 1000, FW_CHECK_MSECS * 2000);
+
+	if (priv->chip_type == MWL8964) {
+		writel(MACREG_A2HRIC_BIT_MASK_NDP,
+		       pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_CLEAR_SEL);
+	} else {
+		writel(MACREG_A2HRIC_BIT_MASK,
+		       pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_CLEAR_SEL);
+	}
+	writel(0x00, pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_CAUSE);
+	writel(0x00, pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_MASK);
+	if (priv->chip_type == MWL8964) {
+		writel(MACREG_A2HRIC_BIT_MASK_NDP,
+		       pcie_priv->iobase1 +
+		       MACREG_REG_A2H_INTERRUPT_STATUS_MASK);
+	} else {
+		writel(MACREG_A2HRIC_BIT_MASK,
+		       pcie_priv->iobase1 +
+		       MACREG_REG_A2H_INTERRUPT_STATUS_MASK);
+	}
+
+	/* this routine interacts with SC2 bootrom to download firmware binary
+	 * to the device. After DMA'd to SC2, the firmware could be deflated to
+	 * reside on its respective blocks such as ITCM, DTCM, SQRAM,
+	 * (or even DDR, AFTER DDR is init'd before fw download
+	 */
+	wiphy_debug(hw->wiphy, "fw download start\n");
+
+	if (priv->chip_type != MWL8997)
+		/* Disable PFU before FWDL */
+		writel(0x100, pcie_priv->iobase1 + 0xE0E4);
+
+	/* make sure SCRATCH2 C40 is clear, in case we are too quick */
+	while (readl(pcie_priv->iobase1 + 0xc40) == 0)
+		cond_resched();
+
+	if (priv->chip_type == MWL8964) {
+		if (!pcie_download_ddr_init(priv)) {
+			wiphy_err(hw->wiphy,
+				  "ddr init: code download failed\n");
+			goto err_download;
+		}
+	}
+
+	while (size_fw_downloaded < fw->size) {
+		len = readl(pcie_priv->iobase1 + 0xc40);
+
+		if (!len)
+			break;
+
+		/* this copies the next chunk of fw binary to be delivered */
+		memcpy((char *)&priv->pcmd_buf[0],
+		       (fw->data + size_fw_downloaded), len);
+
+		/* this function writes pdata to c10, then write 2 to c18 */
+		pcie_trigger_pcicmd_bootcode(pcie_priv);
+
+		/* this is arbitrary per your platform; we use 0xffff */
+		curr_iteration = FW_MAX_NUM_CHECKS;
+
+		/* NOTE: the following back to back checks on C1C is time
+		 * sensitive, hence may need to be tweaked dependent on host
+		 * processor. Time for SC2 to go from the write of event 2 to
+		 * C1C == 2 is ~1300 nSec. Hence the checkings on host has to
+		 * consider how efficient your code can be to meet this timing,
+		 * or you can alternatively tweak this routines to fit your
+		 * platform
+		 */
+		do {
+			int_code = readl(pcie_priv->iobase1 + 0xc1c);
+			if ((int_code & MACREG_H2ARIC_BIT_DOOR_BELL) !=
+			    MACREG_H2ARIC_BIT_DOOR_BELL)
+				break;
+			cond_resched();
+			curr_iteration--;
+		} while (curr_iteration);
+
+		if (curr_iteration == 0) {
+			/* This limited loop check allows you to exit gracefully
+			 * without locking up your entire system just because fw
+			 * download failed
+			 */
+			wiphy_err(hw->wiphy,
+				  "Exhausted curr_iteration for fw download\n");
+			goto err_download;
+		}
+
+		size_fw_downloaded += len;
+	}
+
+	wiphy_debug(hw->wiphy,
+		    "FwSize = %d downloaded Size = %d curr_iteration %d\n",
+		    (int)fw->size, size_fw_downloaded, curr_iteration);
+
+	/* Now firware is downloaded successfully, so this part is to check
+	 * whether fw can properly execute to an extent that write back
+	 * signature to indicate its readiness to the host. NOTE: if your
+	 * downloaded fw crashes, this signature checking will fail. This
+	 * part is similar as SC1
+	 */
+	*((u32 *)&priv->pcmd_buf[1]) = 0;
+	pcie_trigger_pcicmd_bootcode(pcie_priv);
+	curr_iteration = FW_MAX_NUM_CHECKS;
+	do {
+		curr_iteration--;
+		writel(HOSTCMD_SOFTAP_MODE,
+		       pcie_priv->iobase1 + MACREG_REG_GEN_PTR);
+		usleep_range(FW_CHECK_MSECS * 1000, FW_CHECK_MSECS * 2000);
+		int_code = readl(pcie_priv->iobase1 + MACREG_REG_INT_CODE);
+		if (!(curr_iteration % 0xff) && (int_code != 0))
+			wiphy_err(hw->wiphy, "%x;", int_code);
+	} while ((curr_iteration) &&
+		 (int_code != fwreadysignature));
+
+	if (curr_iteration == 0) {
+		wiphy_err(hw->wiphy,
+			  "Exhausted curr_iteration for fw signature\n");
+		goto err_download;
+	}
+
+	wiphy_debug(hw->wiphy, "fw download complete\n");
+	writel(0x00, pcie_priv->iobase1 + MACREG_REG_INT_CODE);
+
+	return 0;
+
+err_download:
+
+	pcie_reset(hw);
+
+	return -EIO;
+}
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/fwdl.h b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/fwdl.h
new file mode 100644
index 000000000000..36a3311aa678
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/fwdl.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines firmware download related functions. */
+
+#ifndef _FWDL_H_
+#define _FWDL_H_
+
+void pcie_reset(struct ieee80211_hw *hw);
+int pcie_download_firmware(struct ieee80211_hw *hw);
+
+#endif /* _FWDL_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/pcie.c b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/pcie.c
new file mode 100644
index 000000000000..da55913c0570
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/pcie.c
@@ -0,0 +1,1645 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements functions needed for PCIe module. */
+
+#include <linux/module.h>
+#include <linux/etherdevice.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "utils.h"
+#include "vendor_cmd.h"
+#include "hif/fwcmd.h"
+#include "hif/pcie/dev.h"
+#include "hif/pcie/fwdl.h"
+#include "hif/pcie/tx.h"
+#include "hif/pcie/rx.h"
+#include "hif/pcie/tx_ndp.h"
+#include "hif/pcie/rx_ndp.h"
+
+#define PCIE_DRV_DESC "Marvell Mac80211 Wireless PCIE Network Driver"
+#define PCIE_DEV_NAME "Marvell 802.11ac PCIE Adapter"
+
+#define MAX_WAIT_FW_COMPLETE_ITERATIONS 2000
+#define CHECK_BA_TRAFFIC_TIME           300 /* msec */
+#define CHECK_TX_DONE_TIME              50  /* msec */
+
+static struct pci_device_id pcie_id_tbl[] = {
+	{ PCI_VDEVICE(MARVELL, 0x2a55),     .driver_data = MWL8864, },
+	{ PCI_VDEVICE(MARVELL, 0x2b38),     .driver_data = MWL8897, },
+	{ PCI_VDEVICE(MARVELL, 0x2b40),     .driver_data = MWL8964, },
+	{ PCI_VDEVICE(MARVELL_EXT, 0x2b42), .driver_data = MWL8997, },
+	{ },
+};
+
+static struct mwl_chip_info pcie_chip_tbl[] = {
+	[MWL8864] = {
+		.part_name	= "88W8864",
+		.fw_image	= "mwlwifi/88W8864.bin",
+		.cal_file	= NULL,
+		.txpwrlmt_file  = NULL,
+		.antenna_tx	= ANTENNA_TX_4_AUTO,
+		.antenna_rx	= ANTENNA_RX_4_AUTO,
+	},
+	[MWL8897] = {
+		.part_name	= "88W8897",
+		.fw_image	= "mwlwifi/88W8897.bin",
+		.cal_file	= NULL,
+		.txpwrlmt_file  = NULL,
+		.antenna_tx	= ANTENNA_TX_2,
+		.antenna_rx	= ANTENNA_RX_2,
+	},
+	[MWL8964] = {
+		.part_name	= "88W8964",
+		.fw_image	= "mwlwifi/88W8964.bin",
+		.cal_file	= NULL,
+		.txpwrlmt_file  = NULL,
+		.antenna_tx	= ANTENNA_TX_4_AUTO,
+		.antenna_rx	= ANTENNA_RX_4_AUTO,
+	},
+	[MWL8997] = {
+		.part_name	= "88W8997",
+		.fw_image	= "mwlwifi/88W8997.bin",
+		.cal_file	= "mwlwifi/WlanCalData_ext.conf",
+		.txpwrlmt_file  = "mwlwifi/txpwrlmt_cfg.conf",
+		.antenna_tx	= ANTENNA_TX_2,
+		.antenna_rx	= ANTENNA_RX_2,
+	},
+};
+
+static int pcie_alloc_resource(struct pcie_priv *pcie_priv)
+{
+	struct pci_dev *pdev = pcie_priv->pdev;
+	struct device *dev = &pdev->dev;
+	void __iomem *addr;
+
+	pcie_priv->next_bar_num = 1;	/* 32-bit */
+	if (pci_resource_flags(pdev, 0) & 0x04)
+		pcie_priv->next_bar_num = 2;	/* 64-bit */
+
+	addr = devm_ioremap_resource(dev, &pdev->resource[0]);
+	if (IS_ERR(addr)) {
+		pr_err("%s: cannot reserve PCI memory region 0\n",
+		       PCIE_DRV_NAME);
+		goto err;
+	}
+	pcie_priv->iobase0 = addr;
+	pr_debug("iobase0 = %p\n", pcie_priv->iobase0);
+
+	addr = devm_ioremap_resource(dev,
+				     &pdev->resource[pcie_priv->next_bar_num]);
+	if (IS_ERR(addr)) {
+		pr_err("%s: cannot reserve PCI memory region 1\n",
+		       PCIE_DRV_NAME);
+		goto err;
+	}
+	pcie_priv->iobase1 = addr;
+	pr_debug("iobase1 = %p\n", pcie_priv->iobase1);
+
+	return 0;
+
+err:
+	pr_err("pci alloc fail\n");
+
+	return -EIO;
+}
+
+static u32 pcie_read_mac_reg(struct pcie_priv *pcie_priv, u32 offset)
+{
+	struct mwl_priv *priv = pcie_priv->mwl_priv;
+
+	if (priv->chip_type == MWL8964) {
+		u32 *addr_val = kmalloc(64 * sizeof(u32), GFP_ATOMIC);
+		u32 val;
+
+		if (addr_val) {
+			mwl_fwcmd_get_addr_value(priv->hw,
+						 0x8000a000 + offset, 4,
+						 addr_val, 0);
+			val = addr_val[0];
+			kfree(addr_val);
+			return val;
+		}
+		return 0;
+	} else
+		return le32_to_cpu(*(__le32 *)
+		       (MAC_REG_ADDR_PCI(offset)));
+}
+
+static bool pcie_chk_adapter(struct pcie_priv *pcie_priv)
+{
+	struct mwl_priv *priv = pcie_priv->mwl_priv;
+	u32 regval;
+
+	regval = readl(pcie_priv->iobase1 + MACREG_REG_INT_CODE);
+
+	if (regval == 0xffffffff) {
+		wiphy_err(priv->hw->wiphy, "adapter does not exist\n");
+		return false;
+	}
+
+	if (priv->cmd_timeout)
+		wiphy_debug(priv->hw->wiphy, "MACREG_REG_INT_CODE: 0x%04x\n",
+			    regval);
+
+	return true;
+}
+
+static void pcie_send_cmd(struct pcie_priv *pcie_priv)
+{
+	writel(pcie_priv->mwl_priv->pphys_cmd_buf,
+	       pcie_priv->iobase1 + MACREG_REG_GEN_PTR);
+	writel(MACREG_H2ARIC_BIT_DOOR_BELL,
+	       pcie_priv->iobase1 + MACREG_REG_H2A_INTERRUPT_EVENTS);
+}
+
+static int pcie_wait_complete(struct mwl_priv *priv, unsigned short cmd)
+{
+	unsigned int curr_iteration = MAX_WAIT_FW_COMPLETE_ITERATIONS;
+	unsigned short int_code = 0;
+
+	do {
+		int_code = le16_to_cpu(*((__le16 *)&priv->pcmd_buf[0]));
+		usleep_range(1000, 2000);
+	} while ((int_code != cmd) && (--curr_iteration) && !priv->rmmod);
+
+	if (curr_iteration == 0) {
+		wiphy_err(priv->hw->wiphy, "cmd 0x%04x=%s timed out\n",
+			  cmd, mwl_fwcmd_get_cmd_string(cmd));
+		wiphy_err(priv->hw->wiphy, "return code: 0x%04x\n", int_code);
+		return -EIO;
+	}
+
+	if (priv->chip_type != MWL8997)
+		usleep_range(3000, 5000);
+
+	return 0;
+}
+
+static int pcie_init(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	const struct hostcmd_get_hw_spec *get_hw_spec;
+	struct hostcmd_set_hw_spec set_hw_spec;
+	int rc, i;
+
+	spin_lock_init(&pcie_priv->int_mask_lock);
+	tasklet_init(&pcie_priv->tx_task,
+		     (void *)pcie_tx_skbs, (unsigned long)hw);
+	tasklet_disable(&pcie_priv->tx_task);
+	tasklet_init(&pcie_priv->tx_done_task,
+		     (void *)pcie_tx_done, (unsigned long)hw);
+	tasklet_disable(&pcie_priv->tx_done_task);
+	spin_lock_init(&pcie_priv->tx_desc_lock);
+	tasklet_init(&pcie_priv->rx_task,
+		     (void *)pcie_rx_recv, (unsigned long)hw);
+	tasklet_disable(&pcie_priv->rx_task);
+	tasklet_init(&pcie_priv->qe_task,
+		     (void *)pcie_tx_flush_amsdu, (unsigned long)hw);
+	tasklet_disable(&pcie_priv->qe_task);
+	pcie_priv->txq_limit = PCIE_TX_QUEUE_LIMIT;
+	pcie_priv->txq_wake_threshold = PCIE_TX_WAKE_Q_THRESHOLD;
+	pcie_priv->is_tx_done_schedule = false;
+	pcie_priv->recv_limit = PCIE_RECEIVE_LIMIT;
+	pcie_priv->is_rx_schedule = false;
+	pcie_priv->is_qe_schedule = false;
+	pcie_priv->qe_trig_num = 0;
+	pcie_priv->qe_trig_time = jiffies;
+
+	rc = pcie_tx_init(hw);
+	if (rc) {
+		wiphy_err(hw->wiphy, "%s: fail to initialize TX\n",
+			  PCIE_DRV_NAME);
+		goto err_mwl_tx_init;
+	}
+
+	rc = pcie_rx_init(hw);
+	if (rc) {
+		wiphy_err(hw->wiphy, "%s: fail to initialize RX\n",
+			  PCIE_DRV_NAME);
+		goto err_mwl_rx_init;
+	}
+
+	/* get and prepare HW specifications */
+	get_hw_spec = mwl_fwcmd_get_hw_specs(hw);
+	if (!get_hw_spec) {
+		wiphy_err(hw->wiphy, "%s: fail to get HW specifications\n",
+			  PCIE_DRV_NAME);
+		goto err_get_hw_specs;
+	}
+	ether_addr_copy(&priv->hw_data.mac_addr[0],
+			get_hw_spec->permanent_addr);
+	pcie_priv->desc_data[0].wcb_base =
+		le32_to_cpu(get_hw_spec->wcb_base0) & 0x0000ffff;
+	for (i = 1; i < SYSADPT_TOTAL_TX_QUEUES; i++)
+		pcie_priv->desc_data[i].wcb_base =
+			le32_to_cpu(get_hw_spec->wcb_base[i - 1]) & 0x0000ffff;
+	pcie_priv->desc_data[0].rx_desc_read =
+		le32_to_cpu(get_hw_spec->rxpd_rd_ptr) & 0x0000ffff;
+	pcie_priv->desc_data[0].rx_desc_write =
+		le32_to_cpu(get_hw_spec->rxpd_wr_ptr) & 0x0000ffff;
+	priv->hw_data.fw_release_num = le32_to_cpu(get_hw_spec->fw_release_num);
+	priv->hw_data.hw_version = get_hw_spec->version;
+	if (priv->chip_type != MWL8997) {
+		writel(pcie_priv->desc_data[0].pphys_tx_ring,
+		       pcie_priv->iobase0 + pcie_priv->desc_data[0].wcb_base);
+		for (i = 1; i < SYSADPT_TOTAL_TX_QUEUES; i++)
+			writel(pcie_priv->desc_data[i].pphys_tx_ring,
+			       pcie_priv->iobase0 +
+			       pcie_priv->desc_data[i].wcb_base);
+	}
+	writel(pcie_priv->desc_data[0].pphys_rx_ring,
+	       pcie_priv->iobase0 + pcie_priv->desc_data[0].rx_desc_read);
+	writel(pcie_priv->desc_data[0].pphys_rx_ring,
+	       pcie_priv->iobase0 + pcie_priv->desc_data[0].rx_desc_write);
+
+	/* prepare and set HW specifications */
+	memset(&set_hw_spec, 0, sizeof(set_hw_spec));
+	if (priv->chip_type == MWL8997) {
+		set_hw_spec.wcb_base[0] =
+			cpu_to_le32(pcie_priv->txbd_ring_pbase);
+		set_hw_spec.tx_wcb_num_per_queue =
+			cpu_to_le32(PCIE_MAX_TXRX_BD);
+		set_hw_spec.num_tx_queues = cpu_to_le32(1);
+		set_hw_spec.features |= HW_SET_PARMS_FEATURES_HOST_PROBE_RESP;
+	} else {
+		set_hw_spec.wcb_base[0] =
+			cpu_to_le32(pcie_priv->desc_data[0].pphys_tx_ring);
+		for (i = 1; i < SYSADPT_TOTAL_TX_QUEUES; i++)
+			set_hw_spec.wcb_base[i] = cpu_to_le32(
+				pcie_priv->desc_data[i].pphys_tx_ring);
+		set_hw_spec.tx_wcb_num_per_queue =
+			cpu_to_le32(PCIE_MAX_NUM_TX_DESC);
+		set_hw_spec.num_tx_queues = cpu_to_le32(PCIE_NUM_OF_DESC_DATA);
+	}
+	set_hw_spec.total_rx_wcb = cpu_to_le32(PCIE_MAX_NUM_RX_DESC);
+	set_hw_spec.rxpd_wr_ptr =
+		cpu_to_le32(pcie_priv->desc_data[0].pphys_rx_ring);
+	rc = mwl_fwcmd_set_hw_specs(hw, &set_hw_spec);
+	if (rc) {
+		wiphy_err(hw->wiphy, "%s: fail to set HW specifications\n",
+			  PCIE_DRV_NAME);
+		goto err_set_hw_specs;
+	}
+
+	return rc;
+
+err_set_hw_specs:
+err_get_hw_specs:
+
+	pcie_rx_deinit(hw);
+
+err_mwl_rx_init:
+
+	pcie_tx_deinit(hw);
+
+err_mwl_tx_init:
+
+	wiphy_err(hw->wiphy, "%s: init fail\n", PCIE_DRV_NAME);
+
+	return rc;
+}
+
+static void pcie_deinit(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+
+	pcie_rx_deinit(hw);
+	pcie_tx_deinit(hw);
+	tasklet_kill(&pcie_priv->qe_task);
+	tasklet_kill(&pcie_priv->rx_task);
+	tasklet_kill(&pcie_priv->tx_done_task);
+	tasklet_kill(&pcie_priv->tx_task);
+	pcie_reset(hw);
+}
+
+static int pcie_get_info(struct ieee80211_hw *hw, char *buf, size_t size)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	char *p = buf;
+	int len = 0;
+
+	len += scnprintf(p + len, size - len, "iobase0: %p\n",
+			 pcie_priv->iobase0);
+	len += scnprintf(p + len, size - len, "iobase1: %p\n",
+			 pcie_priv->iobase1);
+	len += scnprintf(p + len, size - len,
+			 "tx limit: %d\n", pcie_priv->txq_limit);
+	len += scnprintf(p + len, size - len,
+			 "rx limit: %d\n", pcie_priv->recv_limit);
+	len += scnprintf(p + len, size - len,
+			 "qe trigger number: %d\n", pcie_priv->qe_trig_num);
+	return len;
+}
+
+static void pcie_enable_data_tasks(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+
+	tasklet_enable(&pcie_priv->tx_task);
+	tasklet_enable(&pcie_priv->tx_done_task);
+	tasklet_enable(&pcie_priv->rx_task);
+	tasklet_enable(&pcie_priv->qe_task);
+}
+
+static void pcie_disable_data_tasks(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+
+	tasklet_disable(&pcie_priv->tx_task);
+	tasklet_disable(&pcie_priv->tx_done_task);
+	tasklet_disable(&pcie_priv->rx_task);
+	tasklet_disable(&pcie_priv->qe_task);
+}
+
+static int pcie_exec_cmd(struct ieee80211_hw *hw, unsigned short cmd)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	bool busy = false;
+
+	might_sleep();
+
+	if (!pcie_chk_adapter(pcie_priv)) {
+		wiphy_err(priv->hw->wiphy, "adapter does not exist\n");
+		priv->in_send_cmd = false;
+		return -EIO;
+	}
+
+	if (!priv->in_send_cmd && !priv->rmmod) {
+		priv->in_send_cmd = true;
+		if (priv->dump_hostcmd)
+			wiphy_debug(priv->hw->wiphy, "send cmd 0x%04x=%s\n",
+				    cmd, mwl_fwcmd_get_cmd_string(cmd));
+		pcie_send_cmd(pcie_priv);
+		if (pcie_wait_complete(priv, 0x8000 | cmd)) {
+			wiphy_err(priv->hw->wiphy, "timeout: 0x%04x\n", cmd);
+			priv->in_send_cmd = false;
+			priv->cmd_timeout = true;
+			if (priv->heartbeat)
+				vendor_cmd_basic_event(
+					hw->wiphy,
+					MWL_VENDOR_EVENT_CMD_TIMEOUT);
+			return -EIO;
+		}
+	} else {
+		wiphy_warn(priv->hw->wiphy,
+			   "previous command is running or module removed\n");
+		busy = true;
+	}
+
+	if (!busy)
+		priv->in_send_cmd = false;
+
+	return 0;
+}
+
+static int pcie_get_irq_num(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+
+	return pcie_priv->pdev->irq;
+}
+
+static irqreturn_t pcie_isr(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	u32 int_status;
+
+	int_status = readl(pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_CAUSE);
+
+	if (int_status == 0x00000000)
+		return IRQ_NONE;
+
+	if (int_status == 0xffffffff) {
+		wiphy_warn(hw->wiphy, "card unplugged?\n");
+	} else {
+		writel(~int_status,
+		       pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_CAUSE);
+
+		if (int_status & MACREG_A2HRIC_BIT_TX_DONE) {
+			if (!pcie_priv->is_tx_done_schedule) {
+				pcie_mask_int(pcie_priv,
+					      MACREG_A2HRIC_BIT_TX_DONE, false);
+				tasklet_schedule(&pcie_priv->tx_done_task);
+				pcie_priv->is_tx_done_schedule = true;
+			}
+		}
+
+		if (int_status & MACREG_A2HRIC_BIT_RX_RDY) {
+			if (!pcie_priv->is_rx_schedule) {
+				pcie_mask_int(pcie_priv,
+					      MACREG_A2HRIC_BIT_RX_RDY, false);
+				tasklet_schedule(&pcie_priv->rx_task);
+				pcie_priv->is_rx_schedule = true;
+			}
+		}
+
+		if (int_status & MACREG_A2HRIC_BIT_RADAR_DETECT) {
+			wiphy_info(hw->wiphy, "radar detected by firmware\n");
+			ieee80211_radar_detected(hw);
+		}
+
+		if (int_status & MACREG_A2HRIC_BIT_QUE_EMPTY) {
+			if (!pcie_priv->is_qe_schedule) {
+				if (time_after(jiffies,
+					       (pcie_priv->qe_trig_time + 1))) {
+					pcie_mask_int(pcie_priv,
+					      MACREG_A2HRIC_BIT_QUE_EMPTY,
+					      false);
+					tasklet_schedule(&pcie_priv->qe_task);
+					pcie_priv->qe_trig_num++;
+					pcie_priv->is_qe_schedule = true;
+					pcie_priv->qe_trig_time = jiffies;
+				}
+			}
+		}
+
+		if (int_status & MACREG_A2HRIC_BIT_CHAN_SWITCH)
+			ieee80211_queue_work(hw, &priv->chnl_switch_handle);
+
+		if (int_status & MACREG_A2HRIC_BA_WATCHDOG)
+			ieee80211_queue_work(hw, &priv->watchdog_ba_handle);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void pcie_irq_enable(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+
+	if (pcie_chk_adapter(pcie_priv)) {
+		writel(0x00,
+		       pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_MASK);
+		writel(MACREG_A2HRIC_BIT_MASK,
+		       pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_MASK);
+	}
+}
+
+static void pcie_irq_disable(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+
+	if (pcie_chk_adapter(pcie_priv))
+		writel(0x00,
+		       pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_MASK);
+}
+
+static void pcie_timer_routine(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	static int cnt;
+	struct mwl_ampdu_stream *stream;
+	struct mwl_sta *sta_info;
+	struct mwl_tx_info *tx_stats;
+	struct mwl_ampdu_stream *rm_stream = NULL;
+	u32 rm_pkts = 0;
+	bool ba_full = true;
+	int i;
+
+	if ((++cnt * SYSADPT_TIMER_WAKEUP_TIME) < CHECK_BA_TRAFFIC_TIME)
+		return;
+	cnt = 0;
+	spin_lock_bh(&priv->stream_lock);
+	for (i = 0; i < priv->ampdu_num; i++) {
+		stream = &priv->ampdu[i];
+
+		if (stream->state == AMPDU_STREAM_ACTIVE) {
+			sta_info = mwl_dev_get_sta(stream->sta);
+			tx_stats = &sta_info->tx_stats[stream->tid];
+
+			if ((jiffies - tx_stats->start_time > HZ) &&
+			    (tx_stats->pkts < SYSADPT_AMPDU_PACKET_THRESHOLD)) {
+				if (rm_pkts) {
+					if (tx_stats->pkts < rm_pkts) {
+						rm_stream = stream;
+						rm_pkts = tx_stats->pkts;
+					}
+				} else {
+					rm_stream = stream;
+					rm_pkts = tx_stats->pkts;
+				}
+			}
+
+			if (jiffies - tx_stats->start_time > HZ) {
+				tx_stats->pkts = 0;
+				tx_stats->start_time = jiffies;
+			}
+		} else
+			ba_full = false;
+	}
+	if (ba_full && rm_stream) {
+		ieee80211_stop_tx_ba_session(rm_stream->sta,
+					     rm_stream->tid);
+		wiphy_debug(hw->wiphy, "Stop BA %pM\n", rm_stream->sta->addr);
+	}
+	spin_unlock_bh(&priv->stream_lock);
+}
+
+static void pcie_tx_return_pkts(struct ieee80211_hw *hw)
+{
+	pcie_tx_done((unsigned long)hw);
+}
+
+static struct device_node *pcie_get_device_node(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct device_node *dev_node;
+
+	dev_node = pci_bus_to_OF_node(pcie_priv->pdev->bus);
+	wiphy_info(priv->hw->wiphy, "device node: %s\n", dev_node->full_name);
+
+	return dev_node;
+}
+
+static void pcie_get_survey(struct ieee80211_hw *hw,
+			    struct mwl_survey_info *survey_info)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+
+	survey_info->filled = SURVEY_INFO_TIME |
+			      SURVEY_INFO_TIME_BUSY |
+			      SURVEY_INFO_TIME_TX |
+			      SURVEY_INFO_NOISE_DBM;
+	survey_info->time_period += pcie_read_mac_reg(pcie_priv, MCU_LAST_READ);
+	survey_info->time_busy += pcie_read_mac_reg(pcie_priv, MCU_CCA_CNT);
+	survey_info->time_tx += pcie_read_mac_reg(pcie_priv, MCU_TXPE_CNT);
+	survey_info->noise = priv->noise;
+}
+
+static int pcie_reg_access(struct ieee80211_hw *hw, bool write)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	u8 set;
+	u32 *addr_val;
+	int ret = 0;
+
+	set = write ? WL_SET : WL_GET;
+
+	switch (priv->reg_type) {
+	case MWL_ACCESS_RF:
+		ret = mwl_fwcmd_reg_rf(hw, set, priv->reg_offset,
+				       &priv->reg_value);
+		break;
+	case MWL_ACCESS_BBP:
+		ret = mwl_fwcmd_reg_bb(hw, set, priv->reg_offset,
+				       &priv->reg_value);
+		break;
+	case MWL_ACCESS_CAU:
+		ret = mwl_fwcmd_reg_cau(hw, set, priv->reg_offset,
+					&priv->reg_value);
+		break;
+	case MWL_ACCESS_ADDR0:
+		if (set == WL_GET)
+			priv->reg_value =
+				readl(pcie_priv->iobase0 + priv->reg_offset);
+		else
+			writel(priv->reg_value,
+			       pcie_priv->iobase0 + priv->reg_offset);
+		break;
+	case MWL_ACCESS_ADDR1:
+		if (set == WL_GET)
+			priv->reg_value =
+				readl(pcie_priv->iobase1 + priv->reg_offset);
+		else
+			writel(priv->reg_value,
+			       pcie_priv->iobase1 + priv->reg_offset);
+		break;
+	case MWL_ACCESS_ADDR:
+		addr_val = kzalloc(64 * sizeof(u32), GFP_KERNEL);
+		if (addr_val) {
+			addr_val[0] = priv->reg_value;
+			ret = mwl_fwcmd_get_addr_value(hw, priv->reg_offset,
+						       4, addr_val, set);
+			if ((!ret) && (set == WL_GET))
+				priv->reg_value = addr_val[0];
+			kfree(addr_val);
+		} else {
+			ret = -ENOMEM;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static struct mwl_hif_ops pcie_hif_ops = {
+	.driver_name           = PCIE_DRV_NAME,
+	.driver_version        = PCIE_DRV_VERSION,
+	.tx_head_room          = PCIE_MIN_BYTES_HEADROOM,
+	.ampdu_num             = PCIE_AMPDU_QUEUES,
+	.reset                 = pcie_reset,
+	.init                  = pcie_init,
+	.deinit                = pcie_deinit,
+	.get_info              = pcie_get_info,
+	.enable_data_tasks     = pcie_enable_data_tasks,
+	.disable_data_tasks    = pcie_disable_data_tasks,
+	.exec_cmd              = pcie_exec_cmd,
+	.get_irq_num           = pcie_get_irq_num,
+	.irq_handler           = pcie_isr,
+	.irq_enable            = pcie_irq_enable,
+	.irq_disable           = pcie_irq_disable,
+	.download_firmware     = pcie_download_firmware,
+	.timer_routine         = pcie_timer_routine,
+	.tx_xmit               = pcie_tx_xmit,
+	.tx_del_pkts_via_vif   = pcie_tx_del_pkts_via_vif,
+	.tx_del_pkts_via_sta   = pcie_tx_del_pkts_via_sta,
+	.tx_del_ampdu_pkts     = pcie_tx_del_ampdu_pkts,
+	.tx_del_sta_amsdu_pkts = pcie_tx_del_sta_amsdu_pkts,
+	.tx_return_pkts        = pcie_tx_return_pkts,
+	.get_device_node       = pcie_get_device_node,
+	.get_survey            = pcie_get_survey,
+	.reg_access            = pcie_reg_access,
+};
+
+static int pcie_init_ndp(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	const struct hostcmd_get_hw_spec *get_hw_spec;
+	struct hostcmd_set_hw_spec set_hw_spec;
+	int rc;
+
+	spin_lock_init(&pcie_priv->int_mask_lock);
+	tasklet_init(&pcie_priv->tx_task,
+		     (void *)pcie_tx_skbs_ndp, (unsigned long)hw);
+	tasklet_disable(&pcie_priv->tx_task);
+	spin_lock_init(&pcie_priv->tx_desc_lock);
+	tasklet_init(&pcie_priv->rx_task,
+		     (void *)pcie_rx_recv_ndp, (unsigned long)hw);
+	tasklet_disable(&pcie_priv->rx_task);
+	pcie_priv->txq_limit = TX_QUEUE_LIMIT;
+	pcie_priv->txq_wake_threshold = TX_WAKE_Q_THRESHOLD;
+	pcie_priv->is_tx_schedule = false;
+	pcie_priv->recv_limit = MAX_NUM_RX_DESC;
+	pcie_priv->is_rx_schedule = false;
+
+	rc = pcie_tx_init_ndp(hw);
+	if (rc) {
+		wiphy_err(hw->wiphy, "%s: fail to initialize TX\n",
+			  PCIE_DRV_NAME);
+		goto err_mwl_tx_init;
+	}
+
+	rc = pcie_rx_init_ndp(hw);
+	if (rc) {
+		wiphy_err(hw->wiphy, "%s: fail to initialize RX\n",
+			  PCIE_DRV_NAME);
+		goto err_mwl_rx_init;
+	}
+
+	/* get and prepare HW specifications */
+	get_hw_spec = mwl_fwcmd_get_hw_specs(hw);
+	if (!get_hw_spec) {
+		wiphy_err(hw->wiphy, "%s: fail to get HW specifications\n",
+			  PCIE_DRV_NAME);
+		goto err_get_hw_specs;
+	}
+	ether_addr_copy(&priv->hw_data.mac_addr[0],
+			get_hw_spec->permanent_addr);
+	priv->hw_data.fw_release_num = le32_to_cpu(get_hw_spec->fw_release_num);
+	priv->hw_data.hw_version = get_hw_spec->version;
+
+	/* prepare and set HW specifications */
+	memset(&set_hw_spec, 0, sizeof(set_hw_spec));
+	set_hw_spec.wcb_base[0] =
+		cpu_to_le32(pcie_priv->desc_data_ndp.pphys_tx_ring);
+	set_hw_spec.wcb_base[1] =
+		cpu_to_le32(pcie_priv->desc_data_ndp.pphys_tx_ring_done);
+	set_hw_spec.wcb_base[2] =
+		cpu_to_le32(pcie_priv->desc_data_ndp.pphys_rx_ring);
+	set_hw_spec.wcb_base[3] =
+		cpu_to_le32(pcie_priv->desc_data_ndp.pphys_rx_ring_done);
+	set_hw_spec.acnt_base_addr =
+		cpu_to_le32(pcie_priv->desc_data_ndp.pphys_acnt_ring);
+	set_hw_spec.acnt_buf_size =
+		cpu_to_le32(pcie_priv->desc_data_ndp.acnt_ring_size);
+	rc = mwl_fwcmd_set_hw_specs(hw, &set_hw_spec);
+	if (rc) {
+		wiphy_err(hw->wiphy, "%s: fail to set HW specifications\n",
+			  PCIE_DRV_NAME);
+		goto err_set_hw_specs;
+	}
+
+	return rc;
+
+err_set_hw_specs:
+err_get_hw_specs:
+
+	pcie_rx_deinit_ndp(hw);
+
+err_mwl_rx_init:
+
+	pcie_tx_deinit_ndp(hw);
+
+err_mwl_tx_init:
+
+	wiphy_err(hw->wiphy, "%s: init fail\n", PCIE_DRV_NAME);
+
+	return rc;
+}
+
+static void pcie_deinit_ndp(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+
+	pcie_rx_deinit_ndp(hw);
+	pcie_tx_deinit_ndp(hw);
+	tasklet_kill(&pcie_priv->rx_task);
+	tasklet_kill(&pcie_priv->tx_task);
+	pcie_reset(hw);
+}
+
+static int pcie_get_info_ndp(struct ieee80211_hw *hw, char *buf, size_t size)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	char *p = buf;
+	int len = 0;
+
+	len += scnprintf(p + len, size - len, "iobase0: %p\n",
+			 pcie_priv->iobase0);
+	len += scnprintf(p + len, size - len, "iobase1: %p\n",
+			 pcie_priv->iobase1);
+	len += scnprintf(p + len, size - len,
+			 "tx limit: %d\n", pcie_priv->txq_limit);
+	len += scnprintf(p + len, size - len,
+			 "rx limit: %d\n", pcie_priv->recv_limit);
+	return len;
+}
+
+static int pcie_get_tx_status_ndp(struct ieee80211_hw *hw, char *buf,
+				  size_t size)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	char *p = buf;
+	int len = 0;
+
+	len += scnprintf(p + len, size - len, "tx_done_cnt: %d\n",
+			 pcie_priv->tx_done_cnt);
+	len += scnprintf(p + len, size - len, "tx_desc_busy_cnt: %d\n",
+			 pcie_priv->desc_data_ndp.tx_desc_busy_cnt);
+	len += scnprintf(p + len, size - len, "tx_sent_head: %d\n",
+			 pcie_priv->desc_data_ndp.tx_sent_head);
+	len += scnprintf(p + len, size - len, "tx_sent_tail: %d\n",
+			 pcie_priv->desc_data_ndp.tx_sent_tail);
+	len += scnprintf(p + len, size - len, "tx_done_head: %d\n",
+			 readl(pcie_priv->iobase1 + MACREG_REG_TXDONEHEAD));
+	len += scnprintf(p + len, size - len, "tx_done_tail: %d\n",
+			 pcie_priv->desc_data_ndp.tx_done_tail);
+	len += scnprintf(p + len, size - len, "tx_vbuflist_idx: %d\n",
+			 pcie_priv->desc_data_ndp.tx_vbuflist_idx);
+	return len;
+}
+
+static int pcie_get_rx_status_ndp(struct ieee80211_hw *hw, char *buf,
+				  size_t size)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	char *p = buf;
+	int len = 0;
+
+	len += scnprintf(p + len, size - len, "rx_done_head: %d\n",
+			 readl(pcie_priv->iobase1 + MACREG_REG_RXDONEHEAD));
+	len += scnprintf(p + len, size - len, "rx_done_tail: %d\n",
+			 readl(pcie_priv->iobase1 + MACREG_REG_RXDONETAIL));
+	len += scnprintf(p + len, size - len, "rx_desc_head: %d\n",
+			 readl(pcie_priv->iobase1 + MACREG_REG_RXDESCHEAD));
+	len += scnprintf(p + len, size - len, "rx_skb_trace: %d\n",
+			 skb_queue_len(&pcie_priv->rx_skb_trace));
+	len += scnprintf(p + len, size - len, "rx_skb_unlink_err: %d\n",
+			 pcie_priv->rx_skb_unlink_err);
+	len += scnprintf(p + len, size - len, "signature_err: %d\n",
+			 pcie_priv->signature_err);
+	len += scnprintf(p + len, size - len, "recheck_rxringdone: %d\n",
+			 pcie_priv->recheck_rxringdone);
+	len += scnprintf(p + len, size - len, "fast_data_cnt: %d\n",
+			 pcie_priv->rx_cnts.fast_data_cnt);
+	len += scnprintf(p + len, size - len, "fast_bad_amsdu_cnt: %d\n",
+			 pcie_priv->rx_cnts.fast_bad_amsdu_cnt);
+	len += scnprintf(p + len, size - len, "slow_noqueue_cnt: %d\n",
+			 pcie_priv->rx_cnts.slow_noqueue_cnt);
+	len += scnprintf(p + len, size - len, "slow_norun_cnt: %d\n",
+			 pcie_priv->rx_cnts.slow_norun_cnt);
+	len += scnprintf(p + len, size - len, "slow_mcast_cnt: %d\n",
+			 pcie_priv->rx_cnts.slow_mcast_cnt);
+	len += scnprintf(p + len, size - len, "slow_bad_sta_cnt: %d\n",
+			 pcie_priv->rx_cnts.slow_bad_sta_cnt);
+	len += scnprintf(p + len, size - len, "slow_bad_mic_cnt: %d\n",
+			 pcie_priv->rx_cnts.slow_bad_mic_cnt);
+	len += scnprintf(p + len, size - len, "slow_bad_pn_cnt: %d\n",
+			 pcie_priv->rx_cnts.slow_bad_pn_cnt);
+	len += scnprintf(p + len, size - len, "slow_mgmt_cnt: %d\n",
+			 pcie_priv->rx_cnts.slow_mgmt_cnt);
+	len += scnprintf(p + len, size - len, "slow_promisc_cnt: %d\n",
+			 pcie_priv->rx_cnts.slow_promisc_cnt);
+	len += scnprintf(p + len, size - len, "drop_cnt: %d\n",
+			 pcie_priv->rx_cnts.drop_cnt);
+	len += scnprintf(p + len, size - len, "offch_promisc_cnt: %d\n",
+			 pcie_priv->rx_cnts.offch_promisc_cnt);
+	len += scnprintf(p + len, size - len, "mu_pkt_cnt: %d\n",
+			 pcie_priv->rx_cnts.mu_pkt_cnt);
+	return len;
+}
+
+static void pcie_enable_data_tasks_ndp(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+
+	tasklet_enable(&pcie_priv->tx_task);
+	tasklet_enable(&pcie_priv->rx_task);
+}
+
+static void pcie_disable_data_tasks_ndp(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+
+	tasklet_disable(&pcie_priv->tx_task);
+	tasklet_disable(&pcie_priv->rx_task);
+}
+
+static irqreturn_t pcie_isr_ndp(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	u32 int_status;
+
+	int_status = readl(pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_CAUSE);
+
+	if (int_status == 0x00000000)
+		return IRQ_NONE;
+
+	if (int_status == 0xffffffff) {
+		wiphy_warn(hw->wiphy, "card unplugged?\n");
+	} else {
+		writel(~int_status,
+		       pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_CAUSE);
+
+		if (int_status & MACREG_A2HRIC_ACNT_HEAD_RDY)
+			ieee80211_queue_work(hw, &priv->account_handle);
+
+		if (int_status & MACREG_A2HRIC_RX_DONE_HEAD_RDY) {
+			if (!pcie_priv->is_rx_schedule) {
+				pcie_mask_int(pcie_priv,
+					      MACREG_A2HRIC_RX_DONE_HEAD_RDY,
+					      false);
+				tasklet_schedule(&pcie_priv->rx_task);
+				pcie_priv->is_rx_schedule = true;
+			}
+		}
+
+		if (int_status & MACREG_A2HRIC_NEWDP_DFS) {
+			wiphy_info(hw->wiphy, "radar detected by firmware\n");
+			ieee80211_radar_detected(hw);
+		}
+
+		if (int_status & MACREG_A2HRIC_NEWDP_CHANNEL_SWITCH)
+			ieee80211_queue_work(hw, &priv->chnl_switch_handle);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void pcie_irq_enable_ndp(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+
+	if (pcie_chk_adapter(pcie_priv)) {
+		writel(0x00,
+		       pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_MASK);
+		writel(MACREG_A2HRIC_BIT_MASK_NDP,
+		       pcie_priv->iobase1 + MACREG_REG_A2H_INTERRUPT_MASK);
+	}
+}
+
+static void pcie_timer_routine_ndp(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int num = SYSADPT_TX_WMM_QUEUES;
+	static int cnt;
+
+	if (!pcie_priv->is_tx_schedule) {
+		while (num--) {
+			if (skb_queue_len(&pcie_priv->txq[num]) > 0) {
+				tasklet_schedule(&pcie_priv->tx_task);
+				pcie_priv->is_tx_schedule = true;
+				break;
+			}
+		}
+	}
+
+	if ((++cnt * SYSADPT_TIMER_WAKEUP_TIME) >= CHECK_TX_DONE_TIME) {
+		pcie_tx_done_ndp(hw);
+		cnt = 0;
+	}
+}
+
+static void pcie_tx_return_pkts_ndp(struct ieee80211_hw *hw)
+{
+	pcie_tx_done_ndp(hw);
+}
+
+static void pcie_set_sta_id(struct ieee80211_hw *hw,
+			    struct ieee80211_sta *sta,
+			    bool sta_mode, bool set)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct mwl_sta *sta_info;
+	u16 stnid;
+
+	sta_info = mwl_dev_get_sta(sta);
+	stnid = sta_mode ? 0 : sta_info->stnid;
+	pcie_priv->sta_link[stnid] = set ? sta : NULL;
+}
+
+static void pcie_tx_account(struct mwl_priv *priv,
+			    struct mwl_sta *sta_info,
+			    struct acnt_tx_s *acnt_tx)
+{
+	u32 rate_info, tx_cnt;
+	u8 index, type, rate_ac, format, bw, gi, mcs, nss;
+	u16 ratemask;
+	u8 i, found;
+	struct mwl_tx_hist *tx_hist;
+	struct mwl_tx_hist_data *tx_hist_data;
+
+	rate_info = le32_to_cpu(acnt_tx->tx_info.rate_info);
+	tx_cnt = le32_to_cpu(acnt_tx->tx_cnt);
+	index = acnt_tx->rate_tbl_index;
+	type = acnt_tx->type;
+
+	if (!rate_info)
+		return;
+	sta_info->tx_rate_info = rate_info;
+
+	tx_hist = &sta_info->tx_hist;
+	if (!tx_hist || (type >= SU_MU_TYPE_CNT))
+		return;
+
+	format = rate_info & MWL_TX_RATE_FORMAT_MASK;
+	bw = (rate_info & MWL_TX_RATE_BANDWIDTH_MASK) >>
+		MWL_TX_RATE_BANDWIDTH_SHIFT;
+	gi = (rate_info & MWL_TX_RATE_SHORTGI_MASK) >>
+		MWL_TX_RATE_SHORTGI_SHIFT;
+	mcs = (rate_info & MWL_TX_RATE_RATEIDMCS_MASK) >>
+		MWL_TX_RATE_RATEIDMCS_SHIFT;
+
+	tx_hist->cur_rate_info[type] = rate_info;
+
+	/* Rate table index is valid */
+	if (index != 0xff) {
+		if (type == MU_MIMO) {
+			rate_ac = mcs & 0xf;
+			nss = mcs >> 4;
+			if (nss < (QS_NUM_SUPPORTED_11AC_NSS - 1)) {
+				tx_hist_data =
+					&tx_hist->mu_rate[nss][bw][gi][rate_ac];
+				tx_hist_data->rateinfo = rate_info;
+				tx_hist_data->cnt++;
+				tx_hist->total_tx_cnt[type] += tx_cnt;
+			}
+		} else {
+			/* If legacy, skip legacy preamble bit 15 */
+			if (format == TX_RATE_FORMAT_LEGACY)
+				ratemask = 0xfff;
+			else
+				ratemask = 0xffff;
+			tx_hist_data = &tx_hist->su_rate[0];
+			if ((tx_hist_data[index].rateinfo & ratemask) ==
+			    (rate_info & ratemask)) {
+				tx_hist_data[index].cnt++;
+				tx_hist->total_tx_cnt[type] += tx_cnt;
+			}
+		}
+	} else {
+		if (type == MU_MIMO) {
+			rate_ac = mcs & 0xf;
+			nss = mcs >> 4;
+			if (nss < (QS_NUM_SUPPORTED_11AC_NSS - 1)) {
+				tx_hist_data =
+					&tx_hist->mu_rate[nss][bw][gi][rate_ac];
+				tx_hist_data->rateinfo = rate_info;
+				tx_hist_data->cnt++;
+				tx_hist->total_tx_cnt[type] += tx_cnt;
+			}
+		} else {
+			/* If legacy, skip legacy preamble bit 15 */
+			if (format == TX_RATE_FORMAT_LEGACY)
+				ratemask = 0xfff;
+			else
+				ratemask = 0xffff;
+			tx_hist_data = &tx_hist->custom_rate[0];
+			/* Go through non rate table buffer to see if any has
+			 * been used. If all used up, recycle by using index 0
+			 */
+			for (i = 0; i < TX_RATE_HISTO_CUSTOM_CNT; i++) {
+				if (!tx_hist_data[i].rateinfo ||
+				    ((tx_hist_data[i].rateinfo & ratemask) ==
+				    (rate_info & ratemask))) {
+					found = 1;
+					break;
+				}
+			}
+			if (found)
+				index = i;
+			else
+				index = 0; /* reuse index 0 buffer */
+			tx_hist_data[index].rateinfo = rate_info;
+			tx_hist_data[index].cnt++;
+			tx_hist->total_tx_cnt[type] += tx_cnt;
+		}
+	}
+}
+
+static void pcie_rx_account(struct mwl_priv *priv,
+			    struct mwl_sta *sta_info,
+			    struct acnt_rx_s *acnt_rx)
+{
+	u32 sig1, sig2, rate, param;
+	u16 format, nss, bw, gi, rate_mcs;
+
+	sig1 = (le32_to_cpu(acnt_rx->rx_info.ht_sig1) >>
+		RXINFO_HT_SIG1_SHIFT) & RXINFO_HT_SIG1_MASK;
+	sig2 = (le32_to_cpu(acnt_rx->rx_info.ht_sig2_rate) >>
+		RXINFO_HT_SIG2_SHIFT) & RXINFO_HT_SIG2_MASK;
+	rate = (le32_to_cpu(acnt_rx->rx_info.ht_sig2_rate) >>
+		RXINFO_RATE_SHIFT) & RXINFO_RATE_MASK;
+	param = (le32_to_cpu(acnt_rx->rx_info.param) >>
+		RXINFO_PARAM_SHIFT) & RXINFO_PARAM_MASK;
+
+	format = (param >> 3) & 0x7;
+	nss = 0;
+	bw = RX_RATE_INFO_HT20;
+	switch (format) {
+	case RX_RATE_INFO_FORMAT_11A:
+		rate_mcs = rate & 0xF;
+		if (rate_mcs == 10)
+			rate_mcs = 7; /* 12 Mbps */
+		else
+			rate_mcs = utils_get_rate_id(rate_mcs);
+		gi = RX_RATE_INFO_SHORT_INTERVAL;
+		if ((rate_mcs == 5) || (rate_mcs == 7) || (rate_mcs == 9))
+			return;
+		break;
+	case RX_RATE_INFO_FORMAT_11B:
+		rate_mcs = utils_get_rate_id(rate & 0xF);
+		gi = RX_RATE_INFO_LONG_INTERVAL;
+		if ((rate_mcs == 0) || (rate_mcs == 1))
+			return;
+		break;
+	case RX_RATE_INFO_FORMAT_11N:
+		if ((sig1 & 0x3f) >= 16)
+			return;
+		bw = (sig1 >> 7) & 0x1;
+		gi = (sig2 >> 7) & 0x1;
+		rate_mcs = sig1 & 0x3F;
+		if (rate_mcs > 76)
+			return;
+		break;
+	case RX_RATE_INFO_FORMAT_11AC:
+		if (((sig2 >> 4) & 0xf) >= 10)
+			return;
+		nss = (sig1 >> 10) & 0x3;
+		if (!nss)
+			return;
+		bw = sig1 & 0x3;
+		gi = sig2 & 0x1;
+		rate_mcs = (sig2 >> 4) & 0xF;
+		if (rate_mcs > 9)
+			return;
+		break;
+	default:
+		return;
+	}
+
+	sta_info->rx_format = format;
+	sta_info->rx_nss = nss;
+	sta_info->rx_bw = bw;
+	sta_info->rx_gi = gi;
+	sta_info->rx_rate_mcs = rate_mcs;
+	sta_info->rx_signal = ((le32_to_cpu(acnt_rx->rx_info.rssi_x) >>
+		RXINFO_RSSI_X_SHIFT) & RXINFO_RSSI_X_MASK);
+}
+
+static void pcie_tx_per(struct mwl_priv *priv, struct mwl_sta *sta_info,
+			struct acnt_ra_s *acnt_ra)
+{
+	u32 rate_info;
+	u8 index, per, type, rate_ac, per_index, format, bw, gi, mcs, nss;
+	u16 ratemask;
+	u8 i, found;
+	struct mwl_tx_hist *tx_hist;
+	struct mwl_tx_hist_data *tx_hist_data;
+
+	rate_info = le32_to_cpu(acnt_ra->rate_info);
+	index = acnt_ra->rate_tbl_index;
+	per = acnt_ra->per;
+	type = acnt_ra->type;
+
+	tx_hist = &sta_info->tx_hist;
+
+	if (!tx_hist || !rate_info || (type >= SU_MU_TYPE_CNT))
+		return;
+
+	if ((type == SU_MIMO) && (index >= MAX_SUPPORTED_RATES) &&
+	    (index != 0xFF))
+		return;
+
+	if (per >= TX_HISTO_PER_THRES[3])
+		per_index = 4;
+	else if (per >= TX_HISTO_PER_THRES[2])
+		per_index = 3;
+	else if (per >= TX_HISTO_PER_THRES[1])
+		per_index = 2;
+	else if (per >= TX_HISTO_PER_THRES[0])
+		per_index = 1;
+	else
+		per_index = 0;
+
+	format = rate_info & MWL_TX_RATE_FORMAT_MASK;
+	bw = (rate_info & MWL_TX_RATE_BANDWIDTH_MASK) >>
+		MWL_TX_RATE_BANDWIDTH_SHIFT;
+	gi = (rate_info & MWL_TX_RATE_SHORTGI_MASK) >>
+		MWL_TX_RATE_SHORTGI_SHIFT;
+	mcs = (rate_info & MWL_TX_RATE_RATEIDMCS_MASK) >>
+		MWL_TX_RATE_RATEIDMCS_SHIFT;
+
+	/* Rate table index is valid */
+	if (index != 0xff) {
+		if (type == MU_MIMO) {
+			rate_ac = mcs & 0xf;
+			nss = mcs >> 4;
+			if (nss < (QS_NUM_SUPPORTED_11AC_NSS - 1)) {
+				tx_hist_data =
+					&tx_hist->mu_rate[nss][bw][gi][rate_ac];
+				tx_hist_data->rateinfo = rate_info;
+				tx_hist_data->per[per_index]++;
+			}
+		} else {
+			/* If legacy, skip legacy preamble bit 15 */
+			if (format == TX_RATE_FORMAT_LEGACY)
+				ratemask = 0xfff;
+			else
+				ratemask = 0xffff;
+			tx_hist_data = &tx_hist->su_rate[0];
+			if ((tx_hist_data[index].rateinfo & ratemask) ==
+			    (rate_info & ratemask))
+				tx_hist_data[index].per[per_index]++;
+		}
+	} else {
+		if (type == MU_MIMO) {
+			rate_ac = mcs & 0xf;
+			nss = mcs >> 4;
+			if (nss < (QS_NUM_SUPPORTED_11AC_NSS - 1)) {
+				tx_hist_data =
+					&tx_hist->mu_rate[nss][bw][gi][rate_ac];
+				tx_hist_data->rateinfo = rate_info;
+				tx_hist_data->per[per_index]++;
+			}
+		} else {
+			/* If legacy, skip legacy preamble bit 15 */
+			if (format == TX_RATE_FORMAT_LEGACY)
+				ratemask = 0xfff;
+			else
+				ratemask = 0xffff;
+			tx_hist_data = &tx_hist->custom_rate[0];
+			/* Go through non rate table buffer to see if any has
+			 * been used. If all used up, recycle by using index 0
+			 */
+			for (i = 0; i < TX_RATE_HISTO_CUSTOM_CNT; i++) {
+				if (!tx_hist_data[i].rateinfo ||
+				    ((tx_hist_data[i].rateinfo & ratemask) ==
+				    (rate_info & ratemask))) {
+					found = 1;
+					break;
+				}
+			}
+			if (found)
+				index = i;
+			else
+				index = 0; /* reuse index 0 buffer */
+			tx_hist_data[index].rateinfo = rate_info;
+			tx_hist_data[index].per[per_index]++;
+		}
+	}
+}
+
+static void pcie_ba_account(struct mwl_priv *priv,
+			    struct mwl_sta *sta_info,
+			    struct acnt_ba_s *acnt_ba)
+{
+	struct mwl_tx_ba_hist *ba_hist = &sta_info->ba_hist;
+
+	if (sta_info->stnid != le16_to_cpu(acnt_ba->stnid))
+		return;
+
+	if (ba_hist->enable && ba_hist->ba_stats &&
+	    (ba_hist->index < ACNT_BA_SIZE)) {
+		ba_hist->type = acnt_ba->type;
+		ba_hist->ba_stats[ba_hist->index].ba_hole = acnt_ba->ba_hole;
+		ba_hist->ba_stats[ba_hist->index].ba_expected =
+			acnt_ba->ba_expected;
+		ba_hist->ba_stats[ba_hist->index].no_ba = acnt_ba->no_ba;
+		ba_hist->index++;
+		if (ba_hist->index == ACNT_BA_SIZE)
+			wiphy_info(priv->hw->wiphy,
+				   "Aid:%d BA histo collection done\n",
+				   priv->ba_aid);
+	}
+}
+
+static void pcie_bf_mimo_ctrl_decode(struct mwl_priv *priv,
+				     struct acnt_bf_mimo_ctrl_s *bf_mimo_ctrl)
+{
+	struct file *fp_data = NULL;
+	const char filename[] = "/tmp/BF_MIMO_Ctrl_Field_Output.txt";
+	char str_buf[256];
+	char *buf = &str_buf[0];
+	mm_segment_t oldfs;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+
+	buf += sprintf(buf, "\nMAC: %pM\n", bf_mimo_ctrl->rec_mac);
+	buf += sprintf(buf, "SU_0_MU_1: %d\n", bf_mimo_ctrl->type);
+	buf += sprintf(buf, "MIMO_Ctrl_Field: 0x%x\n",
+		       le32_to_cpu(bf_mimo_ctrl->mimo_ctrl));
+	buf += sprintf(buf, "Comp_BF_Report_First_8Bytes: 0x%llx\n",
+		       le64_to_cpu(bf_mimo_ctrl->comp_bf_rep));
+
+	fp_data = filp_open(filename, O_RDWR | O_CREAT | O_TRUNC, 0);
+
+	if (!IS_ERR(fp_data)) {
+		__kernel_write(fp_data, str_buf, strlen(str_buf),
+			       &fp_data->f_pos);
+		filp_close(fp_data, current->files);
+	} else {
+		wiphy_err(priv->hw->wiphy, "Error opening %s! %x\n",
+			  filename, (unsigned int)fp_data);
+	}
+
+	set_fs(oldfs);
+}
+
+static void pcie_process_account(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+	u32 acnt_head, acnt_tail;
+	u32 read_size;
+	u8 *acnt_recds;
+	u8 *pstart, *pend;
+	struct acnt_s *acnt;
+	struct acnt_tx_s *acnt_tx;
+	struct acnt_rx_s *acnt_rx;
+	struct acnt_ra_s *acnt_ra;
+	struct acnt_ba_s *acnt_ba;
+	struct acnt_bf_mimo_ctrl_s *acnt_bf_mimo_ctrl;
+	struct pcie_dma_data *dma_data;
+	struct mwl_sta *sta_info;
+	u16 nf_a, nf_b, nf_c, nf_d;
+	u16 stnid;
+	u8 type;
+
+	acnt_head = readl(pcie_priv->iobase1 + MACREG_REG_ACNTHEAD);
+	acnt_tail = readl(pcie_priv->iobase1 + MACREG_REG_ACNTTAIL);
+
+	if (acnt_tail == acnt_head)
+		return;
+
+	if (acnt_tail > acnt_head) {
+		read_size = desc->acnt_ring_size - acnt_tail + acnt_head;
+		if (read_size > desc->acnt_ring_size) {
+			wiphy_err(hw->wiphy,
+				  "account size overflow (%d %d %d)\n",
+				  acnt_head, acnt_tail, read_size);
+			goto process_next;
+		}
+		memset(desc->pacnt_buf, 0, desc->acnt_ring_size);
+		memcpy(desc->pacnt_buf, desc->pacnt_ring + acnt_tail,
+		       desc->acnt_ring_size - acnt_tail);
+		memcpy(desc->pacnt_buf + desc->acnt_ring_size - acnt_tail,
+		       desc->pacnt_ring, acnt_head);
+		acnt_recds = desc->pacnt_buf;
+	} else {
+		read_size = acnt_head - acnt_tail;
+		if (read_size > desc->acnt_ring_size) {
+			wiphy_err(hw->wiphy,
+				  "account size overflow (%d %d %d)\n",
+				  acnt_head, acnt_tail, read_size);
+			goto process_next;
+		}
+		acnt_recds = desc->pacnt_ring + acnt_tail;
+	}
+
+	pstart = acnt_recds;
+	pend = pstart + read_size;
+	while (pstart < pend) {
+		acnt = (struct acnt_s *)pstart;
+
+		switch (le16_to_cpu(acnt->code)) {
+		case ACNT_CODE_BUSY:
+			pcie_priv->acnt_busy++;
+			break;
+		case ACNT_CODE_WRAP:
+			pcie_priv->acnt_wrap++;
+			break;
+		case ACNT_CODE_DROP:
+			pcie_priv->acnt_drop++;
+			break;
+		case ACNT_CODE_TX_ENQUEUE:
+			acnt_tx = (struct acnt_tx_s *)pstart;
+			sta_info = utils_find_sta(priv, acnt_tx->hdr.wh.addr1);
+			if (sta_info) {
+				spin_lock_bh(&priv->sta_lock);
+				pcie_tx_account(priv, sta_info, acnt_tx);
+				spin_unlock_bh(&priv->sta_lock);
+			}
+			break;
+		case ACNT_CODE_RX_PPDU:
+			acnt_rx = (struct acnt_rx_s *)pstart;
+			nf_a = (le32_to_cpu(acnt_rx->rx_info.nf_a_b) >>
+				RXINFO_NF_A_SHIFT) & RXINFO_NF_A_MASK;
+			nf_b = (le32_to_cpu(acnt_rx->rx_info.nf_a_b) >>
+				RXINFO_NF_B_SHIFT) & RXINFO_NF_B_MASK;
+			nf_c = (le32_to_cpu(acnt_rx->rx_info.nf_c_d) >>
+				RXINFO_NF_C_SHIFT) & RXINFO_NF_C_MASK;
+			nf_d = (le32_to_cpu(acnt_rx->rx_info.nf_c_d) >>
+				RXINFO_NF_D_SHIFT) & RXINFO_NF_D_MASK;
+			if ((nf_a >= 2048) && (nf_b >= 2048) &&
+			    (nf_c >= 2048) && (nf_d >= 2048)) {
+				nf_a = ((4096 - nf_a) >> 4);
+				nf_b = ((4096 - nf_b) >> 4);
+				nf_c = ((4096 - nf_c) >> 4);
+				nf_d = ((4096 - nf_d) >> 4);
+				priv->noise =
+					-((nf_a + nf_b + nf_c + nf_d) / 4);
+			}
+			dma_data = (struct pcie_dma_data *)
+				&acnt_rx->rx_info.hdr[0];
+			sta_info = utils_find_sta(priv, dma_data->wh.addr2);
+			if (sta_info) {
+				spin_lock_bh(&priv->sta_lock);
+				pcie_rx_account(priv, sta_info, acnt_rx);
+				spin_unlock_bh(&priv->sta_lock);
+			}
+			break;
+		case ACNT_CODE_RA_STATS:
+			acnt_ra = (struct acnt_ra_s *)pstart;
+			stnid = le16_to_cpu(acnt_ra->stn_id);
+			if ((stnid > 0) && (stnid <= priv->stnid_num)) {
+				type = acnt_ra->type;
+				if (type < 2) {
+					if (acnt_ra->tx_attempt_cnt >= 250)
+						priv->ra_tx_attempt[type][5]++;
+					else if (acnt_ra->tx_attempt_cnt >= 100)
+						priv->ra_tx_attempt[type][4]++;
+					else if (acnt_ra->tx_attempt_cnt >= 50)
+						priv->ra_tx_attempt[type][3]++;
+					else if (acnt_ra->tx_attempt_cnt >= 15)
+						priv->ra_tx_attempt[type][2]++;
+					else if (acnt_ra->tx_attempt_cnt >= 4)
+						priv->ra_tx_attempt[type][1]++;
+					else
+						priv->ra_tx_attempt[type][0]++;
+				}
+				sta_info = utils_find_sta_by_id(priv, stnid);
+				if (sta_info) {
+					spin_lock_bh(&priv->sta_lock);
+					pcie_tx_per(priv, sta_info, acnt_ra);
+					spin_unlock_bh(&priv->sta_lock);
+				}
+			}
+			break;
+		case ACNT_CODE_BA_STATS:
+			acnt_ba = (struct acnt_ba_s *)pstart;
+			if (priv->ba_aid) {
+				sta_info = utils_find_sta_by_aid(priv,
+								 priv->ba_aid);
+				if (sta_info) {
+					spin_lock_bh(&priv->sta_lock);
+					pcie_ba_account(priv, sta_info,
+							acnt_ba);
+					spin_unlock_bh(&priv->sta_lock);
+				}
+			}
+			break;
+		case ACNT_CODE_BF_MIMO_CTRL:
+			acnt_bf_mimo_ctrl =
+				(struct acnt_bf_mimo_ctrl_s *)pstart;
+			pcie_bf_mimo_ctrl_decode(priv, acnt_bf_mimo_ctrl);
+			break;
+		default:
+			break;
+		}
+
+		if (acnt->len)
+			pstart += acnt->len * 4;
+		else
+			goto process_next;
+	}
+process_next:
+	acnt_tail = acnt_head;
+	writel(acnt_tail, pcie_priv->iobase1 + MACREG_REG_ACNTTAIL);
+}
+
+static int pcie_mcast_cts(struct ieee80211_hw *hw, bool enable)
+{
+	return mwl_fwcmd_mcast_cts(hw, enable ? 1 : 0);
+}
+
+static const struct mwl_hif_ops pcie_hif_ops_ndp = {
+	.driver_name           = PCIE_DRV_NAME,
+	.driver_version        = PCIE_DRV_VERSION,
+	.tx_head_room          = PCIE_MIN_BYTES_HEADROOM,
+	.ampdu_num             = AMPDU_QUEUES_NDP,
+	.reset                 = pcie_reset,
+	.init                  = pcie_init_ndp,
+	.deinit                = pcie_deinit_ndp,
+	.get_info              = pcie_get_info_ndp,
+	.get_tx_status         = pcie_get_tx_status_ndp,
+	.get_rx_status         = pcie_get_rx_status_ndp,
+	.enable_data_tasks     = pcie_enable_data_tasks_ndp,
+	.disable_data_tasks    = pcie_disable_data_tasks_ndp,
+	.exec_cmd              = pcie_exec_cmd,
+	.get_irq_num           = pcie_get_irq_num,
+	.irq_handler           = pcie_isr_ndp,
+	.irq_enable            = pcie_irq_enable_ndp,
+	.irq_disable           = pcie_irq_disable,
+	.download_firmware     = pcie_download_firmware,
+	.timer_routine         = pcie_timer_routine_ndp,
+	.tx_xmit               = pcie_tx_xmit_ndp,
+	.tx_return_pkts        = pcie_tx_return_pkts_ndp,
+	.get_device_node       = pcie_get_device_node,
+	.get_survey            = pcie_get_survey,
+	.reg_access            = pcie_reg_access,
+	.set_sta_id            = pcie_set_sta_id,
+	.process_account       = pcie_process_account,
+	.mcast_cts             = pcie_mcast_cts,
+};
+
+static int pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	static bool printed_version;
+	struct ieee80211_hw *hw;
+	struct mwl_priv *priv;
+	struct pcie_priv *pcie_priv;
+	const struct mwl_hif_ops *hif_ops;
+	int rc = 0;
+
+	if (id->driver_data >= MWLUNKNOWN)
+		return -ENODEV;
+
+	if (!printed_version) {
+		pr_info("<<%s version %s>>\n",
+			PCIE_DRV_DESC, PCIE_DRV_VERSION);
+		printed_version = true;
+	}
+
+	rc = pci_enable_device(pdev);
+	if (rc) {
+		pr_err("%s: cannot enable new PCI device\n",
+		       PCIE_DRV_NAME);
+		return rc;
+	}
+
+	rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
+	if (rc) {
+		pr_err("%s: 32-bit PCI DMA not supported\n",
+		       PCIE_DRV_NAME);
+		goto err_pci_disable_device;
+	}
+
+	pci_set_master(pdev);
+
+	if (id->driver_data == MWL8964)
+		hif_ops = &pcie_hif_ops_ndp;
+	else
+		hif_ops = &pcie_hif_ops;
+	hw = mwl_alloc_hw(MWL_BUS_PCIE, id->driver_data, &pdev->dev,
+			  hif_ops, sizeof(*pcie_priv));
+	if (!hw) {
+		pr_err("%s: mwlwifi hw alloc failed\n",
+		       PCIE_DRV_NAME);
+		rc = -ENOMEM;
+		goto err_pci_disable_device;
+	}
+
+	pci_set_drvdata(pdev, hw);
+
+	priv = hw->priv;
+	priv->antenna_tx = pcie_chip_tbl[priv->chip_type].antenna_tx;
+	priv->antenna_rx = pcie_chip_tbl[priv->chip_type].antenna_rx;
+	pcie_priv = priv->hif.priv;
+	pcie_priv->mwl_priv = priv;
+	pcie_priv->pdev = pdev;
+	if (id->driver_data != MWL8964) {
+		pcie_priv->tx_head_room = PCIE_MIN_BYTES_HEADROOM;
+		if (id->driver_data == MWL8997) {
+			if (NET_SKB_PAD < PCIE_MIN_TX_HEADROOM_KF2) {
+				pcie_priv->tx_head_room =
+					PCIE_MIN_TX_HEADROOM_KF2;
+				pcie_hif_ops.tx_head_room =
+					PCIE_MIN_TX_HEADROOM_KF2;
+			}
+		}
+	}
+
+	rc = pcie_alloc_resource(pcie_priv);
+	if (rc)
+		goto err_alloc_pci_resource;
+
+	rc = mwl_init_hw(hw, pcie_chip_tbl[priv->chip_type].fw_image,
+			 pcie_chip_tbl[priv->chip_type].cal_file,
+			 pcie_chip_tbl[priv->chip_type].txpwrlmt_file);
+	if (rc)
+		goto err_wl_init;
+
+	vendor_cmd_basic_event(hw->wiphy, MWL_VENDOR_EVENT_DRIVER_READY);
+
+	return rc;
+
+err_wl_init:
+
+	pcie_reset(hw);
+
+err_alloc_pci_resource:
+
+	pci_set_drvdata(pdev, NULL);
+	mwl_free_hw(hw);
+
+err_pci_disable_device:
+
+	pci_disable_device(pdev);
+
+	return rc;
+}
+
+static void pcie_remove(struct pci_dev *pdev)
+{
+	struct ieee80211_hw *hw = pci_get_drvdata(pdev);
+	struct mwl_priv *priv = hw->priv;
+
+	priv->rmmod = true;
+	while (priv->in_send_cmd)
+		usleep_range(1000, 2000);
+	vendor_cmd_basic_event(hw->wiphy, MWL_VENDOR_EVENT_DRIVER_START_REMOVE);
+	mwl_deinit_hw(hw);
+	pci_set_drvdata(pdev, NULL);
+	mwl_free_hw(hw);
+	pci_disable_device(pdev);
+}
+
+static struct pci_driver mwl_pcie_driver = {
+	.name     = PCIE_DRV_NAME,
+	.id_table = pcie_id_tbl,
+	.probe    = pcie_probe,
+	.remove   = pcie_remove
+};
+
+module_pci_driver(mwl_pcie_driver);
+
+MODULE_DESCRIPTION(PCIE_DRV_DESC);
+MODULE_VERSION(PCIE_DRV_VERSION);
+MODULE_AUTHOR("Marvell Semiconductor, Inc.");
+MODULE_LICENSE("GPL v2");
+MODULE_SUPPORTED_DEVICE(PCIE_DEV_NAME);
+MODULE_DEVICE_TABLE(pci, pcie_id_tbl);
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx.c b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx.c
new file mode 100644
index 000000000000..25076c6d66df
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx.c
@@ -0,0 +1,540 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements receive related functions. */
+
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "utils.h"
+#include "hif/pcie/dev.h"
+#include "hif/pcie/rx.h"
+
+#define MAX_NUM_RX_RING_BYTES  (PCIE_MAX_NUM_RX_DESC * \
+				sizeof(struct pcie_rx_desc))
+
+#define MAX_NUM_RX_HNDL_BYTES  (PCIE_MAX_NUM_RX_DESC * \
+				sizeof(struct pcie_rx_hndl))
+
+#define DECRYPT_ERR_MASK        0x80
+#define GENERAL_DECRYPT_ERR     0xFF
+#define TKIP_DECRYPT_MIC_ERR    0x02
+#define WEP_DECRYPT_ICV_ERR     0x04
+#define TKIP_DECRYPT_ICV_ERR    0x08
+
+#define W836X_RSSI_OFFSET       8
+
+static int pcie_rx_ring_alloc(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data *desc;
+
+	desc = &pcie_priv->desc_data[0];
+
+	desc->prx_ring = (struct pcie_rx_desc *)
+		dma_alloc_coherent(priv->dev,
+				   MAX_NUM_RX_RING_BYTES,
+				   &desc->pphys_rx_ring,
+				   GFP_KERNEL);
+
+	if (!desc->prx_ring) {
+		wiphy_err(priv->hw->wiphy, "cannot alloc mem\n");
+		return -ENOMEM;
+	}
+
+	memset(desc->prx_ring, 0x00, MAX_NUM_RX_RING_BYTES);
+
+	desc->rx_hndl = kzalloc(MAX_NUM_RX_HNDL_BYTES, GFP_KERNEL);
+
+	if (!desc->rx_hndl) {
+		dma_free_coherent(priv->dev,
+				  MAX_NUM_RX_RING_BYTES,
+				  desc->prx_ring,
+				  desc->pphys_rx_ring);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int pcie_rx_ring_init(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data *desc;
+	int i;
+	struct pcie_rx_hndl *rx_hndl;
+	dma_addr_t dma;
+	u32 val;
+
+	desc = &pcie_priv->desc_data[0];
+
+	if (desc->prx_ring) {
+		desc->rx_buf_size = SYSADPT_MAX_AGGR_SIZE;
+
+		for (i = 0; i < PCIE_MAX_NUM_RX_DESC; i++) {
+			rx_hndl = &desc->rx_hndl[i];
+			rx_hndl->psk_buff =
+				dev_alloc_skb(desc->rx_buf_size);
+
+			if (!rx_hndl->psk_buff) {
+				wiphy_err(priv->hw->wiphy,
+					  "rxdesc %i: no skbuff available\n",
+					  i);
+				return -ENOMEM;
+			}
+
+			skb_reserve(rx_hndl->psk_buff,
+				    PCIE_MIN_BYTES_HEADROOM);
+			desc->prx_ring[i].rx_control =
+				EAGLE_RXD_CTRL_DRIVER_OWN;
+			desc->prx_ring[i].status = EAGLE_RXD_STATUS_OK;
+			desc->prx_ring[i].qos_ctrl = 0x0000;
+			desc->prx_ring[i].channel = 0x00;
+			desc->prx_ring[i].rssi = 0x00;
+			desc->prx_ring[i].pkt_len =
+				cpu_to_le16(SYSADPT_MAX_AGGR_SIZE);
+			dma = pci_map_single(pcie_priv->pdev,
+					     rx_hndl->psk_buff->data,
+					     desc->rx_buf_size,
+					     PCI_DMA_FROMDEVICE);
+			if (pci_dma_mapping_error(pcie_priv->pdev, dma)) {
+				wiphy_err(priv->hw->wiphy,
+					  "failed to map pci memory!\n");
+				return -ENOMEM;
+			}
+			desc->prx_ring[i].pphys_buff_data = cpu_to_le32(dma);
+			val = (u32)desc->pphys_rx_ring +
+			      ((i + 1) * sizeof(struct pcie_rx_desc));
+			desc->prx_ring[i].pphys_next = cpu_to_le32(val);
+			rx_hndl->pdesc = &desc->prx_ring[i];
+			if (i < (PCIE_MAX_NUM_RX_DESC - 1))
+				rx_hndl->pnext = &desc->rx_hndl[i + 1];
+		}
+		desc->prx_ring[PCIE_MAX_NUM_RX_DESC - 1].pphys_next =
+			cpu_to_le32((u32)desc->pphys_rx_ring);
+		desc->rx_hndl[PCIE_MAX_NUM_RX_DESC - 1].pnext =
+			&desc->rx_hndl[0];
+		desc->pnext_rx_hndl = &desc->rx_hndl[0];
+
+		return 0;
+	}
+
+	wiphy_err(priv->hw->wiphy, "no valid RX mem\n");
+
+	return -ENOMEM;
+}
+
+static void pcie_rx_ring_cleanup(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data *desc;
+	int i;
+	struct pcie_rx_hndl *rx_hndl;
+
+	desc = &pcie_priv->desc_data[0];
+
+	if (desc->prx_ring) {
+		for (i = 0; i < PCIE_MAX_NUM_RX_DESC; i++) {
+			rx_hndl = &desc->rx_hndl[i];
+			if (!rx_hndl->psk_buff)
+				continue;
+
+			pci_unmap_single(pcie_priv->pdev,
+					 le32_to_cpu
+					 (rx_hndl->pdesc->pphys_buff_data),
+					 desc->rx_buf_size,
+					 PCI_DMA_FROMDEVICE);
+
+			dev_kfree_skb_any(rx_hndl->psk_buff);
+
+			wiphy_debug(priv->hw->wiphy,
+				    "unmapped+free'd %i 0x%p 0x%x %i\n",
+				    i, rx_hndl->psk_buff->data,
+				    le32_to_cpu(
+				    rx_hndl->pdesc->pphys_buff_data),
+				    desc->rx_buf_size);
+
+			rx_hndl->psk_buff = NULL;
+		}
+	}
+}
+
+static void pcie_rx_ring_free(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data *desc;
+
+	desc = &pcie_priv->desc_data[0];
+
+	if (desc->prx_ring) {
+		pcie_rx_ring_cleanup(priv);
+
+		dma_free_coherent(priv->dev,
+				  MAX_NUM_RX_RING_BYTES,
+				  desc->prx_ring,
+				  desc->pphys_rx_ring);
+
+		desc->prx_ring = NULL;
+	}
+
+	kfree(desc->rx_hndl);
+
+	desc->pnext_rx_hndl = NULL;
+}
+
+static inline void pcie_rx_status(struct mwl_priv *priv,
+				  struct pcie_rx_desc *pdesc,
+				  struct ieee80211_rx_status *status)
+{
+	u16 rx_rate;
+
+	memset(status, 0, sizeof(*status));
+
+	if (priv->chip_type == MWL8997)
+		status->signal = (s8)pdesc->rssi;
+	else
+		status->signal = -(pdesc->rssi + W836X_RSSI_OFFSET);
+
+	rx_rate = le16_to_cpu(pdesc->rate);
+	pcie_rx_prepare_status(priv,
+			       rx_rate & MWL_RX_RATE_FORMAT_MASK,
+			       (rx_rate & MWL_RX_RATE_NSS_MASK) >>
+			       MWL_RX_RATE_NSS_SHIFT,
+			       (rx_rate & MWL_RX_RATE_BW_MASK) >>
+			       MWL_RX_RATE_BW_SHIFT,
+			       (rx_rate & MWL_RX_RATE_GI_MASK) >>
+			       MWL_RX_RATE_GI_SHIFT,
+			       (rx_rate & MWL_RX_RATE_RT_MASK) >>
+			       MWL_RX_RATE_RT_SHIFT,
+			       status);
+
+	status->freq = ieee80211_channel_to_frequency(pdesc->channel,
+						      status->band);
+
+	/* check if status has a specific error bit (bit 7) set or indicates
+	 * a general decrypt error
+	 */
+	if ((pdesc->status == GENERAL_DECRYPT_ERR) ||
+	    (pdesc->status & DECRYPT_ERR_MASK)) {
+		/* check if status is not equal to 0xFF
+		 * the 0xFF check is for backward compatibility
+		 */
+		if (pdesc->status != GENERAL_DECRYPT_ERR) {
+			if (((pdesc->status & (~DECRYPT_ERR_MASK)) &
+			    TKIP_DECRYPT_MIC_ERR) && !((pdesc->status &
+			    (WEP_DECRYPT_ICV_ERR | TKIP_DECRYPT_ICV_ERR)))) {
+				status->flag |= RX_FLAG_MMIC_ERROR;
+			}
+		}
+	}
+}
+
+static inline bool pcie_rx_process_mesh_amsdu(struct mwl_priv *priv,
+					     struct sk_buff *skb,
+					     struct ieee80211_rx_status *status)
+{
+	struct ieee80211_hdr *wh;
+	struct mwl_sta *sta_info;
+	struct ieee80211_sta *sta;
+	u8 *qc;
+	int wh_len;
+	int len;
+	u8 pad;
+	u8 *data;
+	u16 frame_len;
+	struct sk_buff *newskb;
+
+	wh = (struct ieee80211_hdr *)skb->data;
+
+	spin_lock_bh(&priv->sta_lock);
+	list_for_each_entry(sta_info, &priv->sta_list, list) {
+		sta = container_of((void *)sta_info, struct ieee80211_sta,
+				   drv_priv[0]);
+		if (ether_addr_equal(sta->addr, wh->addr2)) {
+			if (!sta_info->is_mesh_node) {
+				spin_unlock_bh(&priv->sta_lock);
+				return false;
+			}
+		}
+	}
+	spin_unlock_bh(&priv->sta_lock);
+
+	qc = ieee80211_get_qos_ctl(wh);
+	*qc &= ~IEEE80211_QOS_CTL_A_MSDU_PRESENT;
+
+	wh_len = ieee80211_hdrlen(wh->frame_control);
+	len = wh_len;
+	data = skb->data;
+
+	while (len < skb->len) {
+		frame_len = *(u8 *)(data + len + ETH_HLEN - 1) |
+			(*(u8 *)(data + len + ETH_HLEN - 2) << 8);
+
+		if ((len + ETH_HLEN + frame_len) > skb->len)
+			break;
+
+		newskb = dev_alloc_skb(wh_len + frame_len);
+		if (!newskb)
+			break;
+
+		ether_addr_copy(wh->addr3, data + len);
+		ether_addr_copy(wh->addr4, data + len + ETH_ALEN);
+		memcpy(newskb->data, wh, wh_len);
+		memcpy(newskb->data + wh_len, data + len + ETH_HLEN, frame_len);
+		skb_put(newskb, wh_len + frame_len);
+
+		pad = ((ETH_HLEN + frame_len) % 4) ?
+			(4 - (ETH_HLEN + frame_len) % 4) : 0;
+		len += (ETH_HLEN + frame_len + pad);
+		if (len < skb->len)
+			status->flag |= RX_FLAG_AMSDU_MORE;
+		else
+			status->flag &= ~RX_FLAG_AMSDU_MORE;
+		memcpy(IEEE80211_SKB_RXCB(newskb), status, sizeof(*status));
+		ieee80211_rx(priv->hw, newskb);
+	}
+
+	dev_kfree_skb_any(skb);
+
+	return true;
+}
+
+static inline int pcie_rx_refill(struct mwl_priv *priv,
+				 struct pcie_rx_hndl *rx_hndl)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data *desc;
+	dma_addr_t dma;
+
+	desc = &pcie_priv->desc_data[0];
+
+	rx_hndl->psk_buff = dev_alloc_skb(desc->rx_buf_size);
+
+	if (!rx_hndl->psk_buff)
+		return -ENOMEM;
+
+	skb_reserve(rx_hndl->psk_buff, PCIE_MIN_BYTES_HEADROOM);
+
+	rx_hndl->pdesc->status = EAGLE_RXD_STATUS_OK;
+	rx_hndl->pdesc->qos_ctrl = 0x0000;
+	rx_hndl->pdesc->channel = 0x00;
+	rx_hndl->pdesc->rssi = 0x00;
+	rx_hndl->pdesc->pkt_len = cpu_to_le16(desc->rx_buf_size);
+
+	dma = pci_map_single(pcie_priv->pdev,
+			     rx_hndl->psk_buff->data,
+			     desc->rx_buf_size,
+			     PCI_DMA_FROMDEVICE);
+	if (pci_dma_mapping_error(pcie_priv->pdev, dma)) {
+		dev_kfree_skb_any(rx_hndl->psk_buff);
+		wiphy_err(priv->hw->wiphy,
+			  "failed to map pci memory!\n");
+		return -ENOMEM;
+	}
+
+	rx_hndl->pdesc->pphys_buff_data = cpu_to_le32(dma);
+
+	return 0;
+}
+
+int pcie_rx_init(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	int rc;
+
+	rc = pcie_rx_ring_alloc(priv);
+	if (rc) {
+		wiphy_err(hw->wiphy, "allocating RX ring failed\n");
+		return rc;
+	}
+
+	rc = pcie_rx_ring_init(priv);
+	if (rc) {
+		pcie_rx_ring_free(priv);
+		wiphy_err(hw->wiphy,
+			  "initializing RX ring failed\n");
+		return rc;
+	}
+
+	return 0;
+}
+
+void pcie_rx_deinit(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	pcie_rx_ring_cleanup(priv);
+	pcie_rx_ring_free(priv);
+}
+
+void pcie_rx_recv(unsigned long data)
+{
+	struct ieee80211_hw *hw = (struct ieee80211_hw *)data;
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data *desc;
+	struct pcie_rx_hndl *curr_hndl;
+	int work_done = 0;
+	struct sk_buff *prx_skb = NULL;
+	int pkt_len;
+	struct ieee80211_rx_status *status;
+	struct mwl_vif *mwl_vif = NULL;
+	struct ieee80211_hdr *wh;
+
+	desc = &pcie_priv->desc_data[0];
+	curr_hndl = desc->pnext_rx_hndl;
+
+	if (!curr_hndl) {
+		pcie_mask_int(pcie_priv, MACREG_A2HRIC_BIT_RX_RDY, true);
+		pcie_priv->is_rx_schedule = false;
+		wiphy_warn(hw->wiphy, "busy or no receiving packets\n");
+		return;
+	}
+
+	while ((curr_hndl->pdesc->rx_control == EAGLE_RXD_CTRL_DMA_OWN) &&
+	       (work_done < pcie_priv->recv_limit)) {
+		prx_skb = curr_hndl->psk_buff;
+		if (!prx_skb)
+			goto out;
+		pci_unmap_single(pcie_priv->pdev,
+				 le32_to_cpu(curr_hndl->pdesc->pphys_buff_data),
+				 desc->rx_buf_size,
+				 PCI_DMA_FROMDEVICE);
+		pkt_len = le16_to_cpu(curr_hndl->pdesc->pkt_len);
+
+		if (skb_tailroom(prx_skb) < pkt_len) {
+			dev_kfree_skb_any(prx_skb);
+			goto out;
+		}
+
+		if (curr_hndl->pdesc->channel !=
+		    hw->conf.chandef.chan->hw_value) {
+			dev_kfree_skb_any(prx_skb);
+			goto out;
+		}
+
+		status = IEEE80211_SKB_RXCB(prx_skb);
+		pcie_rx_status(priv, curr_hndl->pdesc, status);
+
+		if (priv->chip_type == MWL8997) {
+			priv->noise = (s8)curr_hndl->pdesc->noise_floor;
+			if (priv->noise > 0)
+				priv->noise = -priv->noise;
+		} else
+			priv->noise = -curr_hndl->pdesc->noise_floor;
+
+		wh = &((struct pcie_dma_data *)prx_skb->data)->wh;
+
+		if (ieee80211_has_protected(wh->frame_control)) {
+			/* Check if hw crypto has been enabled for
+			 * this bss. If yes, set the status flags
+			 * accordingly
+			 */
+			if (ieee80211_has_tods(wh->frame_control)) {
+				mwl_vif = utils_find_vif_bss(priv, wh->addr1);
+				if (!mwl_vif &&
+				    ieee80211_has_a4(wh->frame_control))
+					mwl_vif =
+						utils_find_vif_bss(priv,
+								   wh->addr2);
+			} else {
+				mwl_vif = utils_find_vif_bss(priv, wh->addr2);
+			}
+
+			if  ((mwl_vif && mwl_vif->is_hw_crypto_enabled) ||
+			     is_multicast_ether_addr(wh->addr1) ||
+			     (ieee80211_is_mgmt(wh->frame_control) &&
+			     !is_multicast_ether_addr(wh->addr1))) {
+				/* When MMIC ERROR is encountered
+				 * by the firmware, payload is
+				 * dropped and only 32 bytes of
+				 * mwlwifi Firmware header is sent
+				 * to the host.
+				 *
+				 * We need to add four bytes of
+				 * key information.  In it
+				 * MAC80211 expects keyidx set to
+				 * 0 for triggering Counter
+				 * Measure of MMIC failure.
+				 */
+				if (status->flag & RX_FLAG_MMIC_ERROR) {
+					struct pcie_dma_data *dma_data;
+
+					dma_data = (struct pcie_dma_data *)
+					     prx_skb->data;
+					memset((void *)&dma_data->data, 0, 4);
+					pkt_len += 4;
+				}
+
+				if (!ieee80211_is_auth(wh->frame_control)) {
+					if (priv->chip_type != MWL8997)
+						status->flag |=
+							RX_FLAG_IV_STRIPPED |
+							RX_FLAG_DECRYPTED |
+							RX_FLAG_MMIC_STRIPPED;
+					else
+						status->flag |=
+							RX_FLAG_DECRYPTED |
+							RX_FLAG_MMIC_STRIPPED;
+				}
+			}
+		}
+
+		skb_put(prx_skb, pkt_len);
+		pcie_rx_remove_dma_header(prx_skb, curr_hndl->pdesc->qos_ctrl);
+
+		wh = (struct ieee80211_hdr *)prx_skb->data;
+
+		if (ieee80211_is_data_qos(wh->frame_control)) {
+			const u8 eapol[] = {0x88, 0x8e};
+			u8 *qc = ieee80211_get_qos_ctl(wh);
+			u8 *data;
+
+			data = prx_skb->data +
+				ieee80211_hdrlen(wh->frame_control) + 6;
+
+			if (!memcmp(data, eapol, sizeof(eapol)))
+				*qc |= 7;
+		}
+
+		if (ieee80211_is_data_qos(wh->frame_control) &&
+		    ieee80211_has_a4(wh->frame_control)) {
+			u8 *qc = ieee80211_get_qos_ctl(wh);
+
+			if (*qc & IEEE80211_QOS_CTL_A_MSDU_PRESENT)
+				if (pcie_rx_process_mesh_amsdu(priv, prx_skb,
+							      status))
+					goto out;
+		}
+
+		if (ieee80211_is_probe_req(wh->frame_control) &&
+		    priv->dump_probe)
+			wiphy_info(hw->wiphy, "Probe Req: %pM\n", wh->addr2);
+
+		ieee80211_rx(hw, prx_skb);
+out:
+		pcie_rx_refill(priv, curr_hndl);
+		curr_hndl->pdesc->rx_control = EAGLE_RXD_CTRL_DRIVER_OWN;
+		curr_hndl->pdesc->qos_ctrl = 0;
+		curr_hndl = curr_hndl->pnext;
+		work_done++;
+	}
+
+	desc->pnext_rx_hndl = curr_hndl;
+	pcie_mask_int(pcie_priv, MACREG_A2HRIC_BIT_RX_RDY, true);
+	pcie_priv->is_rx_schedule = false;
+}
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx.h b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx.h
new file mode 100644
index 000000000000..d2b580fceb0a
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines receive related functions. */
+
+#ifndef _RX_H_
+#define _RX_H_
+
+int pcie_rx_init(struct ieee80211_hw *hw);
+void pcie_rx_deinit(struct ieee80211_hw *hw);
+void pcie_rx_recv(unsigned long data);
+
+#endif /* _RX_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx_ndp.c b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx_ndp.c
new file mode 100644
index 000000000000..d1ede588b4c1
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx_ndp.c
@@ -0,0 +1,612 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements receive related functions for new data
+ * path.
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "utils.h"
+#include "hif/pcie/dev.h"
+#include "hif/pcie/rx_ndp.h"
+
+#define MAX_NUM_RX_RING_BYTES   (MAX_NUM_RX_DESC * \
+				sizeof(struct pcie_rx_desc_ndp))
+#define MAX_NUM_RX_RING_DONE_BYTES (MAX_NUM_RX_DESC * \
+				sizeof(struct rx_ring_done))
+
+static int pcie_rx_ring_alloc_ndp(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+
+	desc->prx_ring = (struct pcie_rx_desc_ndp *)
+		dma_alloc_coherent(priv->dev,
+				   MAX_NUM_RX_RING_BYTES,
+				   &desc->pphys_rx_ring,
+				   GFP_KERNEL);
+	if (!desc->prx_ring)
+		goto err_no_mem;
+	memset(desc->prx_ring, 0x00, MAX_NUM_RX_RING_BYTES);
+
+	desc->prx_ring_done = (struct rx_ring_done *)
+		dma_alloc_coherent(priv->dev,
+				   MAX_NUM_RX_RING_DONE_BYTES,
+				   &desc->pphys_rx_ring_done,
+				   GFP_KERNEL);
+	if (!desc->prx_ring_done)
+		goto err_no_mem;
+	memset(desc->prx_ring_done, 0x00, MAX_NUM_RX_RING_DONE_BYTES);
+	return 0;
+
+err_no_mem:
+
+	wiphy_err(priv->hw->wiphy, "cannot alloc mem\n");
+	return -ENOMEM;
+}
+
+static int pcie_rx_ring_init_ndp(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+	int i;
+	struct sk_buff *psk_buff;
+	dma_addr_t dma;
+
+	skb_queue_head_init(&pcie_priv->rx_skb_trace);
+	if (desc->prx_ring) {
+		desc->rx_buf_size = MAX_AGGR_SIZE;
+
+		for (i = 0; i < MAX_NUM_RX_DESC; i++) {
+			psk_buff = __alloc_skb(desc->rx_buf_size + NET_SKB_PAD,
+					       GFP_ATOMIC, SKB_ALLOC_RX,
+					       NUMA_NO_NODE);
+			skb_reserve(psk_buff, NET_SKB_PAD);
+			if (!psk_buff) {
+				wiphy_err(priv->hw->wiphy,
+					  "rxdesc %i: no skbuff available\n",
+					  i);
+				return -ENOMEM;
+			}
+			skb_reserve(psk_buff, MIN_BYTES_RX_HEADROOM);
+
+			dma = pci_map_single(pcie_priv->pdev,
+					     psk_buff->data,
+					     desc->rx_buf_size,
+					     PCI_DMA_FROMDEVICE);
+			if (pci_dma_mapping_error(pcie_priv->pdev, dma)) {
+				wiphy_err(priv->hw->wiphy,
+					  "failed to map pci memory!\n");
+				return -ENOMEM;
+			}
+
+			desc->rx_vbuflist[i] = psk_buff;
+			desc->prx_ring[i].user = cpu_to_le32(i);
+			desc->prx_ring[i].data = cpu_to_le32(dma);
+			*((u32 *)&psk_buff->cb[16]) = 0xdeadbeef;
+			skb_queue_tail(&pcie_priv->rx_skb_trace, psk_buff);
+		}
+
+		writel(1023, pcie_priv->iobase1 + MACREG_REG_RXDESCHEAD);
+		return 0;
+	}
+
+	wiphy_err(priv->hw->wiphy, "no valid RX mem\n");
+	return -ENOMEM;
+}
+
+static void pcie_rx_ring_cleanup_ndp(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+	int i;
+
+	if (desc->prx_ring) {
+		for (i = 0; i < MAX_NUM_RX_DESC; i++) {
+			if (desc->rx_vbuflist[i]) {
+				pci_unmap_single(pcie_priv->pdev,
+						 le32_to_cpu(
+						 desc->prx_ring[i].data),
+						 desc->rx_buf_size,
+						 PCI_DMA_FROMDEVICE);
+				desc->rx_vbuflist[i] = NULL;
+			}
+		}
+		skb_queue_purge(&pcie_priv->rx_skb_trace);
+	}
+}
+
+static void pcie_rx_ring_free_ndp(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+
+	if (desc->prx_ring) {
+		pcie_rx_ring_cleanup_ndp(priv);
+		dma_free_coherent(priv->dev,
+				  MAX_NUM_RX_RING_BYTES,
+				  desc->prx_ring,
+				  desc->pphys_rx_ring);
+		desc->prx_ring = NULL;
+	}
+
+	if (desc->prx_ring_done) {
+		dma_free_coherent(priv->dev,
+				  MAX_NUM_RX_RING_DONE_BYTES,
+				  desc->prx_ring_done,
+				  desc->pphys_rx_ring_done);
+		desc->prx_ring_done = NULL;
+	}
+}
+
+static inline void pcie_rx_update_ndp_cnts(struct mwl_priv *priv, u32 ctrl)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+
+	switch (ctrl) {
+	case RXRING_CASE_DROP:
+		pcie_priv->rx_cnts.drop_cnt++;
+		break;
+	case RXRING_CASE_FAST_BAD_AMSDU:
+		pcie_priv->rx_cnts.fast_bad_amsdu_cnt++;
+		break;
+	case RXRING_CASE_FAST_DATA:
+		pcie_priv->rx_cnts.fast_data_cnt++;
+		break;
+	case RXRING_CASE_SLOW_BAD_MIC:
+		pcie_priv->rx_cnts.slow_bad_mic_cnt++;
+		break;
+	case RXRING_CASE_SLOW_BAD_PN:
+		pcie_priv->rx_cnts.slow_bad_pn_cnt++;
+		break;
+	case RXRING_CASE_SLOW_BAD_STA:
+		pcie_priv->rx_cnts.slow_bad_sta_cnt++;
+		break;
+	case RXRING_CASE_SLOW_MCAST:
+		pcie_priv->rx_cnts.slow_mcast_cnt++;
+		break;
+	case RXRING_CASE_SLOW_MGMT:
+		pcie_priv->rx_cnts.slow_mgmt_cnt++;
+		break;
+	case RXRING_CASE_SLOW_NOQUEUE:
+		pcie_priv->rx_cnts.slow_noqueue_cnt++;
+		break;
+	case RXRING_CASE_SLOW_NORUN:
+		pcie_priv->rx_cnts.slow_norun_cnt++;
+		break;
+	case RXRING_CASE_SLOW_PROMISC:
+		pcie_priv->rx_cnts.slow_promisc_cnt++;
+		break;
+	}
+}
+
+static void pcie_rx_status_ndp(struct mwl_priv *priv,
+			       struct mwl_sta *sta_info,
+			       struct ieee80211_rx_status *status)
+{
+	memset(status, 0, sizeof(*status));
+	pcie_rx_prepare_status(priv,
+			       sta_info->rx_format,
+			       sta_info->rx_nss,
+			       sta_info->rx_bw,
+			       sta_info->rx_gi,
+			       sta_info->rx_rate_mcs,
+			       status);
+	status->signal = -sta_info->rx_signal;
+	status->band = priv->hw->conf.chandef.chan->band;
+	status->freq = ieee80211_channel_to_frequency(
+		priv->hw->conf.chandef.chan->hw_value, status->band);
+}
+
+static inline void pcie_rx_process_fast_data(struct mwl_priv *priv,
+					     struct sk_buff *skb,
+					     u16 stnid)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct ieee80211_sta *sta;
+	struct mwl_sta *sta_info;
+	struct mwl_vif *mwl_vif;
+	struct ieee80211_hdr hdr;
+	u16 hdrlen, ethertype;
+	__le16 fc;
+	struct ieee80211_rx_status *status;
+
+	if (stnid == RXRING_CTRL_STA_FROMDS)
+		stnid = 0;
+
+	if (stnid > SYSADPT_MAX_STA_SC4)
+		goto drop_packet;
+
+	sta = pcie_priv->sta_link[stnid];
+	if (!sta)
+		goto drop_packet;
+
+	sta_info = mwl_dev_get_sta(sta);
+	mwl_vif = sta_info->mwl_vif;
+	if (!mwl_vif)
+		goto drop_packet;
+
+	ethertype = (skb->data[20] << 8) | skb->data[21];
+	fc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);
+
+	memset(&hdr, 0, sizeof(hdr));
+	switch (mwl_vif->type) {
+	case NL80211_IFTYPE_AP:
+		if (sta_info->wds) {
+			fc |= (cpu_to_le16(IEEE80211_FCTL_TODS) |
+				cpu_to_le16(IEEE80211_FCTL_FROMDS));
+			/* RA TA DA SA */
+			ether_addr_copy(hdr.addr1, mwl_vif->bssid);
+			ether_addr_copy(hdr.addr2, sta->addr);
+			ether_addr_copy(hdr.addr3, skb->data);
+			ether_addr_copy(hdr.addr4, skb->data + ETH_ALEN);
+			hdrlen = 30;
+		} else {
+			fc |= cpu_to_le16(IEEE80211_FCTL_TODS);
+			/* BSSID SA DA */
+			ether_addr_copy(hdr.addr1, mwl_vif->bssid);
+			ether_addr_copy(hdr.addr2, skb->data + ETH_ALEN);
+			ether_addr_copy(hdr.addr3, skb->data);
+			hdrlen = 24;
+		}
+		break;
+	case NL80211_IFTYPE_STATION:
+		if (sta_info->wds) {
+			fc |= (cpu_to_le16(IEEE80211_FCTL_TODS) |
+				cpu_to_le16(IEEE80211_FCTL_FROMDS));
+			/* RA TA DA SA */
+			ether_addr_copy(hdr.addr1, mwl_vif->sta_mac);
+			ether_addr_copy(hdr.addr2, mwl_vif->bssid);
+			ether_addr_copy(hdr.addr3, skb->data);
+			ether_addr_copy(hdr.addr4, skb->data + ETH_ALEN);
+			hdrlen = 30;
+		} else {
+			fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);
+			/* DA BSSID SA */
+			ether_addr_copy(hdr.addr1, skb->data);
+			ether_addr_copy(hdr.addr2, mwl_vif->bssid);
+			ether_addr_copy(hdr.addr3, skb->data + ETH_ALEN);
+			hdrlen = 24;
+		}
+		break;
+	default:
+		goto drop_packet;
+	}
+
+	if (sta->wme) {
+		fc |= cpu_to_le16(IEEE80211_STYPE_QOS_DATA);
+		hdrlen += 2;
+	}
+
+	status = IEEE80211_SKB_RXCB(skb);
+	pcie_rx_status_ndp(priv, sta_info, status);
+	if (mwl_vif->is_hw_crypto_enabled) {
+		fc |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+		status->flag |= RX_FLAG_IV_STRIPPED |
+				RX_FLAG_DECRYPTED |
+				RX_FLAG_MMIC_STRIPPED;
+	}
+
+	hdr.frame_control = fc;
+	hdr.duration_id = 0;
+
+	skb_pull(skb, ETH_HLEN);
+
+	if (ieee80211_is_data_qos(fc)) {
+		__le16 *qos_control;
+
+		qos_control = (__le16 *)skb_push(skb, 2);
+		memcpy(skb_push(skb, hdrlen - 2), &hdr, hdrlen - 2);
+		if (ethertype == ETH_P_PAE)
+			*qos_control = cpu_to_le16(
+				IEEE80211_QOS_CTL_ACK_POLICY_NOACK | 7);
+		else
+			*qos_control = cpu_to_le16(
+				IEEE80211_QOS_CTL_ACK_POLICY_NOACK);
+	} else
+		memcpy(skb_push(skb, hdrlen), &hdr, hdrlen);
+
+	status->flag |= RX_FLAG_DUP_VALIDATED;
+	ieee80211_rx(priv->hw, skb);
+
+	return;
+drop_packet:
+
+	dev_kfree_skb_any(skb);
+}
+
+static inline void pcie_rx_process_slow_data(struct mwl_priv *priv,
+					     struct sk_buff *skb,
+					     bool bad_mic, u8 signal)
+{
+	struct ieee80211_rx_status *status;
+	struct ieee80211_hdr *wh;
+	struct mwl_vif *mwl_vif = NULL;
+
+	pcie_rx_remove_dma_header(skb, 0);
+	status = IEEE80211_SKB_RXCB(skb);
+	memset(status, 0, sizeof(*status));
+	status->signal = -signal;
+	status->band = priv->hw->conf.chandef.chan->band;
+	status->freq = ieee80211_channel_to_frequency(
+		priv->hw->conf.chandef.chan->hw_value, status->band);
+
+	if (bad_mic)
+		status->flag |= RX_FLAG_MMIC_ERROR;
+	else {
+		wh = (struct ieee80211_hdr *)skb->data;
+
+		if (ieee80211_has_protected(wh->frame_control)) {
+			if (ieee80211_has_tods(wh->frame_control)) {
+				mwl_vif = utils_find_vif_bss(priv, wh->addr1);
+				if (!mwl_vif &&
+				    ieee80211_has_a4(wh->frame_control))
+					mwl_vif =
+						utils_find_vif_bss(priv,
+								   wh->addr2);
+			} else {
+				mwl_vif = utils_find_vif_bss(priv, wh->addr2);
+			}
+
+			if ((mwl_vif && mwl_vif->is_hw_crypto_enabled) ||
+			    is_multicast_ether_addr(wh->addr1) ||
+			    (ieee80211_is_mgmt(wh->frame_control) &&
+			    !is_multicast_ether_addr(wh->addr1))) {
+				if (!ieee80211_is_auth(wh->frame_control))
+					status->flag |= RX_FLAG_IV_STRIPPED |
+							RX_FLAG_DECRYPTED |
+							RX_FLAG_MMIC_STRIPPED;
+			}
+		}
+
+		if (ieee80211_has_a4(wh->frame_control) && !priv->wds_check) {
+			ether_addr_copy(priv->wds_check_sta, wh->addr2);
+			ieee80211_queue_work(priv->hw, &priv->wds_check_handle);
+			priv->wds_check = true;
+		}
+	}
+
+	status->flag |= RX_FLAG_DUP_VALIDATED;
+	ieee80211_rx(priv->hw, skb);
+}
+
+static inline int pcie_rx_refill_ndp(struct mwl_priv *priv, u32 buf_idx)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+	struct sk_buff *psk_buff;
+	dma_addr_t dma;
+
+	psk_buff = __alloc_skb(desc->rx_buf_size + NET_SKB_PAD, GFP_ATOMIC,
+			       SKB_ALLOC_RX, NUMA_NO_NODE);
+	skb_reserve(psk_buff, NET_SKB_PAD);
+	if (!psk_buff)
+		return -ENOMEM;
+	skb_reserve(psk_buff, MIN_BYTES_RX_HEADROOM);
+
+	dma = pci_map_single(pcie_priv->pdev,
+			     psk_buff->data,
+			     desc->rx_buf_size,
+			     PCI_DMA_FROMDEVICE);
+	if (pci_dma_mapping_error(pcie_priv->pdev, dma)) {
+		wiphy_err(priv->hw->wiphy,
+			  "refill: failed to map pci memory!\n");
+		return -ENOMEM;
+	}
+
+	desc->rx_vbuflist[buf_idx] = psk_buff;
+	desc->prx_ring[buf_idx].data = cpu_to_le32(dma);
+	*((u32 *)&psk_buff->cb[16]) = 0xdeadbeef;
+	skb_queue_tail(&pcie_priv->rx_skb_trace, psk_buff);
+
+	return 0;
+}
+
+int pcie_rx_init_ndp(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	int rc;
+
+	rc = pcie_rx_ring_alloc_ndp(priv);
+	if (rc) {
+		pcie_rx_ring_free_ndp(priv);
+		wiphy_err(hw->wiphy, "allocating RX ring failed\n");
+		return rc;
+	}
+
+	rc = pcie_rx_ring_init_ndp(priv);
+	if (rc) {
+		pcie_rx_ring_free_ndp(priv);
+		wiphy_err(hw->wiphy,
+			  "initializing RX ring failed\n");
+		return rc;
+	}
+
+	return 0;
+}
+
+void pcie_rx_deinit_ndp(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	pcie_rx_ring_cleanup_ndp(priv);
+	pcie_rx_ring_free_ndp(priv);
+}
+
+void pcie_rx_recv_ndp(unsigned long data)
+{
+	struct ieee80211_hw *hw = (struct ieee80211_hw *)data;
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+	struct rx_ring_done *prx_ring_done;
+	struct pcie_rx_desc_ndp *prx_desc;
+	u32 rx_done_head;
+	u32 rx_done_tail;
+	u32 rx_desc_head;
+	struct sk_buff *psk_buff;
+	u32 buf_idx;
+	u32 rx_cnt;
+	u32 ctrl, ctrl_case;
+	bool bad_mic;
+	u16 stnid;
+	u16 pktlen;
+	struct rx_info *rx_info;
+	struct pcie_dma_data *dma_data;
+	u8 signal;
+
+	rx_done_head = readl(pcie_priv->iobase1 + MACREG_REG_RXDONEHEAD);
+	rx_done_tail = readl(pcie_priv->iobase1 + MACREG_REG_RXDONETAIL);
+	rx_desc_head = readl(pcie_priv->iobase1 + MACREG_REG_RXDESCHEAD);
+	rx_cnt = 0;
+
+	while ((rx_done_tail != rx_done_head) &&
+	       (rx_cnt < pcie_priv->recv_limit)) {
+recheck:
+		prx_ring_done = &desc->prx_ring_done[rx_done_tail];
+		wmb(); /*Data Memory Barrier*/
+		if (le32_to_cpu(prx_ring_done->user) == 0xdeadbeef) {
+			pcie_priv->recheck_rxringdone++;
+			udelay(1);
+			goto recheck;
+		}
+		buf_idx = le32_to_cpu(prx_ring_done->user) & 0x3fff;
+		prx_ring_done->user = cpu_to_le32(0xdeadbeef);
+		rx_done_tail++;
+		prx_desc = &desc->prx_ring[buf_idx];
+		if (!prx_desc->data)
+			wiphy_err(hw->wiphy, "RX desc data is NULL\n");
+		psk_buff = desc->rx_vbuflist[buf_idx];
+		if (!psk_buff) {
+			wiphy_err(hw->wiphy, "RX socket buffer is NULL\n");
+			goto out;
+		}
+		if (*((u32 *)&psk_buff->cb[16]) != 0xdeadbeef) {
+			pcie_priv->signature_err++;
+			break;
+		}
+		if (psk_buff->next && psk_buff->prev) {
+			skb_unlink(psk_buff, &pcie_priv->rx_skb_trace);
+			*((u32 *)&psk_buff->cb[16]) = 0xbeefdead;
+		} else {
+			pcie_priv->rx_skb_unlink_err++;
+			break;
+		}
+
+		pci_unmap_single(pcie_priv->pdev,
+				 le32_to_cpu(prx_desc->data),
+				 desc->rx_buf_size,
+				 PCI_DMA_FROMDEVICE);
+
+		bad_mic = false;
+		ctrl = le32_to_cpu(prx_ring_done->ctrl);
+		ctrl_case = ctrl & RXRING_CTRL_CASE_MASK;
+		stnid = (ctrl >> RXRING_CTRL_STA_SHIFT) & RXRING_CTRL_STA_MASK;
+		pcie_rx_update_ndp_cnts(priv, ctrl_case);
+
+		switch (ctrl_case) {
+		case RXRING_CASE_FAST_DATA:
+			if (stnid == RXRING_CTRL_STA_UNKNOWN) {
+				dev_kfree_skb_any(psk_buff);
+				break;
+			}
+			pktlen = psk_buff->data[12] << 8 | psk_buff->data[13];
+			pktlen += ETH_HLEN;
+
+			if (skb_tailroom(psk_buff) >= pktlen) {
+				skb_put(psk_buff, pktlen);
+				pcie_rx_process_fast_data(priv, psk_buff,
+							  stnid);
+			} else {
+				wiphy_err(hw->wiphy,
+					  "fast: space %d(%d) is not enough\n",
+					  skb_tailroom(psk_buff), pktlen);
+				dev_kfree_skb_any(psk_buff);
+			}
+			break;
+		case RXRING_CASE_FAST_BAD_AMSDU:
+		case RXRING_CASE_SLOW_BAD_STA:
+		case RXRING_CASE_SLOW_DEL_DONE:
+		case RXRING_CASE_DROP:
+		case RXRING_CASE_SLOW_BAD_PN:
+			if (ctrl_case == RXRING_CASE_SLOW_DEL_DONE) {
+				wiphy_debug(hw->wiphy,
+					    "staid %d deleted\n",
+					    stnid);
+				utils_free_stnid(priv, stnid);
+			}
+			dev_kfree_skb_any(psk_buff);
+			break;
+		case RXRING_CASE_SLOW_BAD_MIC:
+			bad_mic = true;
+		case RXRING_CASE_SLOW_NOQUEUE:
+		case RXRING_CASE_SLOW_NORUN:
+		case RXRING_CASE_SLOW_MGMT:
+		case RXRING_CASE_SLOW_MCAST:
+		case RXRING_CASE_SLOW_PROMISC:
+			rx_info = (struct rx_info *)psk_buff->data;
+			dma_data = (struct pcie_dma_data *)&rx_info->hdr[0];
+			pktlen = le16_to_cpu(dma_data->fwlen);
+			pktlen += sizeof(*rx_info);
+			pktlen += sizeof(struct pcie_dma_data);
+			if (bad_mic) {
+				memset((void *)&dma_data->data, 0, 4);
+				pktlen += 4;
+			}
+			if (skb_tailroom(psk_buff) >= pktlen) {
+				skb_put(psk_buff, pktlen);
+				skb_pull(psk_buff, sizeof(*rx_info));
+				signal = ((le32_to_cpu(rx_info->rssi_x) >>
+					RXINFO_RSSI_X_SHIFT) &
+					RXINFO_RSSI_X_MASK);
+				pcie_rx_process_slow_data(priv, psk_buff,
+							  bad_mic, signal);
+			} else {
+				wiphy_err(hw->wiphy,
+					  "slow: space %d(%d) is not enough\n",
+					  skb_tailroom(psk_buff), pktlen);
+				dev_kfree_skb_any(psk_buff);
+			}
+			break;
+		default:
+			wiphy_err(hw->wiphy, "unknown control case: %d\n",
+				  ctrl_case);
+			dev_kfree_skb_any(psk_buff);
+			break;
+		}
+out:
+		pcie_rx_refill_ndp(priv, buf_idx);
+
+		if (rx_done_tail >= MAX_RX_RING_DONE_SIZE)
+			rx_done_tail = 0;
+
+		rx_done_head =
+			readl(pcie_priv->iobase1 + MACREG_REG_RXDONEHEAD);
+		rx_cnt++;
+	}
+
+	rx_desc_head += rx_cnt;
+	if (rx_desc_head >= MAX_RX_RING_SEND_SIZE)
+		rx_desc_head = rx_desc_head - MAX_RX_RING_SEND_SIZE;
+	writel(rx_done_tail, pcie_priv->iobase1 + MACREG_REG_RXDONETAIL);
+	writel(rx_desc_head, pcie_priv->iobase1 + MACREG_REG_RXDESCHEAD);
+
+	pcie_mask_int(pcie_priv, MACREG_A2HRIC_RX_DONE_HEAD_RDY, true);
+	pcie_priv->is_rx_schedule = false;
+}
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx_ndp.h b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx_ndp.h
new file mode 100644
index 000000000000..7e83cedf4351
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/rx_ndp.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines receive related functions for new data path.
+ */
+
+#ifndef _RX_NDP_H_
+#define _RX_NDP_H_
+
+int pcie_rx_init_ndp(struct ieee80211_hw *hw);
+void pcie_rx_deinit_ndp(struct ieee80211_hw *hw);
+void pcie_rx_recv_ndp(unsigned long data);
+
+#endif /* _RX_NDP_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/sc4_ddr.h b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/sc4_ddr.h
new file mode 100644
index 000000000000..2da0257accba
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/sc4_ddr.h
@@ -0,0 +1,965 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+static unsigned char sc4_ddr_init[] = {
+0x05,
+0x00,
+0x00,
+0x00,
+0x00,
+0x00,
+0x00,
+0x00,
+0xa4,
+0x03,
+0x00,
+0x00,
+0x2a,
+0xbe,
+0xad,
+0x7e,
+0x00,
+0x00,
+0x00,
+0xa8,
+0x01,
+0x00,
+0x00,
+0x00,
+0x00,
+0x00,
+0x00,
+0x00,
+0x5c,
+0x48,
+0x5b,
+0x49,
+0x04,
+0x00,
+0x00,
+0x00,
+0x10,
+0xb5,
+0xc0,
+0xf8,
+0x08,
+0x00,
+0x00,
+0x00,
+0xe0,
+0x12,
+0xef,
+0x21,
+0x0c,
+0x00,
+0x00,
+0x00,
+0xc0,
+0xf8,
+0x20,
+0x13,
+0x10,
+0x00,
+0x00,
+0x00,
+0x02,
+0x21,
+0xc0,
+0xf8,
+0x14,
+0x00,
+0x00,
+0x00,
+0x24,
+0x13,
+0x02,
+0x01,
+0x18,
+0x00,
+0x00,
+0x00,
+0x57,
+0x49,
+0x0a,
+0x60,
+0x1c,
+0x00,
+0x00,
+0x00,
+0x00,
+0x21,
+0x56,
+0x4b,
+0x20,
+0x00,
+0x00,
+0x00,
+0xc0,
+0x3b,
+0x19,
+0x60,
+0x24,
+0x00,
+0x00,
+0x00,
+0x54,
+0x4b,
+0x1b,
+0x1d,
+0x28,
+0x00,
+0x00,
+0x00,
+0x1a,
+0x60,
+0x53,
+0x4b,
+0x2c,
+0x00,
+0x00,
+0x00,
+0xbc,
+0x3b,
+0x19,
+0x60,
+0x30,
+0x00,
+0x00,
+0x00,
+0x51,
+0x4b,
+0x08,
+0x33,
+0x34,
+0x00,
+0x00,
+0x00,
+0x1a,
+0x60,
+0x50,
+0x4b,
+0x38,
+0x00,
+0x00,
+0x00,
+0xb8,
+0x3b,
+0x19,
+0x60,
+0x3c,
+0x00,
+0x00,
+0x00,
+0x4e,
+0x4b,
+0x0c,
+0x33,
+0x40,
+0x00,
+0x00,
+0x00,
+0x1a,
+0x60,
+0x4d,
+0x4b,
+0x44,
+0x00,
+0x00,
+0x00,
+0xb4,
+0x3b,
+0x19,
+0x60,
+0x48,
+0x00,
+0x00,
+0x00,
+0x4b,
+0x4b,
+0x10,
+0x33,
+0x4c,
+0x00,
+0x00,
+0x00,
+0x1a,
+0x60,
+0x4a,
+0x4b,
+0x50,
+0x00,
+0x00,
+0x00,
+0xb0,
+0x3b,
+0x19,
+0x60,
+0x54,
+0x00,
+0x00,
+0x00,
+0x48,
+0x4b,
+0x80,
+0x33,
+0x58,
+0x00,
+0x00,
+0x00,
+0x1a,
+0x60,
+0x47,
+0x4b,
+0x5c,
+0x00,
+0x00,
+0x00,
+0x40,
+0x3b,
+0x19,
+0x60,
+0x60,
+0x00,
+0x00,
+0x00,
+0x47,
+0x4c,
+0x46,
+0x4b,
+0x64,
+0x00,
+0x00,
+0x00,
+0x23,
+0x60,
+0x24,
+0x1d,
+0x68,
+0x00,
+0x00,
+0x00,
+0x23,
+0x60,
+0x24,
+0x1d,
+0x6c,
+0x00,
+0x00,
+0x00,
+0x23,
+0x60,
+0x44,
+0x4b,
+0x70,
+0x00,
+0x00,
+0x00,
+0x40,
+0x33,
+0x19,
+0x60,
+0x74,
+0x00,
+0x00,
+0x00,
+0x1b,
+0x1d,
+0x19,
+0x60,
+0x78,
+0x00,
+0x00,
+0x00,
+0x1b,
+0x1d,
+0x19,
+0x60,
+0x7c,
+0x00,
+0x00,
+0x00,
+0x41,
+0x4b,
+0xc0,
+0xf8,
+0x80,
+0x00,
+0x00,
+0x00,
+0xe0,
+0x31,
+0x41,
+0x4b,
+0x84,
+0x00,
+0x00,
+0x00,
+0xc0,
+0xf8,
+0xf0,
+0x31,
+0x88,
+0x00,
+0x00,
+0x00,
+0x03,
+0x04,
+0xc0,
+0xf8,
+0x8c,
+0x00,
+0x00,
+0x00,
+0xf0,
+0x32,
+0x40,
+0xf2,
+0x90,
+0x00,
+0x00,
+0x00,
+0x55,
+0x13,
+0xc0,
+0xf8,
+0x94,
+0x00,
+0x00,
+0x00,
+0x60,
+0x33,
+0x3d,
+0x4b,
+0x98,
+0x00,
+0x00,
+0x00,
+0xc0,
+0xf8,
+0x64,
+0x33,
+0x9c,
+0x00,
+0x00,
+0x00,
+0x13,
+0x1d,
+0xc0,
+0xf8,
+0xa0,
+0x00,
+0x00,
+0x00,
+0x68,
+0x33,
+0x3b,
+0x4b,
+0xa4,
+0x00,
+0x00,
+0x00,
+0xc0,
+0xf8,
+0x6c,
+0x33,
+0xa8,
+0x00,
+0x00,
+0x00,
+0x3a,
+0x4b,
+0xc0,
+0xf8,
+0xac,
+0x00,
+0x00,
+0x00,
+0x70,
+0x33,
+0x3a,
+0x4b,
+0xb0,
+0x00,
+0x00,
+0x00,
+0xc0,
+0xf8,
+0x74,
+0x33,
+0xb4,
+0x00,
+0x00,
+0x00,
+0x39,
+0x4b,
+0xc0,
+0xf8,
+0xb8,
+0x00,
+0x00,
+0x00,
+0x78,
+0x33,
+0xc4,
+0x23,
+0xbc,
+0x00,
+0x00,
+0x00,
+0xc0,
+0xf8,
+0x7c,
+0x33,
+0xc0,
+0x00,
+0x00,
+0x00,
+0x37,
+0x4b,
+0xc0,
+0xf8,
+0xc4,
+0x00,
+0x00,
+0x00,
+0x80,
+0x33,
+0x37,
+0x4b,
+0xc8,
+0x00,
+0x00,
+0x00,
+0xc0,
+0xf8,
+0x84,
+0x33,
+0xcc,
+0x00,
+0x00,
+0x00,
+0x36,
+0x4b,
+0xc0,
+0xf8,
+0xd0,
+0x00,
+0x00,
+0x00,
+0x88,
+0x33,
+0x42,
+0xf2,
+0xd4,
+0x00,
+0x00,
+0x00,
+0x44,
+0x23,
+0xc0,
+0xf8,
+0xd8,
+0x00,
+0x00,
+0x00,
+0x8c,
+0x33,
+0xc0,
+0xf8,
+0xdc,
+0x00,
+0x00,
+0x00,
+0x90,
+0x13,
+0x4f,
+0xf4,
+0xe0,
+0x00,
+0x00,
+0x00,
+0x60,
+0x43,
+0xc0,
+0xf8,
+0xe4,
+0x00,
+0x00,
+0x00,
+0xa0,
+0x32,
+0xc0,
+0xf8,
+0xe8,
+0x00,
+0x00,
+0x00,
+0xa4,
+0x22,
+0xc0,
+0xf8,
+0xec,
+0x00,
+0x00,
+0x00,
+0xa8,
+0x12,
+0x44,
+0xf2,
+0xf0,
+0x00,
+0x00,
+0x00,
+0x40,
+0x02,
+0x2e,
+0x4b,
+0xf4,
+0x00,
+0x00,
+0x00,
+0x1a,
+0x60,
+0x1b,
+0x1d,
+0xf8,
+0x00,
+0x00,
+0x00,
+0x2d,
+0x4a,
+0x1a,
+0x60,
+0xfc,
+0x00,
+0x00,
+0x00,
+0x1b,
+0x1d,
+0x2d,
+0x4a,
+0x00,
+0x01,
+0x00,
+0x00,
+0x1a,
+0x60,
+0x1b,
+0x1d,
+0x04,
+0x01,
+0x00,
+0x00,
+0x2c,
+0x4a,
+0x1a,
+0x60,
+0x08,
+0x01,
+0x00,
+0x00,
+0x1b,
+0x1d,
+0x2c,
+0x4a,
+0x0c,
+0x01,
+0x00,
+0x00,
+0x1a,
+0x60,
+0x1b,
+0x1d,
+0x10,
+0x01,
+0x00,
+0x00,
+0x4f,
+0xf4,
+0x60,
+0x12,
+0x14,
+0x01,
+0x00,
+0x00,
+0x1a,
+0x60,
+0x25,
+0x4a,
+0x18,
+0x01,
+0x00,
+0x00,
+0x28,
+0x32,
+0x11,
+0x60,
+0x1c,
+0x01,
+0x00,
+0x00,
+0x23,
+0x4a,
+0x30,
+0x32,
+0x20,
+0x01,
+0x00,
+0x00,
+0x11,
+0x60,
+0x12,
+0x1d,
+0x24,
+0x01,
+0x00,
+0x00,
+0x11,
+0x60,
+0x03,
+0x22,
+0x28,
+0x01,
+0x00,
+0x00,
+0x20,
+0x4b,
+0x38,
+0x33,
+0x2c,
+0x01,
+0x00,
+0x00,
+0x1a,
+0x60,
+0x20,
+0x22,
+0x30,
+0x01,
+0x00,
+0x00,
+0x1b,
+0x1d,
+0x1a,
+0x60,
+0x34,
+0x01,
+0x00,
+0x00,
+0x1b,
+0x1d,
+0x4f,
+0xf0,
+0x38,
+0x01,
+0x00,
+0x00,
+0x04,
+0x22,
+0x1a,
+0x60,
+0x3c,
+0x01,
+0x00,
+0x00,
+0x03,
+0x06,
+0x1b,
+0x4a,
+0x40,
+0x01,
+0x00,
+0x00,
+0x20,
+0x32,
+0x13,
+0x60,
+0x44,
+0x01,
+0x00,
+0x00,
+0x43,
+0x06,
+0x13,
+0x60,
+0x48,
+0x01,
+0x00,
+0x00,
+0x83,
+0x06,
+0x13,
+0x60,
+0x4c,
+0x01,
+0x00,
+0x00,
+0x0c,
+0x4b,
+0x1c,
+0x4a,
+0x50,
+0x01,
+0x00,
+0x00,
+0x70,
+0x33,
+0x1a,
+0x60,
+0x54,
+0x01,
+0x00,
+0x00,
+0x41,
+0x62,
+0x4f,
+0xf4,
+0x58,
+0x01,
+0x00,
+0x00,
+0x7f,
+0x22,
+0x82,
+0x62,
+0x5c,
+0x01,
+0x00,
+0x00,
+0x19,
+0x4a,
+0x82,
+0x66,
+0x60,
+0x01,
+0x00,
+0x00,
+0xc1,
+0x66,
+0x40,
+0xf2,
+0x64,
+0x01,
+0x00,
+0x00,
+0x63,
+0x42,
+0x42,
+0x63,
+0x68,
+0x01,
+0x00,
+0x00,
+0x01,
+0x64,
+0x17,
+0x49,
+0x6c,
+0x01,
+0x00,
+0x00,
+0x01,
+0x60,
+0x10,
+0xbd,
+0x70,
+0x01,
+0x00,
+0x00,
+0x22,
+0x76,
+0x30,
+0x00,
+0x74,
+0x01,
+0x00,
+0x00,
+0x20,
+0x00,
+0x00,
+0xf0,
+0x78,
+0x01,
+0x00,
+0x00,
+0x40,
+0x06,
+0x00,
+0xf0,
+0x7c,
+0x01,
+0x00,
+0x00,
+0x04,
+0x00,
+0x15,
+0x15,
+0x80,
+0x01,
+0x00,
+0x00,
+0x00,
+0x05,
+0x00,
+0xf0,
+0x84,
+0x01,
+0x00,
+0x00,
+0x01,
+0x00,
+0x0d,
+0x00,
+0x88,
+0x01,
+0x00,
+0x00,
+0x32,
+0x05,
+0x00,
+0x04,
+0x8c,
+0x01,
+0x00,
+0x00,
+0xa9,
+0x02,
+0xb8,
+0x00,
+0x90,
+0x01,
+0x00,
+0x00,
+0x00,
+0x01,
+0x40,
+0x00,
+0x94,
+0x01,
+0x00,
+0x00,
+0xeb,
+0x06,
+0x77,
+0x00,
+0x98,
+0x01,
+0x00,
+0x00,
+0x00,
+0x52,
+0x7b,
+0x50,
+0x9c,
+0x01,
+0x00,
+0x00,
+0x0b,
+0x06,
+0x04,
+0x10,
+0xa0,
+0x01,
+0x00,
+0x00,
+0x10,
+0x07,
+0x17,
+0x13,
+0xa4,
+0x01,
+0x00,
+0x00,
+0x07,
+0x74,
+0x70,
+0x00,
+0xa8,
+0x01,
+0x00,
+0x00,
+0x40,
+0x00,
+0x70,
+0x50,
+0xac,
+0x01,
+0x00,
+0x00,
+0x00,
+0x04,
+0x00,
+0xf0,
+0xb0,
+0x01,
+0x00,
+0x00,
+0x79,
+0x07,
+0x70,
+0x17,
+0xb4,
+0x01,
+0x00,
+0x00,
+0x70,
+0x07,
+0xf0,
+0x0f,
+0xb8,
+0x01,
+0x00,
+0x00,
+0x77,
+0xfc,
+0x03,
+0x3f,
+0xbc,
+0x01,
+0x00,
+0x00,
+0x00,
+0x31,
+0x10,
+0x00,
+0xc0,
+0x01,
+0x00,
+0x00,
+0x01,
+0x00,
+0x00,
+0xc0,
+0xc4,
+0x01,
+0x00,
+0x00,
+0x66,
+0x66,
+0x66,
+0x00,
+0xc8,
+0x01,
+0x00,
+0x00,
+0x01,
+0x00,
+0x00,
+0x11,
+0x37,
+0x3e,
+0xfc,
+0xdc,
+};
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx.c b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx.c
new file mode 100644
index 000000000000..dd77589ef5a6
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx.c
@@ -0,0 +1,1396 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements transmit related functions. */
+
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "utils.h"
+#include "hif/fwcmd.h"
+#include "hif/pcie/dev.h"
+#include "hif/pcie/tx.h"
+
+#define MAX_NUM_TX_RING_BYTES  (PCIE_MAX_NUM_TX_DESC * \
+				sizeof(struct pcie_tx_desc))
+
+#define MAX_NUM_TX_HNDL_BYTES  (PCIE_MAX_NUM_TX_DESC * \
+				sizeof(struct pcie_tx_hndl))
+
+#define TOTAL_HW_QUEUES        (SYSADPT_TX_WMM_QUEUES + \
+				PCIE_AMPDU_QUEUES)
+
+#define EAGLE_TXD_XMITCTRL_USE_MC_RATE     0x8     /* Use multicast data rate */
+
+#define MWL_QOS_ACK_POLICY_MASK	           0x0060
+#define MWL_QOS_ACK_POLICY_NORMAL          0x0000
+#define MWL_QOS_ACK_POLICY_BLOCKACK        0x0060
+
+#define EXT_IV                             0x20
+#define INCREASE_IV(iv16, iv32) \
+{ \
+	(iv16)++; \
+	if ((iv16) == 0) \
+		(iv32)++; \
+}
+
+/* Transmission information to transmit a socket buffer. */
+struct pcie_tx_ctrl {
+	void *vif;
+	void *sta;
+	void *k_conf;
+	void *amsdu_pkts;
+	u8 tx_priority;
+	u8 type;
+	u16 qos_ctrl;
+	u8 xmit_control;
+};
+
+struct ccmp_hdr {
+	__le16 iv16;
+	u8 rsvd;
+	u8 key_id;
+	__le32 iv32;
+} __packed;
+
+static int pcie_tx_ring_alloc(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data *desc;
+	int num;
+	u8 *mem;
+
+	desc = &pcie_priv->desc_data[0];
+
+	mem = dma_alloc_coherent(priv->dev,
+				 MAX_NUM_TX_RING_BYTES *
+				 PCIE_NUM_OF_DESC_DATA,
+				 &desc->pphys_tx_ring,
+				 GFP_KERNEL);
+
+	if (!mem) {
+		wiphy_err(priv->hw->wiphy, "cannot alloc mem\n");
+		return -ENOMEM;
+	}
+
+	for (num = 0; num < PCIE_NUM_OF_DESC_DATA; num++) {
+		desc = &pcie_priv->desc_data[num];
+
+		desc->ptx_ring = (struct pcie_tx_desc *)
+			(mem + num * MAX_NUM_TX_RING_BYTES);
+
+		desc->pphys_tx_ring = (dma_addr_t)
+			((u32)pcie_priv->desc_data[0].pphys_tx_ring +
+			num * MAX_NUM_TX_RING_BYTES);
+
+		memset(desc->ptx_ring, 0x00,
+		       MAX_NUM_TX_RING_BYTES);
+	}
+
+	mem = kzalloc(MAX_NUM_TX_HNDL_BYTES * PCIE_NUM_OF_DESC_DATA,
+		      GFP_KERNEL);
+
+	if (!mem) {
+		wiphy_err(priv->hw->wiphy, "cannot alloc mem\n");
+		dma_free_coherent(priv->dev,
+				  MAX_NUM_TX_RING_BYTES *
+				  PCIE_NUM_OF_DESC_DATA,
+				  pcie_priv->desc_data[0].ptx_ring,
+				  pcie_priv->desc_data[0].pphys_tx_ring);
+		return -ENOMEM;
+	}
+
+	for (num = 0; num < PCIE_NUM_OF_DESC_DATA; num++) {
+		desc = &pcie_priv->desc_data[num];
+
+		desc->tx_hndl = (struct pcie_tx_hndl *)
+			(mem + num * MAX_NUM_TX_HNDL_BYTES);
+	}
+
+	return 0;
+}
+
+static int pcie_txbd_ring_create(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int num;
+	u8 *mem;
+
+	/* driver maintaines the write pointer and firmware maintaines the read
+	 * pointer.
+	 */
+	pcie_priv->txbd_wrptr = 0;
+	pcie_priv->txbd_rdptr = 0;
+
+	/* allocate shared memory for the BD ring and divide the same in to
+	 * several descriptors
+	 */
+	pcie_priv->txbd_ring_size =
+		sizeof(struct pcie_data_buf) * PCIE_MAX_TXRX_BD;
+	wiphy_info(priv->hw->wiphy, "TX ring: allocating %d bytes\n",
+		   pcie_priv->txbd_ring_size);
+
+	mem = dma_alloc_coherent(priv->dev,
+				 pcie_priv->txbd_ring_size,
+				 &pcie_priv->txbd_ring_pbase,
+				 GFP_KERNEL);
+
+	if (!mem) {
+		wiphy_err(priv->hw->wiphy, "cannot alloc mem\n");
+		return -ENOMEM;
+	}
+	pcie_priv->txbd_ring_vbase = mem;
+	wiphy_info(priv->hw->wiphy,
+		   "TX ring: - base: %p, pbase: 0x%x, len: %d\n",
+		   pcie_priv->txbd_ring_vbase,
+		   pcie_priv->txbd_ring_pbase,
+		   pcie_priv->txbd_ring_size);
+
+	for (num = 0; num < PCIE_MAX_TXRX_BD; num++) {
+		pcie_priv->txbd_ring[num] =
+			(struct pcie_data_buf *)(pcie_priv->txbd_ring_vbase +
+			(sizeof(struct pcie_data_buf) * num));
+		pcie_priv->txbd_ring[num]->flags = 0;
+		pcie_priv->txbd_ring[num]->offset = 0;
+		pcie_priv->txbd_ring[num]->frag_len = 0;
+		pcie_priv->txbd_ring[num]->len = 0;
+		pcie_priv->txbd_ring[num]->paddr = 0;
+		pcie_priv->tx_buf_list[num] = NULL;
+	}
+
+	return 0;
+}
+
+static int pcie_tx_ring_init(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int num, i;
+	struct pcie_desc_data *desc;
+
+	for (num = 0; num < PCIE_NUM_OF_DESC_DATA; num++) {
+		skb_queue_head_init(&pcie_priv->txq[num]);
+		pcie_priv->fw_desc_cnt[num] = 0;
+
+		if (priv->chip_type == MWL8997)
+			continue;
+
+		desc = &pcie_priv->desc_data[num];
+
+		if (desc->ptx_ring) {
+			for (i = 0; i < PCIE_MAX_NUM_TX_DESC; i++) {
+				desc->ptx_ring[i].status =
+					cpu_to_le32(EAGLE_TXD_STATUS_IDLE);
+				desc->ptx_ring[i].pphys_next =
+					cpu_to_le32((u32)desc->pphys_tx_ring +
+					((i + 1) *
+					sizeof(struct pcie_tx_desc)));
+				desc->tx_hndl[i].pdesc =
+					&desc->ptx_ring[i];
+				if (i < PCIE_MAX_NUM_TX_DESC - 1)
+					desc->tx_hndl[i].pnext =
+						&desc->tx_hndl[i + 1];
+			}
+			desc->ptx_ring[PCIE_MAX_NUM_TX_DESC - 1].pphys_next =
+				cpu_to_le32((u32)desc->pphys_tx_ring);
+			desc->tx_hndl[PCIE_MAX_NUM_TX_DESC - 1].pnext =
+				&desc->tx_hndl[0];
+
+			desc->pstale_tx_hndl = &desc->tx_hndl[0];
+			desc->pnext_tx_hndl  = &desc->tx_hndl[0];
+		} else {
+			wiphy_err(priv->hw->wiphy, "no valid TX mem\n");
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
+}
+
+static void pcie_tx_ring_cleanup(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int cleaned_tx_desc = 0;
+	int num, i;
+	struct pcie_desc_data *desc;
+
+	for (num = 0; num < PCIE_NUM_OF_DESC_DATA; num++) {
+		skb_queue_purge(&pcie_priv->txq[num]);
+		pcie_priv->fw_desc_cnt[num] = 0;
+
+		if (priv->chip_type == MWL8997)
+			continue;
+
+		desc = &pcie_priv->desc_data[num];
+
+		if (desc->ptx_ring) {
+			for (i = 0; i < PCIE_MAX_NUM_TX_DESC; i++) {
+				if (!desc->tx_hndl[i].psk_buff)
+					continue;
+
+				wiphy_debug(priv->hw->wiphy,
+					    "unmapped and free'd %i %p %x\n",
+					    i,
+					    desc->tx_hndl[i].psk_buff->data,
+					    le32_to_cpu(
+					    desc->ptx_ring[i].pkt_ptr));
+				pci_unmap_single(pcie_priv->pdev,
+						 le32_to_cpu(
+						 desc->ptx_ring[i].pkt_ptr),
+						 desc->tx_hndl[i].psk_buff->len,
+						 PCI_DMA_TODEVICE);
+				dev_kfree_skb_any(desc->tx_hndl[i].psk_buff);
+				desc->ptx_ring[i].status =
+					cpu_to_le32(EAGLE_TXD_STATUS_IDLE);
+				desc->ptx_ring[i].pkt_ptr = 0;
+				desc->ptx_ring[i].pkt_len = 0;
+				desc->tx_hndl[i].psk_buff = NULL;
+				cleaned_tx_desc++;
+			}
+		}
+	}
+
+	wiphy_info(priv->hw->wiphy, "cleaned %i TX descr\n", cleaned_tx_desc);
+}
+
+static void pcie_tx_ring_free(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int num;
+
+	if (pcie_priv->desc_data[0].ptx_ring) {
+		dma_free_coherent(priv->dev,
+				  MAX_NUM_TX_RING_BYTES *
+				  PCIE_NUM_OF_DESC_DATA,
+				  pcie_priv->desc_data[0].ptx_ring,
+				  pcie_priv->desc_data[0].pphys_tx_ring);
+	}
+
+	for (num = 0; num < PCIE_NUM_OF_DESC_DATA; num++) {
+		if (pcie_priv->desc_data[num].ptx_ring)
+			pcie_priv->desc_data[num].ptx_ring = NULL;
+		pcie_priv->desc_data[num].pstale_tx_hndl = NULL;
+		pcie_priv->desc_data[num].pnext_tx_hndl = NULL;
+	}
+
+	kfree(pcie_priv->desc_data[0].tx_hndl);
+}
+
+static void pcie_txbd_ring_delete(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct sk_buff *skb;
+	struct pcie_tx_desc *tx_desc;
+	int num;
+
+	if (pcie_priv->txbd_ring_vbase) {
+		dma_free_coherent(priv->dev,
+				  pcie_priv->txbd_ring_size,
+				  pcie_priv->txbd_ring_vbase,
+				  pcie_priv->txbd_ring_pbase);
+	}
+
+	for (num = 0; num < PCIE_MAX_TXRX_BD; num++) {
+		pcie_priv->txbd_ring[num] = NULL;
+		if (pcie_priv->tx_buf_list[num]) {
+			skb = pcie_priv->tx_buf_list[num];
+			tx_desc = (struct pcie_tx_desc *)skb->data;
+
+			pci_unmap_single(pcie_priv->pdev,
+					 le32_to_cpu(tx_desc->pkt_ptr),
+					 skb->len,
+					 PCI_DMA_TODEVICE);
+			dev_kfree_skb_any(skb);
+		}
+		pcie_priv->tx_buf_list[num] = NULL;
+	}
+
+	pcie_priv->txbd_wrptr = 0;
+	pcie_priv->txbd_rdptr = 0;
+	pcie_priv->txbd_ring_size = 0;
+	pcie_priv->txbd_ring_vbase = NULL;
+	pcie_priv->txbd_ring_pbase = 0;
+}
+
+static inline void pcie_tx_add_ccmp_hdr(u8 *pccmp_hdr,
+					u8 key_id, u16 iv16, u32 iv32)
+{
+	struct ccmp_hdr *ccmp_h = (struct ccmp_hdr *)pccmp_hdr;
+
+	ccmp_h->iv16 = cpu_to_le16(iv16);
+	ccmp_h->rsvd = 0;
+	ccmp_h->key_id = EXT_IV | (key_id << 6);
+	ccmp_h->iv32 = cpu_to_le32(iv32);
+}
+
+static inline bool pcie_tx_available(struct mwl_priv *priv, int desc_num)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_tx_hndl *tx_hndl;
+
+	if (priv->chip_type == MWL8997)
+		return PCIE_TXBD_NOT_FULL(pcie_priv->txbd_wrptr,
+					  pcie_priv->txbd_rdptr);
+
+	tx_hndl = pcie_priv->desc_data[desc_num].pnext_tx_hndl;
+
+	if (!tx_hndl->pdesc)
+		return false;
+
+	if (tx_hndl->pdesc->status != EAGLE_TXD_STATUS_IDLE) {
+		/* Interrupt F/W anyway */
+		if (tx_hndl->pdesc->status &
+		    cpu_to_le32(EAGLE_TXD_STATUS_FW_OWNED))
+			writel(MACREG_H2ARIC_BIT_PPA_READY,
+			       pcie_priv->iobase1 +
+			       MACREG_REG_H2A_INTERRUPT_EVENTS);
+		return false;
+	}
+
+	return true;
+}
+
+static inline void pcie_tx_skb(struct mwl_priv *priv, int desc_num,
+			       struct sk_buff *tx_skb)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct ieee80211_tx_info *tx_info;
+	struct pcie_tx_ctrl *tx_ctrl;
+	struct pcie_tx_hndl *tx_hndl = NULL;
+	struct pcie_tx_desc *tx_desc;
+	struct ieee80211_sta *sta;
+	struct ieee80211_vif *vif;
+	struct mwl_vif *mwl_vif;
+	struct ieee80211_key_conf *k_conf;
+	bool ccmp = false;
+	struct pcie_pfu_dma_data *pfu_dma_data;
+	struct pcie_dma_data *dma_data;
+	struct ieee80211_hdr *wh;
+	dma_addr_t dma;
+
+	if (WARN_ON(!tx_skb))
+		return;
+
+	tx_info = IEEE80211_SKB_CB(tx_skb);
+	tx_ctrl = (struct pcie_tx_ctrl *)&tx_info->status;
+	sta = (struct ieee80211_sta *)tx_ctrl->sta;
+	vif = (struct ieee80211_vif *)tx_ctrl->vif;
+	mwl_vif = mwl_dev_get_vif(vif);
+	k_conf = (struct ieee80211_key_conf *)tx_ctrl->k_conf;
+
+	pcie_tx_encapsulate_frame(priv, tx_skb, k_conf, &ccmp);
+
+	if (priv->chip_type == MWL8997) {
+		pfu_dma_data = (struct pcie_pfu_dma_data *)tx_skb->data;
+		tx_desc = &pfu_dma_data->tx_desc;
+		dma_data = &pfu_dma_data->dma_data;
+	} else {
+		tx_hndl = pcie_priv->desc_data[desc_num].pnext_tx_hndl;
+		tx_hndl->psk_buff = tx_skb;
+		tx_desc = tx_hndl->pdesc;
+		dma_data = (struct pcie_dma_data *)tx_skb->data;
+	}
+	wh = &dma_data->wh;
+
+	if (ieee80211_is_probe_resp(wh->frame_control) &&
+	    priv->dump_probe)
+		wiphy_info(priv->hw->wiphy,
+			  "Probe Resp: %pM\n", wh->addr1);
+
+	if (ieee80211_is_data(wh->frame_control) ||
+	    (ieee80211_is_mgmt(wh->frame_control) &&
+	    ieee80211_has_protected(wh->frame_control) &&
+	    !is_multicast_ether_addr(wh->addr1))) {
+		if (is_multicast_ether_addr(wh->addr1)) {
+			if (ccmp) {
+				pcie_tx_add_ccmp_hdr(dma_data->data,
+						     mwl_vif->keyidx,
+						     mwl_vif->iv16,
+						     mwl_vif->iv32);
+				INCREASE_IV(mwl_vif->iv16, mwl_vif->iv32);
+			}
+		} else {
+			if (ccmp) {
+				if (vif->type == NL80211_IFTYPE_STATION) {
+					pcie_tx_add_ccmp_hdr(dma_data->data,
+							     mwl_vif->keyidx,
+							     mwl_vif->iv16,
+							     mwl_vif->iv32);
+					INCREASE_IV(mwl_vif->iv16,
+						    mwl_vif->iv32);
+				} else {
+					struct mwl_sta *sta_info;
+
+					sta_info = mwl_dev_get_sta(sta);
+
+					pcie_tx_add_ccmp_hdr(dma_data->data,
+							     0,
+							     sta_info->iv16,
+							     sta_info->iv32);
+					INCREASE_IV(sta_info->iv16,
+						    sta_info->iv32);
+				}
+			}
+		}
+	}
+
+	if (tx_info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)
+		tx_desc->flags |= PCIE_TX_WCB_FLAGS_DONT_ENCRYPT;
+	if (tx_info->flags & IEEE80211_TX_CTL_NO_CCK_RATE)
+		tx_desc->flags |= PCIE_TX_WCB_FLAGS_NO_CCK_RATE;
+	tx_desc->tx_priority = tx_ctrl->tx_priority;
+	tx_desc->qos_ctrl = cpu_to_le16(tx_ctrl->qos_ctrl);
+	tx_desc->pkt_len = cpu_to_le16(tx_skb->len);
+	tx_desc->packet_info = 0;
+	tx_desc->data_rate = 0;
+	tx_desc->type = tx_ctrl->type;
+	tx_desc->xmit_control = tx_ctrl->xmit_control;
+	tx_desc->sap_pkt_info = 0;
+	dma = pci_map_single(pcie_priv->pdev, tx_skb->data,
+			     tx_skb->len, PCI_DMA_TODEVICE);
+	if (pci_dma_mapping_error(pcie_priv->pdev, dma)) {
+		dev_kfree_skb_any(tx_skb);
+		wiphy_err(priv->hw->wiphy,
+			  "failed to map pci memory!\n");
+		return;
+	}
+	if (priv->chip_type == MWL8997)
+		tx_desc->pkt_ptr = cpu_to_le32(sizeof(struct pcie_tx_desc));
+	else
+		tx_desc->pkt_ptr = cpu_to_le32(dma);
+	tx_desc->status = cpu_to_le32(EAGLE_TXD_STATUS_FW_OWNED);
+	/* make sure all the memory transactions done by cpu were completed */
+	wmb();	/*Data Memory Barrier*/
+
+	if (priv->chip_type == MWL8997) {
+		u32 wrindx;
+		struct pcie_data_buf *data_buf;
+		const u32 num_tx_buffs = PCIE_MAX_TXRX_BD << PCIE_TX_START_PTR;
+
+		wrindx = (pcie_priv->txbd_wrptr & PCIE_TXBD_MASK) >>
+			PCIE_TX_START_PTR;
+		pcie_priv->tx_buf_list[wrindx] = tx_skb;
+		data_buf = pcie_priv->txbd_ring[wrindx];
+		data_buf->paddr = cpu_to_le64(dma);
+		data_buf->len = cpu_to_le16(tx_skb->len);
+		data_buf->flags = cpu_to_le16(PCIE_BD_FLAG_FIRST_DESC |
+					      PCIE_BD_FLAG_LAST_DESC);
+		data_buf->frag_len = cpu_to_le16(tx_skb->len);
+		data_buf->offset = 0;
+		pcie_priv->txbd_wrptr += PCIE_BD_FLAG_TX_START_PTR;
+
+		if ((pcie_priv->txbd_wrptr & PCIE_TXBD_MASK) == num_tx_buffs)
+			pcie_priv->txbd_wrptr = ((pcie_priv->txbd_wrptr &
+			PCIE_BD_FLAG_TX_ROLLOVER_IND) ^
+			PCIE_BD_FLAG_TX_ROLLOVER_IND);
+
+		/* Write the TX ring write pointer in to REG_TXBD_WRPTR */
+		writel(pcie_priv->txbd_wrptr,
+		       pcie_priv->iobase1 + REG_TXBD_WRPTR);
+	} else {
+		writel(MACREG_H2ARIC_BIT_PPA_READY,
+		       pcie_priv->iobase1 + MACREG_REG_H2A_INTERRUPT_EVENTS);
+		pcie_priv->desc_data[desc_num].pnext_tx_hndl = tx_hndl->pnext;
+		pcie_priv->fw_desc_cnt[desc_num]++;
+	}
+}
+
+static inline
+struct sk_buff *pcie_tx_do_amsdu(struct mwl_priv *priv,
+				 int desc_num,
+				 struct sk_buff *tx_skb,
+				 struct ieee80211_tx_info *tx_info)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct ieee80211_sta *sta;
+	struct mwl_sta *sta_info;
+	struct pcie_tx_ctrl *tx_ctrl = (struct pcie_tx_ctrl *)&tx_info->status;
+	struct ieee80211_tx_info *amsdu_info;
+	struct sk_buff_head *amsdu_pkts;
+	struct mwl_amsdu_frag *amsdu;
+	int amsdu_allow_size;
+	struct ieee80211_hdr *wh;
+	int wh_len;
+	u16 len;
+	u8 *data;
+
+	sta = (struct ieee80211_sta *)tx_ctrl->sta;
+	sta_info = mwl_dev_get_sta(sta);
+
+	if (!sta_info->is_amsdu_allowed)
+		return tx_skb;
+
+	wh = (struct ieee80211_hdr *)tx_skb->data;
+	if (sta_info->is_mesh_node && is_multicast_ether_addr(wh->addr3))
+		return tx_skb;
+
+	if (ieee80211_is_qos_nullfunc(wh->frame_control))
+		return tx_skb;
+
+	if (sta_info->amsdu_ctrl.cap == MWL_AMSDU_SIZE_4K)
+		amsdu_allow_size = SYSADPT_AMSDU_4K_MAX_SIZE;
+	else if (sta_info->amsdu_ctrl.cap == MWL_AMSDU_SIZE_8K)
+		amsdu_allow_size = SYSADPT_AMSDU_8K_MAX_SIZE;
+	else
+		return tx_skb;
+
+	spin_lock_bh(&sta_info->amsdu_lock);
+	amsdu = &sta_info->amsdu_ctrl.frag[desc_num];
+
+	if ((tx_skb->len > SYSADPT_AMSDU_ALLOW_SIZE) ||
+	    utils_is_non_amsdu_packet(tx_skb->data, true)) {
+		if (amsdu->num) {
+			pcie_tx_skb(priv, desc_num, amsdu->skb);
+			amsdu->num = 0;
+			amsdu->cur_pos = NULL;
+		}
+		spin_unlock_bh(&sta_info->amsdu_lock);
+		return tx_skb;
+	}
+
+	/* potential amsdu size, should add amsdu header 14 bytes +
+	 * maximum padding 3.
+	 */
+	wh_len = ieee80211_hdrlen(wh->frame_control);
+	len = tx_skb->len - wh_len + 17;
+
+	if (amsdu->num) {
+		if ((amsdu->skb->len + len) > amsdu_allow_size) {
+			pcie_tx_skb(priv, desc_num, amsdu->skb);
+			amsdu->num = 0;
+			amsdu->cur_pos = NULL;
+		}
+	}
+
+	amsdu->jiffies = jiffies;
+	len = tx_skb->len - wh_len;
+
+	if (amsdu->num == 0) {
+		struct sk_buff *newskb;
+		int headroom;
+
+		amsdu_pkts = (struct sk_buff_head *)
+			kmalloc(sizeof(*amsdu_pkts), GFP_ATOMIC);
+		if (!amsdu_pkts) {
+			spin_unlock_bh(&sta_info->amsdu_lock);
+			return tx_skb;
+		}
+		newskb = dev_alloc_skb(amsdu_allow_size +
+				       pcie_priv->tx_head_room);
+		if (!newskb) {
+			spin_unlock_bh(&sta_info->amsdu_lock);
+			kfree(amsdu_pkts);
+			return tx_skb;
+		}
+
+		headroom = skb_headroom(newskb);
+		if (headroom < pcie_priv->tx_head_room)
+			skb_reserve(newskb,
+				    (pcie_priv->tx_head_room - headroom));
+
+		data = newskb->data;
+		memcpy(data, tx_skb->data, wh_len);
+		if (sta_info->is_mesh_node) {
+			ether_addr_copy(data + wh_len, wh->addr3);
+			ether_addr_copy(data + wh_len + ETH_ALEN, wh->addr4);
+		} else {
+			ether_addr_copy(data + wh_len,
+					ieee80211_get_DA(wh));
+			ether_addr_copy(data + wh_len + ETH_ALEN,
+					ieee80211_get_SA(wh));
+		}
+		*(u8 *)(data + wh_len + ETH_HLEN - 1) = len & 0xff;
+		*(u8 *)(data + wh_len + ETH_HLEN - 2) = (len >> 8) & 0xff;
+		memcpy(data + wh_len + ETH_HLEN, tx_skb->data + wh_len, len);
+
+		skb_put(newskb, tx_skb->len + ETH_HLEN);
+		tx_ctrl->qos_ctrl |= IEEE80211_QOS_CTL_A_MSDU_PRESENT;
+		amsdu_info = IEEE80211_SKB_CB(newskb);
+		memcpy(amsdu_info, tx_info, sizeof(*tx_info));
+		skb_queue_head_init(amsdu_pkts);
+		((struct pcie_tx_ctrl *)&amsdu_info->status)->amsdu_pkts =
+			(void *)amsdu_pkts;
+		amsdu->skb = newskb;
+	} else {
+		amsdu->cur_pos += amsdu->pad;
+		data = amsdu->cur_pos;
+
+		if (sta_info->is_mesh_node) {
+			ether_addr_copy(data, wh->addr3);
+			ether_addr_copy(data + ETH_ALEN, wh->addr4);
+		} else {
+			ether_addr_copy(data, ieee80211_get_DA(wh));
+			ether_addr_copy(data + ETH_ALEN, ieee80211_get_SA(wh));
+		}
+		*(u8 *)(data + ETH_HLEN - 1) = len & 0xff;
+		*(u8 *)(data + ETH_HLEN - 2) = (len >> 8) & 0xff;
+		memcpy(data + ETH_HLEN, tx_skb->data + wh_len, len);
+
+		skb_put(amsdu->skb, len + ETH_HLEN + amsdu->pad);
+		amsdu_info = IEEE80211_SKB_CB(amsdu->skb);
+		amsdu_pkts = (struct sk_buff_head *)
+			((struct pcie_tx_ctrl *)
+			&amsdu_info->status)->amsdu_pkts;
+	}
+
+	amsdu->num++;
+	amsdu->pad = ((len + ETH_HLEN) % 4) ? (4 - (len + ETH_HLEN) % 4) : 0;
+	amsdu->cur_pos = amsdu->skb->data + amsdu->skb->len;
+	skb_queue_tail(amsdu_pkts, tx_skb);
+
+	if (amsdu->num > SYSADPT_AMSDU_PACKET_THRESHOLD) {
+		amsdu->num = 0;
+		amsdu->cur_pos = NULL;
+		spin_unlock_bh(&sta_info->amsdu_lock);
+		return amsdu->skb;
+	}
+
+	spin_unlock_bh(&sta_info->amsdu_lock);
+	return NULL;
+}
+
+static inline void pcie_tx_ack_amsdu_pkts(struct ieee80211_hw *hw, u32 rate,
+					  struct sk_buff_head *amsdu_pkts)
+{
+	struct sk_buff *amsdu_pkt;
+	struct ieee80211_tx_info *info;
+
+	while (skb_queue_len(amsdu_pkts) > 0) {
+		amsdu_pkt = skb_dequeue(amsdu_pkts);
+		info = IEEE80211_SKB_CB(amsdu_pkt);
+		pcie_tx_prepare_info(hw->priv, rate, info);
+		ieee80211_tx_status(hw, amsdu_pkt);
+	}
+
+	kfree(amsdu_pkts);
+}
+
+static void pcie_pfu_tx_done(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	u32 wrdoneidx, rdptr;
+	const u32 num_tx_buffs = PCIE_MAX_TXRX_BD << PCIE_TX_START_PTR;
+	struct pcie_data_buf *data_buf;
+	struct sk_buff *done_skb;
+	struct pcie_pfu_dma_data *pfu_dma;
+	struct pcie_tx_desc *tx_desc;
+	struct pcie_dma_data *dma_data;
+	struct ieee80211_hdr *wh;
+	struct ieee80211_tx_info *info;
+	struct pcie_tx_ctrl *tx_ctrl;
+	struct ieee80211_sta *sta;
+	struct mwl_sta *sta_info;
+	u32 rate = 0;
+	struct sk_buff_head *amsdu_pkts;
+	int hdrlen;
+
+	spin_lock_bh(&pcie_priv->tx_desc_lock);
+	/* Read the TX ring read pointer set by firmware */
+	rdptr = readl(pcie_priv->iobase1 + REG_TXBD_RDPTR);
+	/* free from previous txbd_rdptr to current txbd_rdptr */
+	while (((pcie_priv->txbd_rdptr & PCIE_TXBD_MASK) !=
+	       (rdptr & PCIE_TXBD_MASK)) ||
+	       ((pcie_priv->txbd_rdptr & PCIE_BD_FLAG_TX_ROLLOVER_IND) !=
+	       (rdptr & PCIE_BD_FLAG_TX_ROLLOVER_IND))) {
+		wrdoneidx = pcie_priv->txbd_rdptr & PCIE_TXBD_MASK;
+		wrdoneidx >>= PCIE_TX_START_PTR;
+
+		data_buf = pcie_priv->txbd_ring[wrdoneidx];
+		done_skb = pcie_priv->tx_buf_list[wrdoneidx];
+		if (done_skb) {
+			pfu_dma = (struct pcie_pfu_dma_data *)done_skb->data;
+			tx_desc = &pfu_dma->tx_desc;
+			dma_data = &pfu_dma->dma_data;
+			pci_unmap_single(pcie_priv->pdev,
+					 le32_to_cpu(data_buf->paddr),
+					 le16_to_cpu(data_buf->len),
+					 PCI_DMA_TODEVICE);
+			tx_desc->pkt_ptr = 0;
+			tx_desc->pkt_len = 0;
+			tx_desc->status = cpu_to_le32(EAGLE_TXD_STATUS_IDLE);
+			wmb(); /* memory barrier */
+
+			wh = &dma_data->wh;
+			if (ieee80211_is_nullfunc(wh->frame_control) ||
+			    ieee80211_is_qos_nullfunc(wh->frame_control)) {
+				dev_kfree_skb_any(done_skb);
+				done_skb = NULL;
+				goto next;
+			}
+
+			info = IEEE80211_SKB_CB(done_skb);
+			tx_ctrl = (struct pcie_tx_ctrl *)&info->status;
+			sta = (struct ieee80211_sta *)tx_ctrl->sta;
+			if (sta) {
+				sta_info = mwl_dev_get_sta(sta);
+				rate = sta_info->tx_rate_info;
+			}
+
+			if (ieee80211_is_data(wh->frame_control) ||
+			    ieee80211_is_data_qos(wh->frame_control)) {
+				amsdu_pkts = (struct sk_buff_head *)
+					tx_ctrl->amsdu_pkts;
+				if (amsdu_pkts) {
+					pcie_tx_ack_amsdu_pkts(priv->hw, rate,
+							       amsdu_pkts);
+					dev_kfree_skb_any(done_skb);
+					done_skb = NULL;
+				} else {
+					pcie_tx_prepare_info(priv, rate, info);
+				}
+			} else {
+				pcie_tx_prepare_info(priv, 0, info);
+			}
+
+			if (done_skb) {
+				/* Remove H/W dma header */
+				hdrlen = ieee80211_hdrlen(
+					dma_data->wh.frame_control);
+				memmove(dma_data->data - hdrlen,
+					&dma_data->wh, hdrlen);
+				skb_pull(done_skb, sizeof(*pfu_dma) - hdrlen);
+				ieee80211_tx_status(priv->hw, done_skb);
+			}
+		}
+next:
+		memset(data_buf, 0, sizeof(*data_buf));
+		pcie_priv->tx_buf_list[wrdoneidx] = NULL;
+
+		pcie_priv->txbd_rdptr += PCIE_BD_FLAG_TX_START_PTR;
+		if ((pcie_priv->txbd_rdptr & PCIE_TXBD_MASK) == num_tx_buffs)
+			pcie_priv->txbd_rdptr = ((pcie_priv->txbd_rdptr &
+				PCIE_BD_FLAG_TX_ROLLOVER_IND) ^
+				PCIE_BD_FLAG_TX_ROLLOVER_IND);
+	}
+	spin_unlock_bh(&pcie_priv->tx_desc_lock);
+
+	if (pcie_priv->is_tx_done_schedule) {
+		pcie_mask_int(pcie_priv, MACREG_A2HRIC_BIT_TX_DONE, true);
+		tasklet_schedule(&pcie_priv->tx_task);
+		pcie_priv->is_tx_done_schedule = false;
+	}
+}
+
+static void pcie_non_pfu_tx_done(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int num;
+	struct pcie_desc_data *desc;
+	struct pcie_tx_hndl *tx_hndl;
+	struct pcie_tx_desc *tx_desc;
+	struct sk_buff *done_skb;
+	int idx;
+	u32 rate;
+	struct pcie_dma_data *dma_data;
+	struct ieee80211_hdr *wh;
+	struct ieee80211_tx_info *info;
+	struct pcie_tx_ctrl *tx_ctrl;
+	struct sk_buff_head *amsdu_pkts;
+	int hdrlen;
+
+	spin_lock_bh(&pcie_priv->tx_desc_lock);
+	for (num = 0; num < SYSADPT_TX_WMM_QUEUES; num++) {
+		desc = &pcie_priv->desc_data[num];
+		tx_hndl = desc->pstale_tx_hndl;
+		tx_desc = tx_hndl->pdesc;
+
+		if ((tx_desc->status &
+		    cpu_to_le32(EAGLE_TXD_STATUS_FW_OWNED)) &&
+		    (tx_hndl->pnext->pdesc->status &
+		    cpu_to_le32(EAGLE_TXD_STATUS_OK)))
+			tx_desc->status = cpu_to_le32(EAGLE_TXD_STATUS_OK);
+
+		while (tx_hndl &&
+		       (tx_desc->status & cpu_to_le32(EAGLE_TXD_STATUS_OK)) &&
+		       (!(tx_desc->status &
+		       cpu_to_le32(EAGLE_TXD_STATUS_FW_OWNED)))) {
+			pci_unmap_single(pcie_priv->pdev,
+					 le32_to_cpu(tx_desc->pkt_ptr),
+					 le16_to_cpu(tx_desc->pkt_len),
+					 PCI_DMA_TODEVICE);
+			done_skb = tx_hndl->psk_buff;
+			rate = le32_to_cpu(tx_desc->rate_info);
+			tx_desc->pkt_ptr = 0;
+			tx_desc->pkt_len = 0;
+			tx_desc->status =
+				cpu_to_le32(EAGLE_TXD_STATUS_IDLE);
+			tx_hndl->psk_buff = NULL;
+			wmb(); /*Data Memory Barrier*/
+
+			skb_get(done_skb);
+			idx = pcie_priv->delay_q_idx;
+			if (pcie_priv->delay_q[idx])
+				dev_kfree_skb_any(pcie_priv->delay_q[idx]);
+			pcie_priv->delay_q[idx] = done_skb;
+			idx++;
+			if (idx >= PCIE_DELAY_FREE_Q_LIMIT)
+				idx = 0;
+			pcie_priv->delay_q_idx = idx;
+
+			dma_data = (struct pcie_dma_data *)done_skb->data;
+			wh = &dma_data->wh;
+			if (ieee80211_is_nullfunc(wh->frame_control) ||
+			    ieee80211_is_qos_nullfunc(wh->frame_control)) {
+				dev_kfree_skb_any(done_skb);
+				done_skb = NULL;
+				goto next;
+			}
+
+			info = IEEE80211_SKB_CB(done_skb);
+			if (ieee80211_is_data(wh->frame_control) ||
+			    ieee80211_is_data_qos(wh->frame_control)) {
+				tx_ctrl = (struct pcie_tx_ctrl *)&info->status;
+				amsdu_pkts = (struct sk_buff_head *)
+					tx_ctrl->amsdu_pkts;
+				if (amsdu_pkts) {
+					pcie_tx_ack_amsdu_pkts(priv->hw, rate,
+							       amsdu_pkts);
+					dev_kfree_skb_any(done_skb);
+					done_skb = NULL;
+				} else {
+					pcie_tx_prepare_info(priv, rate, info);
+				}
+			} else {
+				pcie_tx_prepare_info(priv, 0, info);
+			}
+
+			if (done_skb) {
+				/* Remove H/W dma header */
+				hdrlen = ieee80211_hdrlen(
+					dma_data->wh.frame_control);
+				memmove(dma_data->data - hdrlen,
+					&dma_data->wh, hdrlen);
+				skb_pull(done_skb, sizeof(*dma_data) - hdrlen);
+				ieee80211_tx_status(priv->hw, done_skb);
+			}
+next:
+			tx_hndl = tx_hndl->pnext;
+			tx_desc = tx_hndl->pdesc;
+			pcie_priv->fw_desc_cnt[num]--;
+		}
+
+		desc->pstale_tx_hndl = tx_hndl;
+	}
+	spin_unlock_bh(&pcie_priv->tx_desc_lock);
+
+	if (pcie_priv->is_tx_done_schedule) {
+		pcie_mask_int(pcie_priv, MACREG_A2HRIC_BIT_TX_DONE, true);
+		tasklet_schedule(&pcie_priv->tx_task);
+		pcie_priv->is_tx_done_schedule = false;
+	}
+}
+
+int pcie_tx_init(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int rc;
+	int i;
+
+	if (priv->chip_type == MWL8997)
+		rc = pcie_txbd_ring_create(priv);
+	else
+		rc = pcie_tx_ring_alloc(priv);
+
+	if (rc) {
+		wiphy_err(hw->wiphy, "allocating TX ring failed\n");
+		return rc;
+	}
+
+	rc = pcie_tx_ring_init(priv);
+	if (rc) {
+		pcie_tx_ring_free(priv);
+		wiphy_err(hw->wiphy, "initializing TX ring failed\n");
+		return rc;
+	}
+
+	pcie_priv->delay_q_idx = 0;
+	for (i = 0; i < PCIE_DELAY_FREE_Q_LIMIT; i++)
+		pcie_priv->delay_q[i] = NULL;
+
+	return 0;
+}
+
+void pcie_tx_deinit(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int i;
+
+	for (i = 0; i < PCIE_DELAY_FREE_Q_LIMIT; i++)
+		if (pcie_priv->delay_q[i])
+			dev_kfree_skb_any(pcie_priv->delay_q[i]);
+
+	pcie_tx_ring_cleanup(priv);
+
+	if (priv->chip_type == MWL8997)
+		pcie_txbd_ring_delete(priv);
+	else
+		pcie_tx_ring_free(priv);
+}
+
+void pcie_tx_skbs(unsigned long data)
+{
+	struct ieee80211_hw *hw = (struct ieee80211_hw *)data;
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int num = SYSADPT_TX_WMM_QUEUES;
+	struct sk_buff *tx_skb;
+
+	spin_lock_bh(&pcie_priv->tx_desc_lock);
+	while (num--) {
+		while (skb_queue_len(&pcie_priv->txq[num]) > 0) {
+			struct ieee80211_tx_info *tx_info;
+			struct pcie_tx_ctrl *tx_ctrl;
+
+			if (!pcie_tx_available(priv, num))
+				break;
+
+			tx_skb = skb_dequeue(&pcie_priv->txq[num]);
+			if (!tx_skb)
+				continue;
+			tx_info = IEEE80211_SKB_CB(tx_skb);
+			tx_ctrl = (struct pcie_tx_ctrl *)&tx_info->status;
+
+			if (tx_ctrl->tx_priority >= SYSADPT_TX_WMM_QUEUES)
+				tx_skb = pcie_tx_do_amsdu(priv, num,
+							  tx_skb, tx_info);
+
+			if (tx_skb) {
+				if (pcie_tx_available(priv, num))
+					pcie_tx_skb(priv, num, tx_skb);
+				else
+					skb_queue_head(&pcie_priv->txq[num],
+						       tx_skb);
+			}
+		}
+
+		if (skb_queue_len(&pcie_priv->txq[num]) <
+		    pcie_priv->txq_wake_threshold) {
+			int queue;
+
+			queue = SYSADPT_TX_WMM_QUEUES - num - 1;
+			if (ieee80211_queue_stopped(hw, queue))
+				ieee80211_wake_queue(hw, queue);
+		}
+	}
+	spin_unlock_bh(&pcie_priv->tx_desc_lock);
+}
+
+void pcie_tx_flush_amsdu(unsigned long data)
+{
+	struct ieee80211_hw *hw = (struct ieee80211_hw *)data;
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct mwl_sta *sta_info;
+	int i;
+	struct mwl_amsdu_frag *amsdu_frag;
+
+	spin_lock(&priv->sta_lock);
+	list_for_each_entry(sta_info, &priv->sta_list, list) {
+		spin_lock(&pcie_priv->tx_desc_lock);
+		spin_lock(&sta_info->amsdu_lock);
+		for (i = 0; i < SYSADPT_TX_WMM_QUEUES; i++) {
+			amsdu_frag = &sta_info->amsdu_ctrl.frag[i];
+			if (amsdu_frag->num) {
+				if (time_after(jiffies,
+					       (amsdu_frag->jiffies + 1))) {
+					if (pcie_tx_available(priv, i)) {
+						pcie_tx_skb(priv, i,
+							    amsdu_frag->skb);
+						amsdu_frag->num = 0;
+						amsdu_frag->cur_pos = NULL;
+					}
+				}
+			}
+		}
+		spin_unlock(&sta_info->amsdu_lock);
+		spin_unlock(&pcie_priv->tx_desc_lock);
+	}
+	spin_unlock(&priv->sta_lock);
+
+	pcie_mask_int(pcie_priv, MACREG_A2HRIC_BIT_QUE_EMPTY, true);
+	pcie_priv->is_qe_schedule = false;
+}
+
+void pcie_tx_done(unsigned long data)
+{
+	struct ieee80211_hw *hw = (struct ieee80211_hw *)data;
+	struct mwl_priv *priv = hw->priv;
+
+	if (priv->chip_type == MWL8997)
+		pcie_pfu_tx_done(priv);
+	else
+		pcie_non_pfu_tx_done(priv);
+}
+
+void pcie_tx_xmit(struct ieee80211_hw *hw,
+		  struct ieee80211_tx_control *control,
+		  struct sk_buff *skb)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int index;
+	struct ieee80211_sta *sta;
+	struct ieee80211_tx_info *tx_info;
+	struct mwl_vif *mwl_vif;
+	struct ieee80211_hdr *wh;
+	u8 xmitcontrol;
+	u16 qos;
+	int txpriority;
+	u8 tid = 0;
+	struct mwl_ampdu_stream *stream = NULL;
+	bool start_ba_session = false;
+	bool mgmtframe = false;
+	struct ieee80211_mgmt *mgmt;
+	bool eapol_frame = false;
+	struct pcie_tx_ctrl *tx_ctrl;
+	struct ieee80211_key_conf *k_conf = NULL;
+	int rc;
+
+	index = skb_get_queue_mapping(skb);
+	sta = control->sta;
+
+	wh = (struct ieee80211_hdr *)skb->data;
+	tx_info = IEEE80211_SKB_CB(skb);
+	mwl_vif = mwl_dev_get_vif(tx_info->control.vif);
+
+	if (ieee80211_is_data_qos(wh->frame_control))
+		qos = le16_to_cpu(*((__le16 *)ieee80211_get_qos_ctl(wh)));
+	else
+		qos = 0;
+
+	if (ieee80211_is_mgmt(wh->frame_control)) {
+		mgmtframe = true;
+		mgmt = (struct ieee80211_mgmt *)skb->data;
+	} else {
+		u16 pkt_type;
+		struct mwl_sta *sta_info;
+
+		pkt_type = be16_to_cpu(*((__be16 *)
+			&skb->data[ieee80211_hdrlen(wh->frame_control) + 6]));
+		if (pkt_type == ETH_P_PAE) {
+			index = IEEE80211_AC_VO;
+			eapol_frame = true;
+		}
+		if (sta) {
+			if (mwl_vif->is_hw_crypto_enabled) {
+				sta_info = mwl_dev_get_sta(sta);
+				if (!sta_info->is_key_set && !eapol_frame) {
+					dev_kfree_skb_any(skb);
+					return;
+				}
+			}
+		}
+	}
+
+	if (tx_info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {
+		wh->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);
+		wh->seq_ctrl |= cpu_to_le16(mwl_vif->seqno);
+		mwl_vif->seqno += 0x10;
+	}
+
+	/* Setup firmware control bit fields for each frame type. */
+	xmitcontrol = 0;
+
+	if (mgmtframe || ieee80211_is_ctl(wh->frame_control)) {
+		qos = 0;
+	} else if (ieee80211_is_data(wh->frame_control)) {
+		qos &= ~MWL_QOS_ACK_POLICY_MASK;
+
+		if (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {
+			xmitcontrol &= 0xfb;
+			qos |= MWL_QOS_ACK_POLICY_BLOCKACK;
+		} else {
+			xmitcontrol |= 0x4;
+			qos |= MWL_QOS_ACK_POLICY_NORMAL;
+		}
+
+		if (is_multicast_ether_addr(wh->addr1) || eapol_frame)
+			xmitcontrol |= EAGLE_TXD_XMITCTRL_USE_MC_RATE;
+	}
+
+	k_conf = tx_info->control.hw_key;
+
+	/* Queue ADDBA request in the respective data queue.  While setting up
+	 * the ampdu stream, mac80211 queues further packets for that
+	 * particular ra/tid pair.  However, packets piled up in the hardware
+	 * for that ra/tid pair will still go out. ADDBA request and the
+	 * related data packets going out from different queues asynchronously
+	 * will cause a shift in the receiver window which might result in
+	 * ampdu packets getting dropped at the receiver after the stream has
+	 * been setup.
+	 */
+	if (mgmtframe) {
+		u16 capab;
+
+		if (unlikely(ieee80211_is_action(wh->frame_control) &&
+			     mgmt->u.action.category == WLAN_CATEGORY_BACK &&
+			     mgmt->u.action.u.addba_req.action_code ==
+			     WLAN_ACTION_ADDBA_REQ)) {
+			capab = le16_to_cpu(mgmt->u.action.u.addba_req.capab);
+			tid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;
+			index = utils_tid_to_ac(tid);
+		}
+
+		if (unlikely(ieee80211_is_assoc_req(wh->frame_control)))
+			utils_add_basic_rates(hw->conf.chandef.chan->band, skb);
+	}
+
+	index = SYSADPT_TX_WMM_QUEUES - index - 1;
+	txpriority = index;
+
+	if (sta && sta->ht_cap.ht_supported && !eapol_frame &&
+	    ieee80211_is_data_qos(wh->frame_control)) {
+		tid = qos & 0xf;
+		pcie_tx_count_packet(sta, tid);
+
+		spin_lock_bh(&priv->stream_lock);
+		stream = mwl_fwcmd_lookup_stream(hw, sta, tid);
+
+		if (stream) {
+			if (stream->state == AMPDU_STREAM_ACTIVE) {
+				if (WARN_ON(!(qos &
+					    MWL_QOS_ACK_POLICY_BLOCKACK))) {
+					spin_unlock_bh(&priv->stream_lock);
+					dev_kfree_skb_any(skb);
+					return;
+				}
+
+				txpriority =
+					(SYSADPT_TX_WMM_QUEUES + stream->idx) %
+					TOTAL_HW_QUEUES;
+			} else if (stream->state == AMPDU_STREAM_NEW) {
+				/* We get here if the driver sends us packets
+				 * after we've initiated a stream, but before
+				 * our ampdu_action routine has been called
+				 * with IEEE80211_AMPDU_TX_START to get the SSN
+				 * for the ADDBA request.  So this packet can
+				 * go out with no risk of sequence number
+				 * mismatch.  No special handling is required.
+				 */
+			} else {
+				/* Drop packets that would go out after the
+				 * ADDBA request was sent but before the ADDBA
+				 * response is received.  If we don't do this,
+				 * the recipient would probably receive it
+				 * after the ADDBA request with SSN 0.  This
+				 * will cause the recipient's BA receive window
+				 * to shift, which would cause the subsequent
+				 * packets in the BA stream to be discarded.
+				 * mac80211 queues our packets for us in this
+				 * case, so this is really just a safety check.
+				 */
+				wiphy_warn(hw->wiphy,
+					   "can't send packet during ADDBA\n");
+				spin_unlock_bh(&priv->stream_lock);
+				dev_kfree_skb_any(skb);
+				return;
+			}
+		} else {
+			if (mwl_fwcmd_ampdu_allowed(sta, tid)) {
+				stream = mwl_fwcmd_add_stream(hw, sta, tid);
+
+				if (stream)
+					start_ba_session = true;
+			}
+		}
+
+		spin_unlock_bh(&priv->stream_lock);
+	} else {
+		qos &= ~MWL_QOS_ACK_POLICY_MASK;
+		qos |= MWL_QOS_ACK_POLICY_NORMAL;
+	}
+
+	tx_ctrl = (struct pcie_tx_ctrl *)&tx_info->status;
+	tx_ctrl->vif = (void *)tx_info->control.vif;
+	tx_ctrl->sta = (void *)sta;
+	tx_ctrl->k_conf = (void *)k_conf;
+	tx_ctrl->amsdu_pkts = NULL;
+	tx_ctrl->tx_priority = txpriority;
+	tx_ctrl->type = (mgmtframe ? IEEE_TYPE_MANAGEMENT : IEEE_TYPE_DATA);
+	tx_ctrl->qos_ctrl = qos;
+	tx_ctrl->xmit_control = xmitcontrol;
+
+	if (skb_queue_len(&pcie_priv->txq[index]) > pcie_priv->txq_limit)
+		ieee80211_stop_queue(hw, SYSADPT_TX_WMM_QUEUES - index - 1);
+
+	skb_queue_tail(&pcie_priv->txq[index], skb);
+
+	tasklet_schedule(&pcie_priv->tx_task);
+
+	/* Initiate the ampdu session here */
+	if (start_ba_session) {
+		spin_lock_bh(&priv->stream_lock);
+		rc = mwl_fwcmd_start_stream(hw, stream);
+		if (rc)
+			mwl_fwcmd_remove_stream(hw, stream);
+		else
+			wiphy_debug(hw->wiphy, "Mac80211 start BA %pM\n",
+				    stream->sta->addr);
+		spin_unlock_bh(&priv->stream_lock);
+	}
+}
+
+void pcie_tx_del_pkts_via_vif(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int num;
+	struct sk_buff *skb, *tmp;
+	struct ieee80211_tx_info *tx_info;
+	struct pcie_tx_ctrl *tx_ctrl;
+	struct sk_buff_head *amsdu_pkts;
+	unsigned long flags;
+
+	for (num = 1; num < PCIE_NUM_OF_DESC_DATA; num++) {
+		spin_lock_irqsave(&pcie_priv->txq[num].lock, flags);
+		skb_queue_walk_safe(&pcie_priv->txq[num], skb, tmp) {
+			tx_info = IEEE80211_SKB_CB(skb);
+			tx_ctrl = (struct pcie_tx_ctrl *)&tx_info->status;
+			if (tx_ctrl->vif == vif) {
+				amsdu_pkts = (struct sk_buff_head *)
+					tx_ctrl->amsdu_pkts;
+				if (amsdu_pkts) {
+					skb_queue_purge(amsdu_pkts);
+					kfree(amsdu_pkts);
+				}
+				__skb_unlink(skb, &pcie_priv->txq[num]);
+				dev_kfree_skb_any(skb);
+			}
+		}
+		spin_unlock_irqrestore(&pcie_priv->txq[num].lock, flags);
+	}
+}
+
+void pcie_tx_del_pkts_via_sta(struct ieee80211_hw *hw,
+			      struct ieee80211_sta *sta)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int num;
+	struct sk_buff *skb, *tmp;
+	struct ieee80211_tx_info *tx_info;
+	struct pcie_tx_ctrl *tx_ctrl;
+	struct sk_buff_head *amsdu_pkts;
+	unsigned long flags;
+
+	for (num = 1; num < PCIE_NUM_OF_DESC_DATA; num++) {
+		spin_lock_irqsave(&pcie_priv->txq[num].lock, flags);
+		skb_queue_walk_safe(&pcie_priv->txq[num], skb, tmp) {
+			tx_info = IEEE80211_SKB_CB(skb);
+			tx_ctrl = (struct pcie_tx_ctrl *)&tx_info->status;
+			if (tx_ctrl->sta == sta) {
+				amsdu_pkts = (struct sk_buff_head *)
+					tx_ctrl->amsdu_pkts;
+				if (amsdu_pkts) {
+					skb_queue_purge(amsdu_pkts);
+					kfree(amsdu_pkts);
+				}
+				__skb_unlink(skb, &pcie_priv->txq[num]);
+				dev_kfree_skb_any(skb);
+			}
+		}
+		spin_unlock_irqrestore(&pcie_priv->txq[num].lock, flags);
+	}
+}
+
+void pcie_tx_del_ampdu_pkts(struct ieee80211_hw *hw,
+			    struct ieee80211_sta *sta, u8 tid)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct mwl_sta *sta_info = mwl_dev_get_sta(sta);
+	int ac, desc_num;
+	struct mwl_amsdu_frag *amsdu_frag;
+	struct sk_buff *skb, *tmp;
+	struct ieee80211_tx_info *tx_info;
+	struct pcie_tx_ctrl *tx_ctrl;
+	struct sk_buff_head *amsdu_pkts;
+	unsigned long flags;
+
+	ac = utils_tid_to_ac(tid);
+	desc_num = SYSADPT_TX_WMM_QUEUES - ac - 1;
+	spin_lock_irqsave(&pcie_priv->txq[desc_num].lock, flags);
+	skb_queue_walk_safe(&pcie_priv->txq[desc_num], skb, tmp) {
+		tx_info = IEEE80211_SKB_CB(skb);
+		tx_ctrl = (struct pcie_tx_ctrl *)&tx_info->status;
+		if (tx_ctrl->sta == sta) {
+			amsdu_pkts = (struct sk_buff_head *)
+				tx_ctrl->amsdu_pkts;
+			if (amsdu_pkts) {
+				skb_queue_purge(amsdu_pkts);
+				kfree(amsdu_pkts);
+			}
+			__skb_unlink(skb, &pcie_priv->txq[desc_num]);
+			dev_kfree_skb_any(skb);
+		}
+	}
+	spin_unlock_irqrestore(&pcie_priv->txq[desc_num].lock, flags);
+
+	spin_lock_bh(&sta_info->amsdu_lock);
+	amsdu_frag = &sta_info->amsdu_ctrl.frag[desc_num];
+	if (amsdu_frag->num) {
+		amsdu_frag->num = 0;
+		amsdu_frag->cur_pos = NULL;
+		if (amsdu_frag->skb) {
+			tx_info = IEEE80211_SKB_CB(amsdu_frag->skb);
+			tx_ctrl = (struct pcie_tx_ctrl *)&tx_info->status;
+			amsdu_pkts = (struct sk_buff_head *)
+				tx_ctrl->amsdu_pkts;
+			if (amsdu_pkts) {
+				skb_queue_purge(amsdu_pkts);
+				kfree(amsdu_pkts);
+			}
+			dev_kfree_skb_any(amsdu_frag->skb);
+		}
+	}
+	spin_unlock_bh(&sta_info->amsdu_lock);
+}
+
+void pcie_tx_del_sta_amsdu_pkts(struct ieee80211_hw *hw,
+				struct ieee80211_sta *sta)
+{
+	struct mwl_sta *sta_info = mwl_dev_get_sta(sta);
+	int num;
+	struct mwl_amsdu_frag *amsdu_frag;
+	struct ieee80211_tx_info *tx_info;
+	struct pcie_tx_ctrl *tx_ctrl;
+	struct sk_buff_head *amsdu_pkts;
+
+	spin_lock_bh(&sta_info->amsdu_lock);
+	for (num = 0; num < SYSADPT_TX_WMM_QUEUES; num++) {
+		amsdu_frag = &sta_info->amsdu_ctrl.frag[num];
+		if (amsdu_frag->num) {
+			amsdu_frag->num = 0;
+			amsdu_frag->cur_pos = NULL;
+			if (amsdu_frag->skb) {
+				tx_info = IEEE80211_SKB_CB(amsdu_frag->skb);
+				tx_ctrl = (struct pcie_tx_ctrl *)
+					&tx_info->status;
+				amsdu_pkts = (struct sk_buff_head *)
+					tx_ctrl->amsdu_pkts;
+				if (amsdu_pkts) {
+					skb_queue_purge(amsdu_pkts);
+					kfree(amsdu_pkts);
+				}
+				dev_kfree_skb_any(amsdu_frag->skb);
+			}
+		}
+	}
+	spin_unlock_bh(&sta_info->amsdu_lock);
+}
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx.h b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx.h
new file mode 100644
index 000000000000..c233ba1aaa9d
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines transmit related functions. */
+
+#ifndef _TX_H_
+#define _TX_H_
+
+int pcie_tx_init(struct ieee80211_hw *hw);
+void pcie_tx_deinit(struct ieee80211_hw *hw);
+void pcie_tx_skbs(unsigned long data);
+void pcie_tx_done(unsigned long data);
+void pcie_tx_flush_amsdu(unsigned long data);
+void pcie_tx_xmit(struct ieee80211_hw *hw,
+		  struct ieee80211_tx_control *control,
+		  struct sk_buff *skb);
+void pcie_tx_del_pkts_via_vif(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif);
+void pcie_tx_del_pkts_via_sta(struct ieee80211_hw *hw,
+			      struct ieee80211_sta *sta);
+void pcie_tx_del_ampdu_pkts(struct ieee80211_hw *hw,
+			    struct ieee80211_sta *sta, u8 tid);
+void pcie_tx_del_sta_amsdu_pkts(struct ieee80211_hw *hw,
+				struct ieee80211_sta *sta);
+
+#endif /* _TX_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx_ndp.c b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx_ndp.c
new file mode 100644
index 000000000000..6758cde363c6
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx_ndp.c
@@ -0,0 +1,693 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements transmit related functions for new data
+ * path.
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "utils.h"
+#include "hif/fwcmd.h"
+#include "hif/pcie/dev.h"
+#include "hif/pcie/tx_ndp.h"
+
+#define MAX_NUM_TX_RING_BYTES   (MAX_NUM_TX_DESC * \
+				sizeof(struct pcie_tx_desc_ndp))
+#define MAX_NUM_TX_RING_DONE_BYTES (MAX_NUM_TX_DESC * \
+				sizeof(struct tx_ring_done))
+#define QUEUE_STAOFFSET         ((SYSADPT_NUM_OF_AP - 1) + \
+				SYSADPT_NUM_OF_CLIENT)
+#define PROBE_RESPONSE_TXQNUM   ((SYSADPT_MAX_STA_SC4 + SYSADPT_NUM_OF_AP + \
+				SYSADPT_NUM_OF_CLIENT) * SYSADPT_MAX_TID)
+#define MGMT_TXQNUM             ((PROBE_RESPONSE_TXQNUM + 1))
+#define TXDONE_THRESHOLD        4
+
+#define TX_CTRL_TYPE_DATA       BIT(0)
+#define TX_CTRL_EAPOL           BIT(1)
+#define TX_CTRL_TCP_ACK         BIT(2)
+
+/* Transmission information to transmit a socket buffer.
+ */
+struct pcie_tx_ctrl_ndp {
+	u16 tx_que_priority;
+	u8 hdrlen;
+	u8 flags;
+	u32 rate;
+	u32 tcp_dst_src;
+	u32 tcp_sn;
+} __packed;
+
+static int pcie_tx_ring_alloc_ndp(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+	u8 *mem;
+
+	mem = dma_alloc_coherent(priv->dev,
+				 MAX_NUM_TX_RING_BYTES,
+				 &desc->pphys_tx_ring,
+				 GFP_KERNEL);
+	if (!mem)
+		goto err_no_mem;
+	desc->ptx_ring = (struct pcie_tx_desc_ndp *)mem;
+	memset(desc->ptx_ring, 0x00, MAX_NUM_TX_RING_BYTES);
+
+	mem = dma_alloc_coherent(priv->dev,
+				 MAX_NUM_TX_RING_DONE_BYTES,
+				 &desc->pphys_tx_ring_done,
+				 GFP_KERNEL);
+	if (!mem)
+		goto err_no_mem;
+	desc->ptx_ring_done = (struct tx_ring_done *)mem;
+	memset(desc->ptx_ring_done, 0x00, MAX_NUM_TX_RING_DONE_BYTES);
+
+	mem = dma_alloc_coherent(priv->dev,
+				 DEFAULT_ACNT_RING_SIZE,
+				 &desc->pphys_acnt_ring,
+				 GFP_KERNEL);
+	if (!mem)
+		goto err_no_mem;
+	desc->pacnt_ring = (u8 *)mem;
+	memset(desc->pacnt_ring, 0x00, DEFAULT_ACNT_RING_SIZE);
+
+	desc->pacnt_buf = kzalloc(DEFAULT_ACNT_RING_SIZE, GFP_KERNEL);
+	if (!desc->pacnt_buf)
+		goto err_no_mem;
+	desc->acnt_ring_size = DEFAULT_ACNT_RING_SIZE;
+
+	return 0;
+
+err_no_mem:
+
+	wiphy_err(priv->hw->wiphy, "cannot alloc mem\n");
+
+	return -ENOMEM;
+}
+
+static int pcie_tx_ring_init_ndp(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+	int i;
+
+	for (i = 0; i < PCIE_NUM_OF_DESC_DATA; i++)
+		skb_queue_head_init(&pcie_priv->txq[i]);
+
+	if (!desc->ptx_ring) {
+		for (i = 0; i < MAX_NUM_TX_DESC; i++)
+			desc->ptx_ring[i].user = cpu_to_le32(i);
+		desc->tx_desc_busy_cnt = 0;
+	}
+
+	return 0;
+}
+
+static void pcie_tx_ring_cleanup_ndp(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+	struct sk_buff *tx_skb;
+	int i;
+
+	for (i = 0; i < PCIE_NUM_OF_DESC_DATA; i++)
+		skb_queue_purge(&pcie_priv->txq[i]);
+
+	for (i = 0; i < MAX_TX_RING_SEND_SIZE; i++) {
+		tx_skb = desc->tx_vbuflist[i];
+		if (tx_skb) {
+			pci_unmap_single(pcie_priv->pdev,
+					 desc->pphys_tx_buflist[i],
+					 tx_skb->len,
+					 PCI_DMA_TODEVICE);
+			dev_kfree_skb_any(tx_skb);
+			desc->pphys_tx_buflist[i] = 0;
+			desc->tx_vbuflist[i] = NULL;
+		}
+	}
+	desc->tx_sent_tail = 0;
+	desc->tx_sent_head = 0;
+	desc->tx_done_tail = 0;
+	desc->tx_vbuflist_idx = 0;
+	desc->tx_desc_busy_cnt = 0;
+}
+
+static void pcie_tx_ring_free_ndp(struct mwl_priv *priv)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+
+	if (desc->ptx_ring) {
+		dma_free_coherent(priv->dev,
+				  MAX_NUM_TX_RING_BYTES,
+				  desc->ptx_ring,
+				  desc->pphys_tx_ring);
+		desc->ptx_ring = NULL;
+	}
+
+	if (desc->ptx_ring_done) {
+		dma_free_coherent(priv->dev,
+				  MAX_NUM_TX_RING_DONE_BYTES,
+				  desc->ptx_ring_done,
+				  desc->pphys_tx_ring_done);
+		desc->prx_ring_done = NULL;
+	}
+
+	if (desc->pacnt_ring) {
+		dma_free_coherent(priv->dev,
+				  DEFAULT_ACNT_RING_SIZE,
+				  desc->pacnt_ring,
+				  desc->pphys_acnt_ring);
+		desc->pacnt_ring = NULL;
+	}
+
+	kfree(desc->pacnt_buf);
+}
+
+static inline u32 pcie_tx_set_skb(struct mwl_priv *priv, struct sk_buff *skb,
+				  dma_addr_t dma)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+	u32 index = desc->tx_vbuflist_idx;
+
+	while (desc->tx_vbuflist[index])
+		index = (index + 1) % MAX_TX_RING_SEND_SIZE;
+
+	desc->tx_vbuflist_idx = (index + 1) % MAX_TX_RING_SEND_SIZE;
+	desc->pphys_tx_buflist[index] = dma;
+	desc->tx_vbuflist[index] = skb;
+
+	return index;
+}
+
+static inline int pcie_tx_skb_ndp(struct mwl_priv *priv,
+				  struct sk_buff *tx_skb)
+{
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+	u32 tx_send_tail;
+	u32 tx_send_head_new;
+	struct ieee80211_tx_info *tx_info;
+	struct pcie_tx_ctrl_ndp *tx_ctrl;
+	struct pcie_tx_desc_ndp *pnext_tx_desc;
+	struct ieee80211_hdr *wh;
+	u32 ctrl = 0;
+	dma_addr_t dma;
+
+	spin_lock_bh(&pcie_priv->tx_desc_lock);
+
+	tx_send_tail = desc->tx_sent_tail;
+	tx_send_head_new = desc->tx_sent_head;
+
+	if (((tx_send_head_new + 1) & (MAX_NUM_TX_DESC-1)) == tx_send_tail) {
+		/* Update the tx_send_tail */
+		tx_send_tail = readl(pcie_priv->iobase1 +
+				     MACREG_REG_TXSEDNTAIL);
+		desc->tx_sent_tail = tx_send_tail;
+
+		if (((tx_send_head_new + 1) & (MAX_NUM_TX_DESC-1)) ==
+		    tx_send_tail) {
+			spin_unlock_bh(&pcie_priv->tx_desc_lock);
+			return -EAGAIN;
+		}
+	}
+
+	tx_info = IEEE80211_SKB_CB(tx_skb);
+	tx_ctrl = (struct pcie_tx_ctrl_ndp *)tx_info->status.status_driver_data;
+	pnext_tx_desc = &desc->ptx_ring[tx_send_head_new];
+
+	if (tx_ctrl->flags & TX_CTRL_TYPE_DATA) {
+		wh = (struct ieee80211_hdr *)tx_skb->data;
+
+		skb_pull(tx_skb, tx_ctrl->hdrlen);
+		ether_addr_copy(pnext_tx_desc->u.sa,
+				ieee80211_get_SA(wh));
+		ether_addr_copy(pnext_tx_desc->u.da,
+				ieee80211_get_DA(wh));
+
+		if (tx_ctrl->flags & TX_CTRL_EAPOL)
+			ctrl = TXRING_CTRL_TAG_EAP << TXRING_CTRL_TAG_SHIFT;
+		if (tx_ctrl->flags & TX_CTRL_TCP_ACK) {
+			pnext_tx_desc->tcp_dst_src =
+				cpu_to_le32(tx_ctrl->tcp_dst_src);
+			pnext_tx_desc->tcp_sn = cpu_to_le32(tx_ctrl->tcp_sn);
+			ctrl = TXRING_CTRL_TAG_TCP_ACK << TXRING_CTRL_TAG_SHIFT;
+		}
+		ctrl |= (((tx_ctrl->tx_que_priority & TXRING_CTRL_QID_MASK) <<
+			TXRING_CTRL_QID_SHIFT) |
+			((tx_skb->len & TXRING_CTRL_LEN_MASK) <<
+			TXRING_CTRL_LEN_SHIFT));
+	} else {
+		/* Assigning rate code; use legacy 6mbps rate. */
+		pnext_tx_desc->u.rate_code = cpu_to_le16(RATECODE_TYPE_LEGACY +
+			(0 << RATECODE_MCS_SHIFT) + RATECODE_BW_20MHZ);
+		pnext_tx_desc->u.max_retry = 5;
+
+		ctrl = (((tx_ctrl->tx_que_priority & TXRING_CTRL_QID_MASK) <<
+			TXRING_CTRL_QID_SHIFT) |
+			(((tx_skb->len - sizeof(struct pcie_dma_data)) &
+			TXRING_CTRL_LEN_MASK) << TXRING_CTRL_LEN_SHIFT) |
+			(TXRING_CTRL_TAG_MGMT << TXRING_CTRL_TAG_SHIFT));
+	}
+
+	dma = pci_map_single(pcie_priv->pdev, tx_skb->data,
+			     tx_skb->len, PCI_DMA_TODEVICE);
+	if (pci_dma_mapping_error(pcie_priv->pdev, dma)) {
+		dev_kfree_skb_any(tx_skb);
+		wiphy_err(priv->hw->wiphy,
+			  "failed to map pci memory!\n");
+		spin_unlock_bh(&pcie_priv->tx_desc_lock);
+		return -EIO;
+	}
+
+	pnext_tx_desc->data = cpu_to_le32(dma);
+	pnext_tx_desc->ctrl = cpu_to_le32(ctrl);
+	pnext_tx_desc->user = cpu_to_le32(pcie_tx_set_skb(priv, tx_skb, dma));
+
+	if ((tx_ctrl->flags & TX_CTRL_TYPE_DATA) &&
+	    (tx_ctrl->rate != 0)) {
+		skb_push(tx_skb, tx_ctrl->hdrlen);
+		skb_get(tx_skb);
+		pcie_tx_prepare_info(priv, tx_ctrl->rate, tx_info);
+		tx_ctrl->flags |= TX_CTRL_TYPE_DATA;
+		ieee80211_tx_status(priv->hw, tx_skb);
+	}
+
+	if (++tx_send_head_new >= MAX_NUM_TX_DESC)
+		tx_send_head_new = 0;
+	desc->tx_sent_head = tx_send_head_new;
+	wmb(); /*Data Memory Barrier*/
+	writel(tx_send_head_new, pcie_priv->iobase1 + MACREG_REG_TXSENDHEAD);
+	desc->tx_desc_busy_cnt++;
+
+	spin_unlock_bh(&pcie_priv->tx_desc_lock);
+
+	return 0;
+}
+
+static inline void pcie_tx_check_tcp_ack(struct sk_buff *tx_skb,
+					 struct pcie_tx_ctrl_ndp *tx_ctrl)
+{
+	struct iphdr *iph;
+	struct tcphdr *tcph;
+
+	if (tx_ctrl->flags & TX_CTRL_TYPE_DATA) {
+		iph = (struct iphdr *)(tx_skb->data + tx_ctrl->hdrlen + 8);
+		tcph = (struct tcphdr *)((u8 *)iph + (iph->ihl * 4));
+		if ((iph->protocol == IPPROTO_TCP) &&
+		    (tx_skb->protocol == htons(ETH_P_IP))) {
+			if ((tcph->ack == 1) && (ntohs(iph->tot_len) ==
+			    (iph->ihl * 4 + tcph->doff * 4))) {
+				if (tcph->syn || tcph->fin)
+					return;
+
+				tx_ctrl->flags |= TX_CTRL_TCP_ACK;
+				tx_ctrl->tcp_dst_src = ntohs(tcph->source) |
+					(ntohs(tcph->dest) << 16);
+				tx_ctrl->tcp_sn = ntohl(tcph->ack_seq);
+			}
+		}
+	}
+}
+
+int pcie_tx_init_ndp(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct sk_buff skb;
+	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(&skb);
+	int rc;
+
+	if (sizeof(struct pcie_tx_ctrl_ndp) >
+	    sizeof(tx_info->status.status_driver_data)) {
+		wiphy_err(hw->wiphy, "driver data is not enough: %d (%d)\n",
+			  sizeof(struct pcie_tx_ctrl_ndp),
+			  sizeof(tx_info->status.status_driver_data));
+		return -ENOMEM;
+	}
+
+	rc = pcie_tx_ring_alloc_ndp(priv);
+	if (rc) {
+		pcie_tx_ring_free_ndp(priv);
+		wiphy_err(hw->wiphy, "allocating TX ring failed\n");
+		return rc;
+	}
+
+	rc = pcie_tx_ring_init_ndp(priv);
+	if (rc) {
+		pcie_tx_ring_free_ndp(priv);
+		wiphy_err(hw->wiphy, "initializing TX ring failed\n");
+		return rc;
+	}
+
+	return 0;
+}
+
+void pcie_tx_deinit_ndp(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	pcie_tx_ring_cleanup_ndp(priv);
+	pcie_tx_ring_free_ndp(priv);
+}
+
+void pcie_tx_skbs_ndp(unsigned long data)
+{
+	struct ieee80211_hw *hw = (struct ieee80211_hw *)data;
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	int num = SYSADPT_TX_WMM_QUEUES;
+	struct sk_buff *tx_skb;
+	int rc;
+
+	while (num--) {
+		while (skb_queue_len(&pcie_priv->txq[num]) > 0) {
+			if (pcie_priv->desc_data_ndp.tx_desc_busy_cnt >=
+			    (MAX_TX_RING_SEND_SIZE - 1)) {
+				pcie_tx_done_ndp(hw);
+				break;
+			}
+
+			tx_skb = skb_dequeue(&pcie_priv->txq[num]);
+
+			rc = pcie_tx_skb_ndp(priv, tx_skb);
+			if (rc) {
+				pcie_tx_done_ndp(hw);
+				if (rc == -EAGAIN)
+					skb_queue_head(&pcie_priv->txq[num],
+						       tx_skb);
+				break;
+			}
+
+			if (++pcie_priv->tx_done_cnt > TXDONE_THRESHOLD) {
+				pcie_tx_done_ndp(hw);
+				pcie_priv->tx_done_cnt = 0;
+			}
+		}
+
+		if (skb_queue_len(&pcie_priv->txq[num]) <
+		    pcie_priv->txq_wake_threshold) {
+			int queue;
+
+			queue = SYSADPT_TX_WMM_QUEUES - num - 1;
+			if (ieee80211_queue_stopped(hw, queue))
+				ieee80211_wake_queue(hw, queue);
+		}
+	}
+
+	pcie_priv->is_tx_schedule = false;
+}
+
+void pcie_tx_done_ndp(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct pcie_desc_data_ndp *desc = &pcie_priv->desc_data_ndp;
+	u32 tx_done_head, tx_done_tail;
+	struct tx_ring_done *ptx_ring_done;
+	u32 index;
+	struct sk_buff *skb;
+	struct ieee80211_tx_info *tx_info;
+	struct pcie_tx_ctrl_ndp *tx_ctrl;
+	struct pcie_dma_data *dma_data;
+	u16 hdrlen;
+
+	spin_lock_bh(&pcie_priv->tx_desc_lock);
+
+	tx_done_head = readl(pcie_priv->iobase1 +
+			     MACREG_REG_TXDONEHEAD);
+	tx_done_tail = desc->tx_done_tail & (MAX_TX_RING_DONE_SIZE - 1);
+	tx_done_head &= (MAX_TX_RING_DONE_SIZE - 1);
+
+	while (tx_done_head != tx_done_tail) {
+		ptx_ring_done = &desc->ptx_ring_done[tx_done_tail];
+
+		index = le32_to_cpu(ptx_ring_done->user);
+		ptx_ring_done->user = 0;
+		if (index >= MAX_TX_RING_SEND_SIZE) {
+			wiphy_err(hw->wiphy,
+				  "corruption for index of buffer\n");
+			break;
+		}
+		skb = desc->tx_vbuflist[index];
+		if (!skb) {
+			wiphy_err(hw->wiphy,
+				  "buffer is NULL for tx done ring\n");
+			break;
+		}
+		pci_unmap_single(pcie_priv->pdev,
+				 desc->pphys_tx_buflist[index],
+				 skb->len,
+				 PCI_DMA_TODEVICE);
+		desc->pphys_tx_buflist[index] = 0;
+		desc->tx_vbuflist[index] = NULL;
+
+		tx_info = IEEE80211_SKB_CB(skb);
+		tx_ctrl = (struct pcie_tx_ctrl_ndp *)
+			tx_info->status.status_driver_data;
+
+		if (tx_ctrl->flags & TX_CTRL_TYPE_DATA) {
+			dev_kfree_skb_any(skb);
+			goto bypass_ack;
+		} else {
+			/* Remove H/W dma header */
+			dma_data = (struct pcie_dma_data *)skb->data;
+
+			if (ieee80211_is_assoc_resp(
+			    dma_data->wh.frame_control) ||
+			    ieee80211_is_reassoc_resp(
+			    dma_data->wh.frame_control)) {
+				dev_kfree_skb_any(skb);
+				goto bypass_ack;
+			}
+			hdrlen = ieee80211_hdrlen(
+				dma_data->wh.frame_control);
+			memmove(dma_data->data - hdrlen,
+				&dma_data->wh, hdrlen);
+			skb_pull(skb, sizeof(*dma_data) - hdrlen);
+		}
+
+		pcie_tx_prepare_info(priv, 0, tx_info);
+		ieee80211_tx_status(hw, skb);
+
+bypass_ack:
+		if (++tx_done_tail >= MAX_TX_RING_DONE_SIZE)
+			tx_done_tail = 0;
+		desc->tx_desc_busy_cnt--;
+	}
+
+	writel(tx_done_tail, pcie_priv->iobase1 +
+	       MACREG_REG_TXDONETAIL);
+	desc->tx_done_tail = tx_done_tail;
+
+	spin_unlock_bh(&pcie_priv->tx_desc_lock);
+}
+
+void pcie_tx_xmit_ndp(struct ieee80211_hw *hw,
+		      struct ieee80211_tx_control *control,
+		      struct sk_buff *skb)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct pcie_priv *pcie_priv = priv->hif.priv;
+	struct ieee80211_tx_info *tx_info;
+	struct ieee80211_key_conf *k_conf;
+	struct mwl_vif *mwl_vif;
+	int index;
+	struct ieee80211_sta *sta;
+	struct mwl_sta *sta_info;
+	struct ieee80211_hdr *wh;
+	u8 *da;
+	u16 qos;
+	u8 tid = 0;
+	struct mwl_ampdu_stream *stream = NULL;
+	u16 tx_que_priority;
+	bool mgmtframe = false;
+	struct ieee80211_mgmt *mgmt;
+	bool eapol_frame = false;
+	bool start_ba_session = false;
+	struct pcie_tx_ctrl_ndp *tx_ctrl;
+
+	tx_info = IEEE80211_SKB_CB(skb);
+	k_conf = tx_info->control.hw_key;
+	mwl_vif = mwl_dev_get_vif(tx_info->control.vif);
+	index = skb_get_queue_mapping(skb);
+	sta = control->sta;
+	sta_info = sta ? mwl_dev_get_sta(sta) : NULL;
+
+	wh = (struct ieee80211_hdr *)skb->data;
+
+	if (ieee80211_is_data_qos(wh->frame_control))
+		qos = le16_to_cpu(*((__le16 *)ieee80211_get_qos_ctl(wh)));
+	else
+		qos = 0xFFFF;
+
+	if (skb->protocol == cpu_to_be16(ETH_P_PAE)) {
+		index = IEEE80211_AC_VO;
+		eapol_frame = true;
+	}
+
+	if (ieee80211_is_mgmt(wh->frame_control)) {
+		mgmtframe = true;
+		mgmt = (struct ieee80211_mgmt *)skb->data;
+	}
+
+	if (mgmtframe) {
+		u16 capab;
+
+		if (unlikely(ieee80211_is_action(wh->frame_control) &&
+			     mgmt->u.action.category == WLAN_CATEGORY_BACK &&
+			     mgmt->u.action.u.addba_req.action_code ==
+			     WLAN_ACTION_ADDBA_REQ)) {
+			capab = le16_to_cpu(mgmt->u.action.u.addba_req.capab);
+			tid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;
+			index = utils_tid_to_ac(tid);
+		}
+
+		if (unlikely(ieee80211_is_assoc_req(wh->frame_control)))
+			utils_add_basic_rates(hw->conf.chandef.chan->band, skb);
+
+		if (ieee80211_is_probe_req(wh->frame_control) ||
+		    ieee80211_is_probe_resp(wh->frame_control))
+			tx_que_priority = PROBE_RESPONSE_TXQNUM;
+		else {
+			if ((
+			    (mwl_vif->macid == SYSADPT_NUM_OF_AP) &&
+			    (!ieee80211_has_protected(wh->frame_control) ||
+			    (ieee80211_has_protected(wh->frame_control) &&
+			    ieee80211_is_auth(wh->frame_control)))
+			    ) ||
+			    !sta ||
+			    ieee80211_is_auth(wh->frame_control) ||
+			    ieee80211_is_assoc_req(wh->frame_control) ||
+			    ieee80211_is_assoc_resp(wh->frame_control))
+				tx_que_priority = MGMT_TXQNUM;
+			else {
+				if (is_multicast_ether_addr(wh->addr1) &&
+				    (mwl_vif->macid != SYSADPT_NUM_OF_AP))
+					tx_que_priority = mwl_vif->macid *
+						SYSADPT_MAX_TID;
+				else
+					tx_que_priority = SYSADPT_MAX_TID *
+						(sta_info->stnid +
+						QUEUE_STAOFFSET) + 6;
+			}
+		}
+
+		if (ieee80211_is_assoc_resp(wh->frame_control) ||
+		    ieee80211_is_reassoc_resp(wh->frame_control)) {
+			struct sk_buff *ack_skb;
+			struct ieee80211_tx_info *ack_info;
+
+			ack_skb = skb_copy(skb, GFP_ATOMIC);
+			ack_info = IEEE80211_SKB_CB(ack_skb);
+			pcie_tx_prepare_info(priv, 0, ack_info);
+			ieee80211_tx_status(hw, ack_skb);
+		}
+
+		pcie_tx_encapsulate_frame(priv, skb, k_conf, NULL);
+	} else {
+		tid = qos & 0x7;
+		if (sta && sta->ht_cap.ht_supported && !eapol_frame &&
+		    qos != 0xFFFF) {
+			pcie_tx_count_packet(sta, tid);
+			spin_lock_bh(&priv->stream_lock);
+			stream = mwl_fwcmd_lookup_stream(hw, sta, tid);
+			if (!stream ||
+			    stream->state == AMPDU_STREAM_IN_PROGRESS) {
+				wiphy_warn(hw->wiphy,
+					   "can't send packet during ADDBA\n");
+				spin_unlock_bh(&priv->stream_lock);
+				dev_kfree_skb_any(skb);
+				return;
+			}
+			if ((stream->state == AMPDU_NO_STREAM) &&
+			    mwl_fwcmd_ampdu_allowed(sta, tid)) {
+				stream = mwl_fwcmd_add_stream(hw, sta, tid);
+				if (stream)
+					start_ba_session = true;
+			}
+			spin_unlock_bh(&priv->stream_lock);
+		}
+
+		da = ieee80211_get_DA(wh);
+
+		if (is_multicast_ether_addr(da)
+		    && (mwl_vif->macid != SYSADPT_NUM_OF_AP)) {
+
+			tx_que_priority = mwl_vif->macid * SYSADPT_MAX_TID;
+
+			if (da[ETH_ALEN - 1] == 0xff)
+				tx_que_priority += 7;
+
+			if (ieee80211_has_a4(wh->frame_control)) {
+				if (sta && sta_info->wds)
+					tx_que_priority = SYSADPT_MAX_TID *
+						(sta_info->stnid +
+						QUEUE_STAOFFSET) + 6;
+			}
+		} else {
+			if (sta) {
+				if (!eapol_frame)
+					tx_que_priority = SYSADPT_MAX_TID *
+						(sta_info->stnid +
+						QUEUE_STAOFFSET) +
+						((qos == 0xFFFF) ? 0 : tid);
+				else
+					tx_que_priority = SYSADPT_MAX_TID *
+						(sta_info->stnid +
+						QUEUE_STAOFFSET) +
+						((qos == 0xFFFF) ? 0 : 6);
+			} else
+				tx_que_priority = 0;
+		}
+	}
+
+	index = SYSADPT_TX_WMM_QUEUES - index - 1;
+
+	tx_ctrl = (struct pcie_tx_ctrl_ndp *)tx_info->status.status_driver_data;
+	tx_ctrl->tx_que_priority = tx_que_priority;
+	tx_ctrl->hdrlen = ieee80211_hdrlen(wh->frame_control);
+	tx_ctrl->flags = 0;
+	if (!mgmtframe)
+		tx_ctrl->flags |= TX_CTRL_TYPE_DATA;
+	if (eapol_frame)
+		tx_ctrl->flags |= TX_CTRL_EAPOL;
+	tx_ctrl->rate = sta ? sta_info->tx_rate_info : 0;
+	if (ieee80211_is_nullfunc(wh->frame_control) ||
+	    ieee80211_is_qos_nullfunc(wh->frame_control))
+		tx_ctrl->rate = 0;
+	pcie_tx_check_tcp_ack(skb, tx_ctrl);
+
+	if (skb_queue_len(&pcie_priv->txq[index]) > pcie_priv->txq_limit)
+		ieee80211_stop_queue(hw, SYSADPT_TX_WMM_QUEUES - index - 1);
+
+	skb_queue_tail(&pcie_priv->txq[index], skb);
+
+	if (!pcie_priv->is_tx_schedule) {
+		tasklet_schedule(&pcie_priv->tx_task);
+		pcie_priv->is_tx_schedule = true;
+	}
+
+	/* Initiate the ampdu session here */
+	if (start_ba_session) {
+		spin_lock_bh(&priv->stream_lock);
+		if (mwl_fwcmd_start_stream(hw, stream))
+			mwl_fwcmd_remove_stream(hw, stream);
+		spin_unlock_bh(&priv->stream_lock);
+	}
+}
diff --git a/drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx_ndp.h b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx_ndp.h
new file mode 100644
index 000000000000..2ad5f381b9ee
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hif/pcie/tx_ndp.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines transmit related functions for new data path.
+ */
+
+#ifndef _TX_NDP_H_
+#define _TX_NDP_H_
+
+int pcie_tx_init_ndp(struct ieee80211_hw *hw);
+void pcie_tx_deinit_ndp(struct ieee80211_hw *hw);
+void pcie_tx_skbs_ndp(unsigned long data);
+void pcie_tx_done_ndp(struct ieee80211_hw *hw);
+void pcie_tx_xmit_ndp(struct ieee80211_hw *hw,
+		      struct ieee80211_tx_control *control,
+		      struct sk_buff *skb);
+
+#endif /* _TX_NDP_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/hostapd/700-interoperability-workaround-for-80+80-and-160-MHz-channels b/drivers/net/wireless/marvell/mwlwifi/hostapd/700-interoperability-workaround-for-80+80-and-160-MHz-channels
new file mode 100644
index 000000000000..adadd2e4d8d4
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hostapd/700-interoperability-workaround-for-80+80-and-160-MHz-channels
@@ -0,0 +1,32 @@
+diff --git a/src/ap/ieee802_11_vht.c b/src/ap/ieee802_11_vht.c
+index 3236016..e923094 100644
+--- a/src/ap/ieee802_11_vht.c
++++ b/src/ap/ieee802_11_vht.c
+@@ -82,6 +82,27 @@ u8 * hostapd_eid_vht_operation(struct hostapd_data *hapd, u8 *eid)
+ 
+ 	oper->vht_op_info_chwidth = hapd->iconf->vht_oper_chwidth;
+ 
++	if (hapd->iconf->vht_oper_chwidth == 2) {
++		/*
++		 * Convert 160 MHz channel width to new style as interop
++		 * workaround.
++		 */
++		oper->vht_op_info_chwidth = 1;
++		oper->vht_op_info_chan_center_freq_seg1_idx =
++			oper->vht_op_info_chan_center_freq_seg0_idx;
++		if (hapd->iconf->channel <
++		    hapd->iconf->vht_oper_centr_freq_seg0_idx)
++				oper->vht_op_info_chan_center_freq_seg0_idx -= 8;
++			else
++				oper->vht_op_info_chan_center_freq_seg0_idx += 8;
++	} else if (hapd->iconf->vht_oper_chwidth == 3) {
++		/*
++		 * Convert 80+80 MHz channel width to new style as interop
++		 * workaround.
++		 */
++		oper->vht_op_info_chwidth = 1;
++	}
++
+ 	/* VHT Basic MCS set comes from hw */
+ 	/* Hard code 1 stream, MCS0-7 is a min Basic VHT MCS rates */
+ 	oper->vht_basic_mcs_set = host_to_le16(0xfffc);
diff --git a/drivers/net/wireless/marvell/mwlwifi/hostapd/README b/drivers/net/wireless/marvell/mwlwifi/hostapd/README
new file mode 100644
index 000000000000..a5fb2b68d3d3
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/hostapd/README
@@ -0,0 +1,26 @@
+700-interoperability-workaround-for-80+80-and-160-MHz-channels: 
+
+patch for OpenWrt hostapd package 2016-01-15 for following commit
+(move it to package/network/services/hostapd/patches).
+
+Note: After hostapd package 2016-06-15, this commit is already included.
+
+commit 03a72eacda5d9a1837a74387081596a0d5466ec1
+Author: Jouni Malinen <jouni@qca.qualcomm.com>
+Date:   Thu Dec 17 18:39:19 2015 +0200
+
+    VHT: Add an interoperability workaround for 80+80 and 160 MHz channels
+
+    Number of deployed 80 MHz capable VHT stations that do not support 80+80
+    and 160 MHz bandwidths seem to misbehave when trying to connect to an AP
+    that advertises 80+80 or 160 MHz channel bandwidth in the VHT Operation
+    element. To avoid such issues with deployed devices, modify the design
+    based on newly proposed IEEE 802.11 standard changes.
+
+    This allows poorly implemented VHT 80 MHz stations to connect with the
+    AP in 80 MHz mode. 80+80 and 160 MHz capable stations need to support
+    the new workaround mechanism to allow full bandwidth to be used.
+    However, there are more or less no impacted station with 80+80/160
+    capability deployed.
+
+    Signed-off-by: Jouni Malinen jouni@qca.qualcomm.com
diff --git a/drivers/net/wireless/marvell/mwlwifi/mac80211.c b/drivers/net/wireless/marvell/mwlwifi/mac80211.c
new file mode 100644
index 000000000000..725dec0f604b
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/mac80211.c
@@ -0,0 +1,933 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements mac80211 related functions. */
+
+#include <linux/etherdevice.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "utils.h"
+#include "hif/fwcmd.h"
+#include "hif/hif-ops.h"
+
+#define MAX_AMPDU_ATTEMPTS  5
+
+static const struct ieee80211_rate mwl_rates_24[] = {
+	{ .bitrate = 10, .hw_value = 2, },
+	{ .bitrate = 20, .hw_value = 4, },
+	{ .bitrate = 55, .hw_value = 11, },
+	{ .bitrate = 110, .hw_value = 22, },
+	{ .bitrate = 220, .hw_value = 44, },
+	{ .bitrate = 60, .hw_value = 12, },
+	{ .bitrate = 90, .hw_value = 18, },
+	{ .bitrate = 120, .hw_value = 24, },
+	{ .bitrate = 180, .hw_value = 36, },
+	{ .bitrate = 240, .hw_value = 48, },
+	{ .bitrate = 360, .hw_value = 72, },
+	{ .bitrate = 480, .hw_value = 96, },
+	{ .bitrate = 540, .hw_value = 108, },
+};
+
+static const struct ieee80211_rate mwl_rates_50[] = {
+	{ .bitrate = 60, .hw_value = 12, },
+	{ .bitrate = 90, .hw_value = 18, },
+	{ .bitrate = 120, .hw_value = 24, },
+	{ .bitrate = 180, .hw_value = 36, },
+	{ .bitrate = 240, .hw_value = 48, },
+	{ .bitrate = 360, .hw_value = 72, },
+	{ .bitrate = 480, .hw_value = 96, },
+	{ .bitrate = 540, .hw_value = 108, },
+};
+
+static void mwl_get_rateinfo(struct mwl_priv *priv, u8 *addr,
+			     struct mwl_sta *sta_info)
+{
+	int table_size = (sizeof(__le32) * 2 * SYSADPT_MAX_RATE_ADAPT_RATES);
+	u8 *rate_table, *rate_idx;
+	u32 rate_info;
+	struct mwl_tx_hist_data *tx_hist_data;
+	int ret, idx;
+
+	rate_table = kzalloc(table_size, GFP_KERNEL);
+	if (!rate_table)
+		return;
+
+	ret = mwl_fwcmd_get_ratetable(priv->hw, addr, rate_table,
+				      table_size, 0);
+	if (ret) {
+		kfree(rate_table);
+		return;
+	}
+
+	idx = 0;
+	rate_idx = rate_table;
+	rate_info = le32_to_cpu(*(__le32 *)rate_idx);
+	tx_hist_data = &sta_info->tx_hist.su_rate[0];
+	while (rate_info) {
+		if (idx < SYSADPT_MAX_RATE_ADAPT_RATES)
+			tx_hist_data[idx].rateinfo = rate_info;
+		idx++;
+		rate_idx += (2 * sizeof(__le32));
+		rate_info = le32_to_cpu(*(__le32 *)rate_idx);
+	}
+
+	kfree(rate_table);
+}
+
+static void mwl_mac80211_tx(struct ieee80211_hw *hw,
+			    struct ieee80211_tx_control *control,
+			    struct sk_buff *skb)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if (!priv->radio_on) {
+		wiphy_warn(hw->wiphy,
+			   "dropped TX frame since radio is disabled\n");
+		dev_kfree_skb_any(skb);
+		return;
+	}
+
+	mwl_hif_tx_xmit(hw, control, skb);
+}
+
+static int mwl_mac80211_start(struct ieee80211_hw *hw)
+{
+	struct mwl_priv *priv = hw->priv;
+	int rc;
+
+	/* Enable TX and RX tasklets. */
+	mwl_hif_enable_data_tasks(hw);
+
+	/* Enable interrupts */
+	mwl_hif_irq_enable(hw);
+
+	rc = mwl_fwcmd_radio_enable(hw);
+	if (rc)
+		goto fwcmd_fail;
+	rc = mwl_fwcmd_set_rate_adapt_mode(hw, 0);
+	if (rc)
+		goto fwcmd_fail;
+	rc = mwl_fwcmd_set_wmm_mode(hw, true);
+	if (rc)
+		goto fwcmd_fail;
+	rc = mwl_fwcmd_ht_guard_interval(hw, GUARD_INTERVAL_AUTO);
+	if (rc)
+		goto fwcmd_fail;
+	rc = mwl_fwcmd_set_dwds_stamode(hw, true);
+	if (rc)
+		goto fwcmd_fail;
+	rc = mwl_fwcmd_set_fw_flush_timer(hw, SYSADPT_AMSDU_FLUSH_TIME);
+	if (rc)
+		goto fwcmd_fail;
+	rc = mwl_fwcmd_set_optimization_level(hw, 1);
+	if (rc)
+		goto fwcmd_fail;
+	if (priv->chip_type == MWL8997) {
+		rc = mwl_fwcmd_config_EDMACCtrl(hw, 0);
+		if (rc)
+			goto fwcmd_fail;
+	}
+	if (priv->chip_type == MWL8964) {
+		rc = mwl_fwcmd_newdp_dmathread_start(hw);
+		if (rc)
+			goto fwcmd_fail;
+		rc = mwl_fwcmd_set_bftype(hw, priv->bf_type);
+		if (rc)
+			goto fwcmd_fail;
+	}
+
+	ieee80211_wake_queues(hw);
+	return 0;
+
+fwcmd_fail:
+	mwl_hif_irq_disable(hw);
+	mwl_hif_disable_data_tasks(hw);
+
+	return rc;
+}
+
+static void mwl_mac80211_stop(struct ieee80211_hw *hw)
+{
+	mwl_fwcmd_radio_disable(hw);
+
+	ieee80211_stop_queues(hw);
+
+	/* Disable interrupts */
+	mwl_hif_irq_disable(hw);
+
+	/* Disable TX and RX tasklets. */
+	mwl_hif_disable_data_tasks(hw);
+
+	/* Return all skbs to mac80211 */
+	mwl_hif_tx_return_pkts(hw);
+}
+
+static int mwl_mac80211_add_interface(struct ieee80211_hw *hw,
+				      struct ieee80211_vif *vif)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+	u32 macids_supported;
+	int macid;
+
+	switch (vif->type) {
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_MESH_POINT:
+		if (vif->type == NL80211_IFTYPE_MESH_POINT)
+			if (priv->chip_type != MWL8997)
+				return -EPERM;
+		macids_supported = priv->ap_macids_supported;
+		break;
+	case NL80211_IFTYPE_STATION:
+		macids_supported = priv->sta_macids_supported;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	macid = ffs(macids_supported & ~priv->macids_used);
+
+	if (!macid) {
+		wiphy_warn(hw->wiphy, "no macid can be allocated\n");
+		return -EBUSY;
+	}
+	macid--;
+
+	/* Setup driver private area. */
+	mwl_vif = mwl_dev_get_vif(vif);
+	memset(mwl_vif, 0, sizeof(*mwl_vif));
+	mwl_vif->type = vif->type;
+	mwl_vif->macid = macid;
+	mwl_vif->seqno = 0;
+	mwl_vif->is_hw_crypto_enabled = false;
+	mwl_vif->beacon_info.valid = false;
+	mwl_vif->set_beacon = false;
+	mwl_vif->basic_rate_idx = 0;
+	mwl_vif->broadcast_ssid = 0xFF;
+	mwl_vif->iv16 = 1;
+	mwl_vif->iv32 = 0;
+	mwl_vif->keyidx = 0;
+
+	switch (vif->type) {
+	case NL80211_IFTYPE_AP:
+		ether_addr_copy(mwl_vif->bssid, vif->addr);
+		mwl_fwcmd_set_new_stn_add_self(hw, vif);
+		if (priv->chip_type == MWL8964) {
+			/* allow firmware to really set channel */
+			mwl_fwcmd_bss_start(hw, vif, true);
+			mwl_fwcmd_bss_start(hw, vif, false);
+		}
+		break;
+	case NL80211_IFTYPE_MESH_POINT:
+		ether_addr_copy(mwl_vif->bssid, vif->addr);
+		mwl_fwcmd_set_new_stn_add_self(hw, vif);
+		break;
+	case NL80211_IFTYPE_STATION:
+		ether_addr_copy(mwl_vif->sta_mac, vif->addr);
+		mwl_fwcmd_bss_start(hw, vif, true);
+		mwl_fwcmd_set_infra_mode(hw, vif);
+		mwl_fwcmd_set_mac_addr_client(hw, vif, vif->addr);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	priv->macids_used |= 1 << mwl_vif->macid;
+	spin_lock_bh(&priv->vif_lock);
+	list_add_tail(&mwl_vif->list, &priv->vif_list);
+	spin_unlock_bh(&priv->vif_lock);
+
+	return 0;
+}
+
+static void mwl_mac80211_remove_vif(struct mwl_priv *priv,
+				    struct ieee80211_vif *vif)
+{
+	struct mwl_vif *mwl_vif = mwl_dev_get_vif(vif);
+
+	if (!priv->macids_used)
+		return;
+
+	mwl_hif_tx_del_pkts_via_vif(priv->hw, vif);
+
+	priv->macids_used &= ~(1 << mwl_vif->macid);
+	spin_lock_bh(&priv->vif_lock);
+	list_del(&mwl_vif->list);
+	spin_unlock_bh(&priv->vif_lock);
+}
+
+static void mwl_mac80211_remove_interface(struct ieee80211_hw *hw,
+					  struct ieee80211_vif *vif)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	switch (vif->type) {
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_MESH_POINT:
+		mwl_fwcmd_set_new_stn_del(hw, vif, vif->addr);
+		break;
+	case NL80211_IFTYPE_STATION:
+		mwl_fwcmd_remove_mac_addr(hw, vif, vif->addr);
+		break;
+	default:
+		break;
+	}
+
+	mwl_mac80211_remove_vif(priv, vif);
+}
+
+static int mwl_mac80211_config(struct ieee80211_hw *hw,
+			       u32 changed)
+{
+	struct ieee80211_conf *conf = &hw->conf;
+	int rc;
+
+	wiphy_debug(hw->wiphy, "change: 0x%x\n", changed);
+
+	if (conf->flags & IEEE80211_CONF_IDLE)
+		rc = mwl_fwcmd_radio_disable(hw);
+	else
+		rc = mwl_fwcmd_radio_enable(hw);
+
+	if (rc)
+		goto out;
+
+	if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
+		int rate = 0;
+
+		if (conf->chandef.chan->band == NL80211_BAND_2GHZ) {
+			mwl_fwcmd_set_apmode(hw, AP_MODE_2_4GHZ_11AC_MIXED);
+			mwl_fwcmd_set_linkadapt_cs_mode(hw,
+							LINK_CS_STATE_CONSERV);
+			rate = mwl_rates_24[0].hw_value;
+		} else if (conf->chandef.chan->band == NL80211_BAND_5GHZ) {
+			mwl_fwcmd_set_apmode(hw, AP_MODE_11AC);
+			mwl_fwcmd_set_linkadapt_cs_mode(hw,
+							LINK_CS_STATE_AUTO);
+			rate = mwl_rates_50[0].hw_value;
+
+			if (conf->radar_enabled)
+				mwl_fwcmd_set_radar_detect(hw, MONITOR_START);
+			else
+				mwl_fwcmd_set_radar_detect(hw,
+							   STOP_DETECT_RADAR);
+		}
+
+		rc = mwl_fwcmd_set_rf_channel(hw, conf);
+		if (rc)
+			goto out;
+		rc = mwl_fwcmd_use_fixed_rate(hw, rate, rate);
+		if (rc)
+			goto out;
+		rc = mwl_fwcmd_max_tx_power(hw, conf, 0);
+		if (rc)
+			goto out;
+		rc = mwl_fwcmd_tx_power(hw, conf, 0);
+		if (rc)
+			goto out;
+		rc = mwl_fwcmd_set_cdd(hw);
+	}
+
+out:
+
+	return rc;
+}
+
+static void mwl_mac80211_bss_info_changed_sta(struct ieee80211_hw *hw,
+					      struct ieee80211_vif *vif,
+					      struct ieee80211_bss_conf *info,
+					      u32 changed)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	if ((changed & BSS_CHANGED_ERP_SLOT) && (priv->chip_type == MWL8997)) {
+		if (priv->use_short_slot != vif->bss_conf.use_short_slot) {
+			mwl_fwcmd_set_slot_time(hw,
+						vif->bss_conf.use_short_slot);
+			priv->use_short_slot = vif->bss_conf.use_short_slot;
+		}
+	}
+
+	if (changed & BSS_CHANGED_ERP_PREAMBLE) {
+		if (priv->use_short_preamble !=
+		    vif->bss_conf.use_short_preamble) {
+			mwl_fwcmd_set_radio_preamble(
+				hw, vif->bss_conf.use_short_preamble);
+			priv->use_short_preamble =
+				vif->bss_conf.use_short_preamble;
+		}
+	}
+
+	if ((changed & BSS_CHANGED_ASSOC) && vif->bss_conf.assoc)
+		mwl_fwcmd_set_aid(hw, vif, (u8 *)vif->bss_conf.bssid,
+				  vif->bss_conf.aid);
+}
+
+static void mwl_mac80211_bss_info_changed_ap(struct ieee80211_hw *hw,
+					     struct ieee80211_vif *vif,
+					     struct ieee80211_bss_conf *info,
+					     u32 changed)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_vif *mwl_vif;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+
+	if ((changed & BSS_CHANGED_ERP_SLOT) && (priv->chip_type == MWL8997)) {
+		if (priv->use_short_slot != vif->bss_conf.use_short_slot) {
+			mwl_fwcmd_set_slot_time(hw,
+						vif->bss_conf.use_short_slot);
+			priv->use_short_slot = vif->bss_conf.use_short_slot;
+		}
+	}
+
+	if (changed & BSS_CHANGED_ERP_PREAMBLE) {
+		if (priv->use_short_preamble !=
+		    vif->bss_conf.use_short_preamble) {
+			mwl_fwcmd_set_radio_preamble(
+				hw, vif->bss_conf.use_short_preamble);
+			priv->use_short_preamble =
+				vif->bss_conf.use_short_preamble;
+		}
+	}
+
+	if (changed & BSS_CHANGED_BASIC_RATES) {
+		int idx;
+		int rate;
+
+		/* Use lowest supported basic rate for multicasts
+		 * and management frames (such as probe responses --
+		 * beacons will always go out at 1 Mb/s).
+		 */
+		idx = ffs(vif->bss_conf.basic_rates);
+		if (idx)
+			idx--;
+		if (mwl_vif->basic_rate_idx != idx) {
+			if (hw->conf.chandef.chan->band == NL80211_BAND_2GHZ)
+				rate = mwl_rates_24[idx].hw_value;
+			else
+				rate = mwl_rates_50[idx].hw_value;
+
+			mwl_fwcmd_use_fixed_rate(hw, rate, rate);
+			mwl_vif->basic_rate_idx = idx;
+		}
+	}
+
+	if (changed & (BSS_CHANGED_BEACON_INT | BSS_CHANGED_BEACON)) {
+		struct sk_buff *skb;
+
+		if ((info->ssid[0] != '\0') &&
+		    (info->ssid_len != 0) &&
+		    (!info->hidden_ssid)) {
+			if (mwl_vif->broadcast_ssid != true) {
+				mwl_fwcmd_broadcast_ssid_enable(hw, vif, true);
+				mwl_vif->broadcast_ssid = true;
+			}
+		} else {
+			if (mwl_vif->broadcast_ssid != false) {
+				mwl_fwcmd_broadcast_ssid_enable(hw, vif, false);
+				mwl_vif->broadcast_ssid = false;
+			}
+		}
+
+		if (!mwl_vif->set_beacon) {
+			skb = ieee80211_beacon_get(hw, vif);
+
+			if (skb) {
+				mwl_fwcmd_set_beacon(hw, vif, skb->data, skb->len);
+				dev_kfree_skb_any(skb);
+			}
+			mwl_vif->set_beacon = true;
+		}
+	}
+
+	if (changed & BSS_CHANGED_BEACON_ENABLED)
+		mwl_fwcmd_bss_start(hw, vif, info->enable_beacon);
+}
+
+static void mwl_mac80211_bss_info_changed(struct ieee80211_hw *hw,
+					  struct ieee80211_vif *vif,
+					  struct ieee80211_bss_conf *info,
+					  u32 changed)
+{
+	switch (vif->type) {
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_MESH_POINT:
+		mwl_mac80211_bss_info_changed_ap(hw, vif, info, changed);
+		break;
+	case NL80211_IFTYPE_STATION:
+		mwl_mac80211_bss_info_changed_sta(hw, vif, info, changed);
+		break;
+	default:
+		break;
+	}
+}
+
+static void mwl_mac80211_configure_filter(struct ieee80211_hw *hw,
+					  unsigned int changed_flags,
+					  unsigned int *total_flags,
+					  u64 multicast)
+{
+	/* AP firmware doesn't allow fine-grained control over
+	 * the receive filter.
+	 */
+	*total_flags &= FIF_ALLMULTI | FIF_BCN_PRBRESP_PROMISC;
+}
+
+static int mwl_mac80211_set_key(struct ieee80211_hw *hw,
+				enum set_key_cmd cmd_param,
+				struct ieee80211_vif *vif,
+				struct ieee80211_sta *sta,
+				struct ieee80211_key_conf *key)
+{
+	struct mwl_vif *mwl_vif;
+	struct mwl_sta *sta_info;
+	int rc = 0;
+	u8 encr_type;
+	u8 *addr;
+
+	mwl_vif = mwl_dev_get_vif(vif);
+	addr = sta ? sta->addr : vif->addr;
+
+	if (cmd_param == SET_KEY) {
+		if ((key->cipher == WLAN_CIPHER_SUITE_WEP40) ||
+		    (key->cipher == WLAN_CIPHER_SUITE_WEP104)) {
+			encr_type = ENCR_TYPE_WEP;
+		} else if (key->cipher == WLAN_CIPHER_SUITE_CCMP) {
+			encr_type = ENCR_TYPE_AES;
+			if ((key->flags & IEEE80211_KEY_FLAG_PAIRWISE) == 0) {
+				if (vif->type != NL80211_IFTYPE_STATION)
+					mwl_vif->keyidx = key->keyidx;
+			}
+		} else if (key->cipher == WLAN_CIPHER_SUITE_TKIP) {
+			encr_type = ENCR_TYPE_TKIP;
+		} else {
+			encr_type = ENCR_TYPE_DISABLE;
+		}
+
+		rc = mwl_fwcmd_update_encryption_enable(hw, vif, addr,
+							encr_type);
+		if (rc)
+			goto out;
+		rc = mwl_fwcmd_encryption_set_key(hw, vif, addr, key);
+		if (rc)
+			goto out;
+
+		mwl_vif->is_hw_crypto_enabled = true;
+		if (sta) {
+			sta_info = mwl_dev_get_sta(sta);
+			sta_info->is_key_set = true;
+		}
+	} else {
+		rc = mwl_fwcmd_encryption_remove_key(hw, vif, addr, key);
+		if (rc)
+			goto out;
+	}
+
+out:
+
+	return rc;
+}
+
+static int mwl_mac80211_set_rts_threshold(struct ieee80211_hw *hw,
+					  u32 value)
+{
+	return mwl_fwcmd_set_rts_threshold(hw, value);
+}
+
+static int mwl_mac80211_sta_add(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				struct ieee80211_sta *sta)
+{
+	struct mwl_priv *priv = hw->priv;
+	u16 stnid, sta_stnid = 0;
+	struct mwl_vif *mwl_vif;
+	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
+	bool use_4addr = wdev->use_4addr;
+	struct mwl_sta *sta_info;
+	struct ieee80211_key_conf *key;
+	int rc;
+	int i;
+
+	if (vif->type == NL80211_IFTYPE_STATION)
+		sta->aid = 1;
+	mwl_vif = mwl_dev_get_vif(vif);
+	stnid = utils_assign_stnid(priv, mwl_vif->macid, sta->aid);
+	if (!stnid)
+		return -EPERM;
+	if (vif->type == NL80211_IFTYPE_STATION) {
+		sta_stnid = utils_assign_stnid(priv, mwl_vif->macid,
+					       sta->aid + 1);
+		if (!sta_stnid) {
+			utils_free_stnid(priv, stnid);
+			return -EPERM;
+		}
+		ether_addr_copy(mwl_vif->bssid, sta->addr);
+	}
+	sta_info = mwl_dev_get_sta(sta);
+	memset(sta_info, 0, sizeof(*sta_info));
+
+	if (vif->type == NL80211_IFTYPE_MESH_POINT)
+		sta_info->is_mesh_node = true;
+
+	if (sta->ht_cap.ht_supported) {
+		sta_info->is_ampdu_allowed = true;
+		sta_info->is_amsdu_allowed = false;
+		if (sta->ht_cap.cap & IEEE80211_HT_CAP_MAX_AMSDU)
+			sta_info->amsdu_ctrl.cap = MWL_AMSDU_SIZE_8K;
+		else
+			sta_info->amsdu_ctrl.cap = MWL_AMSDU_SIZE_4K;
+		if ((sta->tdls) && (!sta->wme))
+			sta->wme = true;
+	}
+	sta_info->mwl_vif = mwl_vif;
+	sta_info->stnid = stnid;
+	if (vif->type == NL80211_IFTYPE_STATION)
+		sta_info->sta_stnid = sta_stnid;
+	sta_info->tx_rate_info = utils_get_init_tx_rate(priv, &hw->conf, sta);
+	sta_info->iv16 = 1;
+	sta_info->iv32 = 0;
+	spin_lock_init(&sta_info->amsdu_lock);
+	spin_lock_bh(&priv->sta_lock);
+	list_add_tail(&sta_info->list, &priv->sta_list);
+	spin_unlock_bh(&priv->sta_lock);
+
+	if (vif->type == NL80211_IFTYPE_STATION)
+		mwl_fwcmd_set_new_stn_del(hw, vif, sta->addr);
+
+	if (priv->chip_type == MWL8964) {
+		if (use_4addr) {
+			sta_info->wds = true;
+			rc = mwl_fwcmd_set_new_stn_add_sc4(hw, vif, sta,
+							   WDS_MODE);
+		} else
+			rc = mwl_fwcmd_set_new_stn_add_sc4(hw, vif, sta, 0);
+	} else
+		rc = mwl_fwcmd_set_new_stn_add(hw, vif, sta);
+
+	if ((vif->type == NL80211_IFTYPE_STATION) && !use_4addr)
+		mwl_hif_set_sta_id(hw, sta, true, true);
+	else
+		mwl_hif_set_sta_id(hw, sta, false, true);
+
+	for (i = 0; i < NUM_WEP_KEYS; i++) {
+		key = (struct ieee80211_key_conf *)mwl_vif->wep_key_conf[i].key;
+
+		if (mwl_vif->wep_key_conf[i].enabled)
+			mwl_mac80211_set_key(hw, SET_KEY, vif, sta, key);
+	}
+
+	mwl_get_rateinfo(priv, sta->addr, sta_info);
+
+	return rc;
+}
+
+static int mwl_mac80211_sta_remove(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif,
+				   struct ieee80211_sta *sta)
+{
+	struct mwl_priv *priv = hw->priv;
+	int rc;
+	struct mwl_sta *sta_info = mwl_dev_get_sta(sta);
+
+	mwl_hif_tx_del_sta_amsdu_pkts(hw, sta);
+	mwl_fwcmd_del_sta_streams(hw, sta);
+	mwl_hif_tx_del_pkts_via_sta(hw, sta);
+
+	rc = mwl_fwcmd_set_new_stn_del(hw, vif, sta->addr);
+
+	if (vif->type == NL80211_IFTYPE_STATION)
+		mwl_hif_set_sta_id(hw, sta, true, false);
+	else
+		mwl_hif_set_sta_id(hw, sta, false, false);
+
+	if (priv->chip_type != MWL8964)
+		utils_free_stnid(priv, sta_info->stnid);
+	if (vif->type == NL80211_IFTYPE_STATION)
+		utils_free_stnid(priv, sta_info->sta_stnid);
+
+	spin_lock_bh(&priv->sta_lock);
+	list_del(&sta_info->list);
+	spin_unlock_bh(&priv->sta_lock);
+
+	return rc;
+}
+
+static int mwl_mac80211_conf_tx(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				u16 queue,
+				const struct ieee80211_tx_queue_params *params)
+{
+	struct mwl_priv *priv = hw->priv;
+	int rc = 0;
+
+	if (WARN_ON(queue > SYSADPT_TX_WMM_QUEUES - 1))
+		return -EINVAL;
+
+	memcpy(&priv->wmm_params[queue], params, sizeof(*params));
+
+	if (!priv->wmm_enabled) {
+		rc = mwl_fwcmd_set_wmm_mode(hw, true);
+		priv->wmm_enabled = true;
+	}
+
+	if (!rc) {
+		int q = SYSADPT_TX_WMM_QUEUES - 1 - queue;
+
+		rc = mwl_fwcmd_set_edca_params(hw, q,
+					       params->cw_min, params->cw_max,
+					       params->aifs, params->txop);
+	}
+
+	return rc;
+}
+
+static int mwl_mac80211_get_stats(struct ieee80211_hw *hw,
+				  struct ieee80211_low_level_stats *stats)
+{
+	return mwl_fwcmd_get_stat(hw, stats);
+}
+
+static int mwl_mac80211_get_survey(struct ieee80211_hw *hw,
+				   int idx,
+				   struct survey_info *survey)
+{
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_survey_info *survey_info;
+
+	if (priv->survey_info_idx) {
+		if (idx >= priv->survey_info_idx) {
+			priv->survey_info_idx = 0;
+			return -ENOENT;
+		}
+		survey_info = &priv->survey_info[idx];
+	} else {
+		if (idx != 0)
+			return -ENOENT;
+		mwl_fwcmd_get_survey(hw, 0);
+		survey_info = &priv->cur_survey_info;
+		if (!(hw->conf.flags & IEEE80211_CONF_OFFCHANNEL))
+			survey->filled |= SURVEY_INFO_IN_USE;
+	}
+
+	survey->channel = &survey_info->channel;
+	survey->filled |= survey_info->filled;
+	survey->time = survey_info->time_period / 1000;
+	survey->time_busy = survey_info->time_busy / 1000;
+	survey->time_tx = survey_info->time_tx / 1000;
+	survey->noise = survey_info->noise;
+
+	return 0;
+}
+
+static int mwl_mac80211_ampdu_action(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif,
+				     struct ieee80211_ampdu_params *params)
+{
+	int rc = 0;
+	struct mwl_priv *priv = hw->priv;
+	struct mwl_ampdu_stream *stream;
+	enum ieee80211_ampdu_mlme_action action = params->action;
+	struct ieee80211_sta *sta = params->sta;
+	u16 tid = params->tid;
+	u8 buf_size = params->buf_size;
+	u8 *addr = sta->addr;
+	struct mwl_sta *sta_info;
+
+	sta_info = mwl_dev_get_sta(sta);
+
+	spin_lock_bh(&priv->stream_lock);
+
+	stream = mwl_fwcmd_lookup_stream(hw, sta, tid);
+
+	switch (action) {
+	case IEEE80211_AMPDU_RX_START:
+		if (priv->chip_type == MWL8964) {
+			struct mwl_ampdu_stream tmp;
+
+			tmp.sta = sta;
+			tmp.tid = tid;
+			spin_unlock_bh(&priv->stream_lock);
+			mwl_fwcmd_create_ba(hw, &tmp, vif,
+					    BA_FLAG_DIRECTION_DOWN,
+					    buf_size, params->ssn,
+					    params->amsdu);
+			spin_lock_bh(&priv->stream_lock);
+			break;
+		}
+	case IEEE80211_AMPDU_RX_STOP:
+		if (priv->chip_type == MWL8964) {
+			struct mwl_ampdu_stream tmp;
+
+			tmp.sta = sta;
+			tmp.tid = tid;
+			spin_unlock_bh(&priv->stream_lock);
+			mwl_fwcmd_destroy_ba(hw, &tmp,
+					     BA_FLAG_DIRECTION_DOWN);
+			spin_lock_bh(&priv->stream_lock);
+		}
+		break;
+	case IEEE80211_AMPDU_TX_START:
+		if (!sta_info->is_ampdu_allowed) {
+			wiphy_warn(hw->wiphy, "ampdu not allowed\n");
+			rc = -EPERM;
+			break;
+		}
+
+		if (!stream) {
+			stream = mwl_fwcmd_add_stream(hw, sta, tid);
+			if (!stream) {
+				wiphy_warn(hw->wiphy, "no stream found\n");
+				rc = -EPERM;
+				break;
+			}
+		}
+
+		if (priv->chip_type != MWL8964) {
+			spin_unlock_bh(&priv->stream_lock);
+			rc = mwl_fwcmd_check_ba(hw, stream, vif,
+					BA_FLAG_DIRECTION_UP);
+			spin_lock_bh(&priv->stream_lock);
+			if (rc) {
+				mwl_fwcmd_remove_stream(hw, stream);
+				sta_info->check_ba_failed[tid]++;
+				break;
+			}
+		}
+		stream->state = AMPDU_STREAM_IN_PROGRESS;
+		spin_unlock_bh(&priv->stream_lock);
+		rc = mwl_fwcmd_get_seqno(hw, stream, &params->ssn);
+		spin_lock_bh(&priv->stream_lock);
+		if (rc)
+			break;
+		ieee80211_start_tx_ba_cb_irqsafe(vif, addr, tid);
+		break;
+	case IEEE80211_AMPDU_TX_STOP_CONT:
+	case IEEE80211_AMPDU_TX_STOP_FLUSH:
+	case IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:
+		if (stream) {
+			if (stream->state == AMPDU_STREAM_ACTIVE) {
+				stream->state = AMPDU_STREAM_IN_PROGRESS;
+				mwl_hif_tx_del_ampdu_pkts(hw, sta, tid);
+				spin_unlock_bh(&priv->stream_lock);
+				mwl_fwcmd_destroy_ba(hw, stream,
+						     BA_FLAG_DIRECTION_UP);
+				spin_lock_bh(&priv->stream_lock);
+				sta_info->is_amsdu_allowed = false;
+			}
+
+			mwl_fwcmd_remove_stream(hw, stream);
+			ieee80211_stop_tx_ba_cb_irqsafe(vif, addr, tid);
+		} else {
+			rc = -EPERM;
+		}
+		break;
+	case IEEE80211_AMPDU_TX_OPERATIONAL:
+		if (stream) {
+			if (WARN_ON(stream->state !=
+				    AMPDU_STREAM_IN_PROGRESS)) {
+				rc = -EPERM;
+				break;
+			}
+			spin_unlock_bh(&priv->stream_lock);
+			rc = mwl_fwcmd_create_ba(hw, stream, vif,
+						 BA_FLAG_DIRECTION_UP,
+						 buf_size, params->ssn,
+						 params->amsdu);
+			spin_lock_bh(&priv->stream_lock);
+
+			if (!rc) {
+				stream->state = AMPDU_STREAM_ACTIVE;
+				sta_info->check_ba_failed[tid] = 0;
+				if (priv->tx_amsdu)
+					sta_info->is_amsdu_allowed =
+						params->amsdu;
+				else
+					sta_info->is_amsdu_allowed = false;
+			} else {
+				spin_unlock_bh(&priv->stream_lock);
+				mwl_fwcmd_destroy_ba(hw, stream,
+						     BA_FLAG_DIRECTION_UP);
+				spin_lock_bh(&priv->stream_lock);
+				mwl_fwcmd_remove_stream(hw, stream);
+				wiphy_err(hw->wiphy,
+					  "ampdu operation error code: %d\n",
+					  rc);
+			}
+		} else {
+			rc = -EPERM;
+		}
+		break;
+	default:
+		rc = -ENOTSUPP;
+		break;
+	}
+
+	spin_unlock_bh(&priv->stream_lock);
+
+	return rc;
+}
+
+static int mwl_mac80211_chnl_switch(struct ieee80211_hw *hw,
+				    struct ieee80211_vif *vif,
+				    struct ieee80211_channel_switch *ch_switch)
+{
+	int rc = 0;
+
+	rc = mwl_fwcmd_set_switch_channel(hw, ch_switch);
+
+	return rc;
+}
+
+static void mwl_mac80211_sw_scan_start(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       const u8 *mac_addr)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	priv->sw_scanning = true;
+	priv->survey_info_idx = 0;
+}
+
+static void mwl_mac80211_sw_scan_complete(struct ieee80211_hw *hw,
+					  struct ieee80211_vif *vif)
+{
+	struct mwl_priv *priv = hw->priv;
+
+	priv->sw_scanning = false;
+}
+
+const struct ieee80211_ops mwl_mac80211_ops = {
+	.tx                 = mwl_mac80211_tx,
+	.start              = mwl_mac80211_start,
+	.stop               = mwl_mac80211_stop,
+	.add_interface      = mwl_mac80211_add_interface,
+	.remove_interface   = mwl_mac80211_remove_interface,
+	.config             = mwl_mac80211_config,
+	.bss_info_changed   = mwl_mac80211_bss_info_changed,
+	.configure_filter   = mwl_mac80211_configure_filter,
+	.set_key            = mwl_mac80211_set_key,
+	.set_rts_threshold  = mwl_mac80211_set_rts_threshold,
+	.sta_add            = mwl_mac80211_sta_add,
+	.sta_remove         = mwl_mac80211_sta_remove,
+	.conf_tx            = mwl_mac80211_conf_tx,
+	.get_stats          = mwl_mac80211_get_stats,
+	.get_survey         = mwl_mac80211_get_survey,
+	.ampdu_action       = mwl_mac80211_ampdu_action,
+	.pre_channel_switch = mwl_mac80211_chnl_switch,
+	.sw_scan_start      = mwl_mac80211_sw_scan_start,
+	.sw_scan_complete   = mwl_mac80211_sw_scan_complete,
+};
diff --git a/drivers/net/wireless/marvell/mwlwifi/mu_mimo.c b/drivers/net/wireless/marvell/mwlwifi/mu_mimo.c
new file mode 100644
index 000000000000..74ab054f947e
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/mu_mimo.c
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements MU-MIMO functions. */
+
+#include "sysadpt.h"
+#include "core.h"
+#include "mu_mimo.h"
+
diff --git a/drivers/net/wireless/marvell/mwlwifi/mu_mimo.h b/drivers/net/wireless/marvell/mwlwifi/mu_mimo.h
new file mode 100644
index 000000000000..24179f404774
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/mu_mimo.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines MU-MIMO functions. */
+
+#ifndef _MU_MIMO_H_
+#define _MU_MIMO_H_
+
+
+
+#endif /* _MU_MIMO_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/sysadpt.h b/drivers/net/wireless/marvell/mwlwifi/sysadpt.h
new file mode 100644
index 000000000000..1194e5271870
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/sysadpt.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines system adaptation related information. */
+
+#ifndef _SYSADPT_H_
+#define _SYSADPT_H_
+
+#define SYSADPT_MAX_STA                64
+
+#define SYSADPT_MAX_STA_SC4            300
+
+#define SYSADPT_MAX_NUM_CHANNELS       64
+
+#define SYSADPT_MAX_DATA_RATES_G       14
+
+#define SYSADPT_MAX_MCS_RATES          24
+
+#define SYSADPT_MAX_11AC_RATES         20
+
+#define SYSADPT_MAX_RATE_ADAPT_RATES   (SYSADPT_MAX_DATA_RATES_G + \
+					SYSADPT_MAX_MCS_RATES + \
+					SYSADPT_MAX_11AC_RATES)
+
+#define SYSADPT_TX_POWER_LEVEL_TOTAL   16  /* SC3 */
+
+#define SYSADPT_TX_GRP_PWR_LEVEL_TOTAL 28  /* KF2 */
+
+#define SYSADPT_TX_PWR_LEVEL_TOTAL_SC4 32  /* SC4 */
+
+#define SYSADPT_TX_WMM_QUEUES          4
+
+#define SYSADPT_NUM_OF_CLIENT          1
+
+#define SYSADPT_NUM_OF_AP              16
+
+#define SYSADPT_NUM_OF_MESH            1
+
+#define SYSADPT_TOTAL_TX_QUEUES        (SYSADPT_TX_WMM_QUEUES + \
+					SYSADPT_NUM_OF_AP)
+
+#define SYSADPT_MAX_AGGR_SIZE          4096
+
+#define SYSADPT_AMPDU_PACKET_THRESHOLD 64
+
+#define SYSADPT_AMSDU_FW_MAX_SIZE      3300
+
+#define SYSADPT_AMSDU_4K_MAX_SIZE      SYSADPT_AMSDU_FW_MAX_SIZE
+
+#define SYSADPT_AMSDU_8K_MAX_SIZE      SYSADPT_AMSDU_FW_MAX_SIZE
+
+#define SYSADPT_AMSDU_ALLOW_SIZE       1600
+
+#define SYSADPT_AMSDU_FLUSH_TIME       500
+
+#define SYSADPT_AMSDU_PACKET_THRESHOLD 10
+
+#define SYSADPT_MAX_TID                8
+
+#define SYSADPT_QUIET_PERIOD_DEFAULT   100
+
+#define SYSADPT_QUIET_PERIOD_MIN       25
+
+#define SYSADPT_QUIET_START_OFFSET     10
+
+#define SYSADPT_THERMAL_THROTTLE_MAX   100
+
+#define SYSADPT_TIMER_WAKEUP_TIME      10 /* ms */
+
+#define SYSADPT_OTP_BUF_SIZE           (256*8) /* 258 lines * 8 bytes */
+
+#define SYSADPT_TXPWRLMT_CFG_BUF_SIZE  (3650)
+
+#endif /* _SYSADPT_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/thermal.c b/drivers/net/wireless/marvell/mwlwifi/thermal.c
new file mode 100644
index 000000000000..7c59def51e7f
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/thermal.c
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements thermal framework related functions. */
+
+#include <linux/device.h>
+#include <linux/sysfs.h>
+#include <linux/thermal.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "hif/fwcmd.h"
+#include "thermal.h"
+
+static int
+mwl_thermal_get_max_throttle_state(struct thermal_cooling_device *cdev,
+				   unsigned long *state)
+{
+	*state = SYSADPT_THERMAL_THROTTLE_MAX;
+
+	return 0;
+}
+
+static int
+mwl_thermal_get_cur_throttle_state(struct thermal_cooling_device *cdev,
+				   unsigned long *state)
+{
+	struct mwl_priv *priv = cdev->devdata;
+
+	*state = priv->throttle_state;
+
+	return 0;
+}
+
+static int
+mwl_thermal_set_cur_throttle_state(struct thermal_cooling_device *cdev,
+				   unsigned long throttle_state)
+{
+	struct mwl_priv *priv = cdev->devdata;
+
+	if (throttle_state > SYSADPT_THERMAL_THROTTLE_MAX) {
+		wiphy_warn(priv->hw->wiphy,
+			   "throttle state %ld is exceeding the limit %d\n",
+			   throttle_state, SYSADPT_THERMAL_THROTTLE_MAX);
+		return -EINVAL;
+	}
+	priv->throttle_state = throttle_state;
+	mwl_thermal_set_throttling(priv);
+
+	return 0;
+}
+
+static struct thermal_cooling_device_ops mwl_thermal_ops = {
+	.get_max_state = mwl_thermal_get_max_throttle_state,
+	.get_cur_state = mwl_thermal_get_cur_throttle_state,
+	.set_cur_state = mwl_thermal_set_cur_throttle_state,
+};
+
+static ssize_t mwl_thermal_show_temp(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct mwl_priv *priv = dev_get_drvdata(dev);
+	int ret, temperature;
+
+	ret = mwl_fwcmd_get_temp(priv->hw, &priv->temperature);
+	if (ret) {
+		wiphy_warn(priv->hw->wiphy, "failed: can't get temperature\n");
+		goto out;
+	}
+
+	temperature = priv->temperature;
+
+	/* display in millidegree celcius */
+	ret = snprintf(buf, PAGE_SIZE, "%d\n", temperature * 1000);
+out:
+	return ret;
+}
+
+static SENSOR_DEVICE_ATTR(temp1_input, 0444, mwl_thermal_show_temp,
+			  NULL, 0);
+
+static struct attribute *mwl_hwmon_attrs[] = {
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(mwl_hwmon);
+
+void mwl_thermal_set_throttling(struct mwl_priv *priv)
+{
+	u32 period, duration, enabled;
+	int ret;
+
+	period = priv->quiet_period;
+	duration = (period * priv->throttle_state) / 100;
+	enabled = duration ? 1 : 0;
+
+	ret = mwl_fwcmd_quiet_mode(priv->hw, enabled, period,
+				   duration, SYSADPT_QUIET_START_OFFSET);
+	if (ret) {
+		wiphy_warn(priv->hw->wiphy,
+			   "failed: period %u duarion %u enabled %u ret %d\n",
+			    period, duration, enabled, ret);
+	}
+}
+
+int mwl_thermal_register(struct mwl_priv *priv)
+{
+	struct thermal_cooling_device *cdev;
+	struct device *hwmon_dev;
+	int ret;
+
+	if (priv->chip_type != MWL8897)
+		return 0;
+
+	cdev = thermal_cooling_device_register("mwlwifi_thermal", priv,
+					       &mwl_thermal_ops);
+	if (IS_ERR(cdev)) {
+		wiphy_err(priv->hw->wiphy,
+			  "failed to setup thermal device result: %ld\n",
+			  PTR_ERR(cdev));
+		return -EINVAL;
+	}
+
+	ret = sysfs_create_link(&priv->dev->kobj, &cdev->device.kobj,
+				"cooling_device");
+	if (ret) {
+		wiphy_err(priv->hw->wiphy,
+			  "failed to create cooling device symlink\n");
+		goto err_cooling_destroy;
+	}
+
+	priv->cdev = cdev;
+	priv->quiet_period = SYSADPT_QUIET_PERIOD_DEFAULT;
+
+	if (!IS_ENABLED(CONFIG_HWMON))
+		return 0;
+
+	hwmon_dev =
+		devm_hwmon_device_register_with_groups(priv->dev,
+						       "mwlwifi_hwmon", priv,
+						       mwl_hwmon_groups);
+	if (IS_ERR(hwmon_dev)) {
+		wiphy_err(priv->hw->wiphy,
+			  "failed to register hwmon device: %ld\n",
+			  PTR_ERR(hwmon_dev));
+		ret = -EINVAL;
+		goto err_remove_link;
+	}
+
+	return 0;
+
+err_remove_link:
+	sysfs_remove_link(&priv->dev->kobj, "cooling_device");
+err_cooling_destroy:
+	thermal_cooling_device_unregister(cdev);
+
+	return ret;
+}
+
+void mwl_thermal_unregister(struct mwl_priv *priv)
+{
+	if (priv->chip_type != MWL8897)
+		return;
+
+	sysfs_remove_link(&priv->dev->kobj, "cooling_device");
+	thermal_cooling_device_unregister(priv->cdev);
+}
diff --git a/drivers/net/wireless/marvell/mwlwifi/thermal.h b/drivers/net/wireless/marvell/mwlwifi/thermal.h
new file mode 100644
index 000000000000..c7f0ad2b87eb
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/thermal.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines Linux thermal framework related functions. */
+
+#ifndef _THERMAL_H_
+#define _THERMAL_H_
+
+#include <linux/kconfig.h>
+
+#if IS_ENABLED(CONFIG_THERMAL)
+int mwl_thermal_register(struct mwl_priv *priv);
+void mwl_thermal_unregister(struct mwl_priv *priv);
+void mwl_thermal_set_throttling(struct mwl_priv *priv);
+#else
+static inline int mwl_thermal_register(struct mwl_priv *priv)
+{
+	return 0;
+}
+
+static inline void mwl_thermal_unregister(struct mwl_priv *priv)
+{
+}
+
+static inline void mwl_thermal_set_throttling(struct mwl_priv *priv)
+{
+}
+#endif
+
+#endif /* _THERMAL_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/utils.c b/drivers/net/wireless/marvell/mwlwifi/utils.c
new file mode 100644
index 000000000000..b73054a3f55e
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/utils.c
@@ -0,0 +1,576 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements common utility functions. */
+
+#include <linux/etherdevice.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "utils.h"
+
+static unsigned short phy_rate[][5] = {
+	{2,   13,  15,  27,  30},   /* 0  */
+	{4,   26,  29,  54,  60},   /* 1  */
+	{11,  39,  43,  81,  90},   /* 2  */
+	{22,  52,  58,  108, 120},  /* 3  */
+	{44,  78,  87,  162, 180},  /* 4  */
+	{12,  104, 115, 216, 240},  /* 5  */
+	{18,  117, 130, 243, 270},  /* 6  */
+	{24,  130, 144, 270, 300},  /* 7  */
+	{36,  26,  29,  54,  60},   /* 8  */
+	{48,  52,  58,  108, 120},  /* 9  */
+	{72,  78,  87,  162, 180},  /* 10 */
+	{96,  104, 116, 216, 240},  /* 11 */
+	{108, 156, 173, 324, 360},  /* 12 */
+	{0,   208, 231, 432, 480},  /* 13 */
+	{0,   234, 260, 486, 540},  /* 14 */
+	{0,   260, 289, 540, 600},  /* 15 */
+	{0,   39,  43,  81,  90},   /* 16 */
+	{0,   78,  87,  162, 180},  /* 17 */
+	{0,   117, 130, 243, 270},  /* 18 */
+	{0,   156, 173, 324, 360},  /* 19 */
+	{0,   234, 260, 486, 540},  /* 20 */
+	{0,   312, 347, 648, 720},  /* 21 */
+	{0,   351, 390, 729, 810},  /* 22 */
+	{0,   390, 433, 810, 900},  /* 23 */
+};
+
+/* 20Mhz: Nss1_LGI, Nss1_SGI, Nss2_LGI, Nss2_SGI, Nss3_LGI, Nss3_SGI */
+static unsigned short phy_rate_11ac20M[][6] = {
+	{13,  15,  26,  29,  39,  44},   /* 0 */
+	{26,  29,  52,  58,  78,  87},   /* 1 */
+	{39,  44,  78,  87,  117, 130},  /* 2 */
+	{52,  58,  104, 116, 156, 174},  /* 3 */
+	{78,  87,  156, 174, 234, 260},  /* 4 */
+	{104, 116, 208, 231, 312, 347},  /* 5 */
+	{117, 130, 234, 260, 351, 390},  /* 6 */
+	{130, 145, 260, 289, 390, 434},  /* 7 */
+	{156, 174, 312, 347, 468, 520},  /* 8 */
+	/* Nss 1 and Nss 2 mcs9 not valid */
+	{2,   2,   2,   2,   520, 578},  /* 9 */
+};
+
+/* 40Mhz: Nss1_LGI, Nss1_SGI, Nss2_LGI, Nss2_SGI, Nss3_LGI, Nss3_SGI */
+static unsigned short phy_rate_11ac40M[][6] = {
+	{27,  30,  54,  60,  81,   90},   /* 0 */
+	{54,  60,  108, 120, 162,  180},  /* 1 */
+	{81,  90,  162, 180, 243,  270},  /* 2 */
+	{108, 120, 216, 240, 324,  360},  /* 3 */
+	{162, 180, 324, 360, 486,  540},  /* 4 */
+	{216, 240, 432, 480, 648,  720},  /* 5 */
+	{243, 270, 486, 540, 729,  810},  /* 6 */
+	{270, 300, 540, 600, 810,  900},  /* 7 */
+	{324, 360, 648, 720, 972,  1080}, /* 8 */
+	{360, 400, 720, 800, 1080, 1200}, /* 9 */
+};
+
+/* 80Mhz: Nss1_LGI, Nss1_SGI, Nss2_LGI, Nss2_SGI, Nss3_LGI, Nss3_SGI */
+static unsigned short phy_rate_11ac80M[][6] = {
+	{59,  65,  117,  130,  175,  195},  /* 0 */
+	{117, 130, 234,  260,  351,  390},  /* 1 */
+	{175, 195, 351,  390,  527,  585},  /* 2 */
+	{234, 260, 468,  520,  702,  780},  /* 3 */
+	{351, 390, 702,  780,  1053, 1170}, /* 4 */
+	{468, 520, 936,  1040, 1404, 1560}, /* 5 */
+	{527, 585, 1053, 1170, 2,    2},    /* 6, Nss 3 mcs6 not valid */
+	{585, 650, 1170, 1300, 1755, 1950}, /* 7 */
+	{702, 780, 1404, 1560, 2106, 2340}, /* 8 */
+	{780, 867, 1560, 1733, 2340, 2600}, /* 9 */
+};
+
+/* 160Mhz: Nss1_LGI, Nss1_SGI, Nss2_LGI, Nss2_SGI, Nss3_LGI, Nss3_SGI */
+static unsigned short phy_rate_11ac160M[][6] = {
+	{117,   130,  234,  260,  351,  390},  /* 0 */
+	{234,   260,  468,  520,  702,  780},  /* 1 */
+	{351,   390,  702,  780,  1053, 1170}, /* 2 */
+	{468,   520,  936,  1040, 1404, 1560}, /* 3 */
+	{702,   780,  1404, 1560, 2106, 2340}, /* 4 */
+	{936,   1040, 1872, 2080, 2808, 3120}, /* 5 */
+	{1053,  1170, 2106, 2340, 3159, 3510}, /* 6 */
+	{1170,  1300, 2340, 2600, 3510, 3900}, /* 7 */
+	{1404,  1560, 2808, 3120, 4212, 4680}, /* 8 */
+	{1560,  1733, 2130, 3467, 4680, 5200}, /* 9 */
+};
+
+int utils_get_phy_rate(u8 format, u8 bandwidth, u8 short_gi, u8 mcs_id)
+{
+	u8 index = 0;
+	u8 nss_11ac = 0;
+	u8 rate_11ac = 0;
+
+	if (format == TX_RATE_FORMAT_11N) {
+		index = (bandwidth << 1) | short_gi;
+		index++;
+	} else if (format == TX_RATE_FORMAT_11AC) {
+		rate_11ac = mcs_id & 0xf; /* 11ac, mcs_id[3:0]: rate     */
+		nss_11ac = mcs_id >> 4;	  /* 11ac, mcs_id[6:4]: nss code */
+		index = (nss_11ac << 1) | short_gi;
+	}
+
+	if (format != TX_RATE_FORMAT_11AC)
+		return (phy_rate[mcs_id][index] / 2);
+
+	if (bandwidth == TX_RATE_BANDWIDTH_20)
+		return (phy_rate_11ac20M[rate_11ac][index] / 2);
+	else if (bandwidth == TX_RATE_BANDWIDTH_40)
+		return (phy_rate_11ac40M[rate_11ac][index] / 2);
+	else if (bandwidth == TX_RATE_BANDWIDTH_80)
+		return (phy_rate_11ac80M[rate_11ac][index] / 2);
+	else
+		return (phy_rate_11ac160M[rate_11ac][index] / 2);
+}
+
+u8 utils_get_rate_id(u8 rate)
+{
+	switch (rate) {
+	case 10:   /* 1 Mbit/s or 12 Mbit/s */
+		return 0;
+	case 20:   /* 2 Mbit/s */
+		return 1;
+	case 55:   /* 5.5 Mbit/s */
+		return 2;
+	case 110:  /* 11 Mbit/s */
+		return 3;
+	case 220:  /* 22 Mbit/s */
+		return 4;
+	case 0xb:  /* 6 Mbit/s */
+		return 5;
+	case 0xf:  /* 9 Mbit/s */
+		return 6;
+	case 0xe:  /* 18 Mbit/s */
+		return 8;
+	case 0x9:  /* 24 Mbit/s */
+		return 9;
+	case 0xd:  /* 36 Mbit/s */
+		return 10;
+	case 0x8:  /* 48 Mbit/s */
+		return 11;
+	case 0xc:  /* 54 Mbit/s */
+		return 12;
+	case 0x7:  /* 72 Mbit/s */
+		return 13;
+	}
+
+	return 0;
+}
+
+u32 utils_get_init_tx_rate(struct mwl_priv *priv, struct ieee80211_conf *conf,
+			   struct ieee80211_sta *sta)
+{
+	u32 tx_rate;
+	u16 format, nss, bw, rate_mcs;
+
+	if (sta->vht_cap.vht_supported)
+		format = TX_RATE_FORMAT_11AC;
+	else if (sta->ht_cap.ht_supported)
+		format = TX_RATE_FORMAT_11N;
+	else
+		format = TX_RATE_FORMAT_LEGACY;
+
+	switch (priv->antenna_tx) {
+	case ANTENNA_TX_1:
+		nss = 1;
+		break;
+	case ANTENNA_TX_2:
+		nss = 2;
+		break;
+	case ANTENNA_TX_3:
+	case ANTENNA_TX_4_AUTO:
+		nss = 3;
+		break;
+	default:
+		nss = sta->rx_nss;
+		break;
+	}
+	if (nss > sta->rx_nss)
+		nss = sta->rx_nss;
+
+	switch (conf->chandef.width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+	case NL80211_CHAN_WIDTH_20:
+		bw = TX_RATE_BANDWIDTH_20;
+		break;
+	case NL80211_CHAN_WIDTH_40:
+		bw = TX_RATE_BANDWIDTH_40;
+		break;
+	case NL80211_CHAN_WIDTH_80:
+		bw = TX_RATE_BANDWIDTH_80;
+		break;
+	case NL80211_CHAN_WIDTH_160:
+		bw = TX_RATE_BANDWIDTH_160;
+		break;
+	default:
+		bw = sta->bandwidth;
+		break;
+	}
+	if (bw > sta->bandwidth)
+		bw = sta->bandwidth;
+
+	switch (format) {
+	case TX_RATE_FORMAT_LEGACY:
+		rate_mcs = 12; /* ignore 11b */
+		break;
+	case TX_RATE_FORMAT_11N:
+		rate_mcs = (nss * 8) - 1;
+		break;
+	default:
+		rate_mcs = ((nss - 1) << 4) | 8;
+		break;
+	}
+
+	tx_rate = (format | (bw << MWL_TX_RATE_BANDWIDTH_SHIFT) |
+		(TX_RATE_INFO_SHORT_GI << MWL_TX_RATE_SHORTGI_SHIFT) |
+		(rate_mcs << MWL_TX_RATE_RATEIDMCS_SHIFT));
+
+	return tx_rate;
+}
+
+struct mwl_vif *utils_find_vif_bss(struct mwl_priv *priv, u8 *bssid)
+{
+	struct mwl_vif *mwl_vif;
+
+	spin_lock_bh(&priv->vif_lock);
+	list_for_each_entry(mwl_vif, &priv->vif_list, list) {
+		if (ether_addr_equal(bssid, mwl_vif->bssid)) {
+			spin_unlock_bh(&priv->vif_lock);
+			return mwl_vif;
+		}
+	}
+	spin_unlock_bh(&priv->vif_lock);
+
+	return NULL;
+}
+
+struct mwl_sta *utils_find_sta(struct mwl_priv *priv, u8 *addr)
+{
+	struct mwl_sta *sta_info;
+	struct ieee80211_sta *sta;
+
+	spin_lock_bh(&priv->sta_lock);
+	list_for_each_entry(sta_info, &priv->sta_list, list) {
+		sta = container_of((void *)sta_info, struct ieee80211_sta,
+				   drv_priv);
+		if (ether_addr_equal(addr, sta->addr)) {
+			spin_unlock_bh(&priv->sta_lock);
+			return sta_info;
+		}
+	}
+	spin_unlock_bh(&priv->sta_lock);
+
+	return NULL;
+}
+
+struct mwl_sta *utils_find_sta_by_aid(struct mwl_priv *priv, u16 aid)
+{
+	struct mwl_sta *sta_info;
+	struct ieee80211_sta *sta;
+
+	spin_lock_bh(&priv->sta_lock);
+	list_for_each_entry(sta_info, &priv->sta_list, list) {
+		sta = container_of((void *)sta_info, struct ieee80211_sta,
+				   drv_priv);
+		if (sta->aid == aid) {
+			spin_unlock_bh(&priv->sta_lock);
+			return sta_info;
+		}
+	}
+	spin_unlock_bh(&priv->sta_lock);
+
+	return NULL;
+}
+
+struct mwl_sta *utils_find_sta_by_id(struct mwl_priv *priv, u16 stnid)
+{
+	struct mwl_sta *sta_info;
+
+	spin_lock_bh(&priv->sta_lock);
+	list_for_each_entry(sta_info, &priv->sta_list, list) {
+		if (sta_info->stnid == stnid) {
+			spin_unlock_bh(&priv->sta_lock);
+			return sta_info;
+		}
+	}
+	spin_unlock_bh(&priv->sta_lock);
+
+	return NULL;
+}
+
+void utils_dump_data_info(const char *prefix_str, const void *buf, size_t len)
+{
+	print_hex_dump(KERN_INFO, prefix_str, DUMP_PREFIX_OFFSET,
+		       16, 1, buf, len, true);
+}
+
+void utils_dump_data_debug(const char *prefix_str, const void *buf, size_t len)
+{
+	print_hex_dump(KERN_DEBUG, prefix_str, DUMP_PREFIX_OFFSET,
+		       16, 1, buf, len, true);
+}
+
+bool utils_is_non_amsdu_packet(const void *packet, bool mac80211)
+{
+	const u8 *data = packet;
+	struct ieee80211_hdr *wh;
+	__be16 *protocol;
+	struct iphdr *iph;
+	struct udphdr *udph;
+
+	if (mac80211) {
+		/* mac80211 packet */
+		wh = (struct ieee80211_hdr *)data;
+		data += ieee80211_hdrlen(wh->frame_control) + 6;
+		protocol = (__be16 *)data;
+	} else {
+		/* mac802.3 packet */
+		data += (2 * ETH_ALEN);
+		protocol = (__be16 *)data;
+	}
+
+	if (*protocol == cpu_to_be16(ETH_P_PAE))
+		return true;
+
+	if (*protocol == htons(ETH_P_ARP))
+		return true;
+
+	if (*protocol == htons(ETH_P_IP)) {
+		data += sizeof(__be16);
+		iph = (struct iphdr *)data;
+		if (iph->protocol == IPPROTO_ICMP)
+			return true;
+		if (iph->protocol == IPPROTO_UDP) {
+			data += (iph->ihl * 4);
+			udph = (struct udphdr *)data;
+			if (((udph->source == htons(68)) &&
+			    (udph->dest == htons(67))) ||
+			    ((udph->source == htons(67)) &&
+			    (udph->dest == htons(68))))
+				return true;
+		}
+	}
+
+	return false;
+}
+
+bool utils_is_arp(const void *packet, bool mac80211, u16 *arp_op)
+{
+	const u8 *data = packet;
+	struct ieee80211_hdr *wh;
+	__be16 *protocol;
+	struct arphdr *arph;
+
+	if (mac80211) {
+		/* mac80211 packet */
+		wh = (struct ieee80211_hdr *)data;
+		data += ieee80211_hdrlen(wh->frame_control) + 6;
+		protocol = (__be16 *)data;
+	} else {
+		/* mac802.3 packet */
+		data += (2 * ETH_ALEN);
+		protocol = (__be16 *)data;
+	}
+
+	if (*protocol == htons(ETH_P_ARP)) {
+		data += sizeof(__be16);
+		arph = (struct arphdr *)data;
+		*arp_op = ntohs(arph->ar_op);
+		return true;
+	}
+
+	return false;
+}
+
+bool utils_is_icmp_echo(const void *packet, bool mac80211, u8 *type)
+{
+	const u8 *data = packet;
+	struct ieee80211_hdr *wh;
+	__be16 *protocol;
+	struct iphdr *iph;
+	struct icmphdr *icmph;
+
+	if (mac80211) {
+		/* mac80211 packet */
+		wh = (struct ieee80211_hdr *)data;
+		data += ieee80211_hdrlen(wh->frame_control) + 6;
+		protocol = (__be16 *)data;
+	} else {
+		/* mac802.3 packet */
+		data += (2 * ETH_ALEN);
+		protocol = (__be16 *)data;
+	}
+
+	if (*protocol == htons(ETH_P_IP)) {
+		data += sizeof(__be16);
+		iph = (struct iphdr *)data;
+		if (iph->protocol == IPPROTO_ICMP) {
+			data += (iph->ihl * 4);
+			icmph = (struct icmphdr *)data;
+			*type = icmph->type;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+bool utils_is_dhcp(const void *packet, bool mac80211, u8 *op, u8 *dhcp_client)
+{
+	const u8 *data = packet;
+	struct ieee80211_hdr *wh;
+	__be16 *protocol;
+	struct iphdr *iph;
+	struct udphdr *udph;
+
+	if (mac80211) {
+		/* mac80211 packet */
+		wh = (struct ieee80211_hdr *)data;
+		data += ieee80211_hdrlen(wh->frame_control) + 6;
+		protocol = (__be16 *)data;
+	} else {
+		/* mac802.3 packet */
+		data += (2 * ETH_ALEN);
+		protocol = (__be16 *)data;
+	}
+
+	if (*protocol == htons(ETH_P_IP)) {
+		data += sizeof(__be16);
+		iph = (struct iphdr *)data;
+		if (iph->protocol == IPPROTO_UDP) {
+			data += (iph->ihl * 4);
+			udph = (struct udphdr *)data;
+			if (((udph->source == htons(68)) &&
+			    (udph->dest == htons(67))) ||
+			    ((udph->source == htons(67)) &&
+			    (udph->dest == htons(68)))) {
+				data += sizeof(struct udphdr);
+				*op = *data;
+				ether_addr_copy(dhcp_client, data + 28);
+				return true;
+			}
+		}
+	}
+
+	return false;
+}
+
+void utils_dump_arp(const void *packet, bool mac80211, size_t len)
+{
+	const u8 *data = packet;
+	struct ieee80211_hdr *wh;
+	__be16 *protocol;
+	struct arphdr *arph;
+
+	if (mac80211) {
+		/* mac80211 packet */
+		wh = (struct ieee80211_hdr *)data;
+		data += ieee80211_hdrlen(wh->frame_control) + 6;
+		protocol = (__be16 *)data;
+	} else {
+		/* mac802.3 packet */
+		data += (2 * ETH_ALEN);
+		protocol = (__be16 *)data;
+	}
+
+	if (*protocol == htons(ETH_P_ARP)) {
+		data += sizeof(__be16);
+		arph = (struct arphdr *)data;
+		if (arph->ar_op == htons(ARPOP_REQUEST))
+			utils_dump_data_info("ARP REQUEST: ", packet, len);
+		else if (arph->ar_op == htons(ARPOP_REPLY))
+			utils_dump_data_info("ARP REPLY: ", packet, len);
+	}
+}
+
+void utils_dump_icmp_echo(const void *packet, bool mac80211, size_t len)
+{
+	const u8 *data = packet;
+	struct ieee80211_hdr *wh;
+	__be16 *protocol;
+	struct iphdr *iph;
+	struct icmphdr *icmph;
+
+	if (mac80211) {
+		/* mac80211 packet */
+		wh = (struct ieee80211_hdr *)data;
+		data += ieee80211_hdrlen(wh->frame_control) + 6;
+		protocol = (__be16 *)data;
+	} else {
+		/* mac802.3 packet */
+		data += (2 * ETH_ALEN);
+		protocol = (__be16 *)data;
+	}
+
+	if (*protocol == htons(ETH_P_IP)) {
+		data += sizeof(__be16);
+		iph = (struct iphdr *)data;
+		if (iph->protocol == IPPROTO_ICMP) {
+			data += (iph->ihl * 4);
+			icmph = (struct icmphdr *)data;
+			if (icmph->type == ICMP_ECHO)
+				utils_dump_data_info("ECHO REQUEST: ",
+						     packet, len);
+			else if (icmph->type == ICMP_ECHOREPLY)
+				utils_dump_data_info("ECHO REPLY: ",
+						     packet, len);
+		}
+	}
+}
+
+void utils_dump_dhcp(const void *packet, bool mac80211, size_t len)
+{
+	const u8 *data = packet;
+	struct ieee80211_hdr *wh;
+	__be16 *protocol;
+	struct iphdr *iph;
+	struct udphdr *udph;
+	const char *dhcp_op[8] = {
+		"DHCPDISCOVER",
+		"DHCPOFFER",
+		"DHCPREQUEST",
+		"DHCPDECLINE",
+		"DHCPACK",
+		"DHCPNAK",
+		"DHCPRELEASE",
+		"DHCPINFORM"
+	};
+
+	if (mac80211) {
+		/* mac80211 packet */
+		wh = (struct ieee80211_hdr *)data;
+		data += ieee80211_hdrlen(wh->frame_control) + 6;
+		protocol = (__be16 *)data;
+	} else {
+		/* mac802.3 packet */
+		data += (2 * ETH_ALEN);
+		protocol = (__be16 *)data;
+	}
+
+	if (*protocol == htons(ETH_P_IP)) {
+		data += sizeof(__be16);
+		iph = (struct iphdr *)data;
+		if (iph->protocol == IPPROTO_UDP) {
+			data += (iph->ihl * 4);
+			udph = (struct udphdr *)data;
+			if (((udph->source == htons(68)) &&
+			    (udph->dest == htons(67))) ||
+			    ((udph->source == htons(67)) &&
+			    (udph->dest == htons(68)))) {
+				data += sizeof(struct udphdr);
+				utils_dump_data_info(dhcp_op[*data - 1],
+						     packet, len);
+			}
+		}
+	}
+}
diff --git a/drivers/net/wireless/marvell/mwlwifi/utils.h b/drivers/net/wireless/marvell/mwlwifi/utils.h
new file mode 100644
index 000000000000..4a292e990412
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/utils.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines common utility functions. */
+
+#ifndef _UTILS_H_
+#define _UTILS_H_
+
+#include <net/arp.h>
+#include <net/ip.h>
+#include <net/udp.h>
+#include <net/icmp.h>
+
+/* DHCP message types */
+#define DHCPDISCOVER    1
+#define DHCPOFFER       2
+#define DHCPREQUEST     3
+#define DHCPDECLINE     4
+#define DHCPACK         5
+#define DHCPNAK         6
+#define DHCPRELEASE     7
+#define DHCPINFORM      8
+
+static inline int utils_tid_to_ac(u8 tid)
+{
+	switch (tid) {
+	case 0:
+	case 3:
+		return IEEE80211_AC_BE;
+	case 1:
+	case 2:
+		return IEEE80211_AC_BK;
+	case 4:
+	case 5:
+		return IEEE80211_AC_VI;
+	case 6:
+	case 7:
+		return IEEE80211_AC_VO;
+	default:
+		break;
+	}
+
+	return -1;
+}
+
+static inline void utils_add_basic_rates(int band, struct sk_buff *skb)
+{
+	struct ieee80211_mgmt *mgmt;
+	int len;
+	u8 *pos;
+
+	mgmt = (struct ieee80211_mgmt *)skb->data;
+	len = skb->len - ieee80211_hdrlen(mgmt->frame_control);
+	len -= 4;
+	pos = (u8 *)cfg80211_find_ie(WLAN_EID_SUPP_RATES,
+				     mgmt->u.assoc_req.variable,
+				     len);
+	if (pos) {
+		pos++;
+		len = *pos++;
+		while (len) {
+			if (band == NL80211_BAND_2GHZ) {
+				if ((*pos == 2) || (*pos == 4) ||
+				    (*pos == 11) || (*pos == 22))
+					*pos |= 0x80;
+			} else {
+				if ((*pos == 12) || (*pos == 24) ||
+				    (*pos == 48))
+					*pos |= 0x80;
+			}
+			pos++;
+			len--;
+		}
+	}
+}
+
+static inline int utils_assign_stnid(struct mwl_priv *priv, int macid, u16 aid)
+{
+	int stnid;
+	int i;
+
+	spin_lock_bh(&priv->stnid_lock);
+	stnid = priv->available_stnid;
+	if (stnid >= priv->stnid_num) {
+		spin_unlock_bh(&priv->stnid_lock);
+		return 0;
+	}
+	priv->stnid[stnid].macid = macid;
+	priv->stnid[stnid].aid = aid;
+	stnid++;
+	for (i = stnid; i < priv->stnid_num; i++) {
+		if (!priv->stnid[i].aid)
+			break;
+	}
+	priv->available_stnid = i;
+	spin_unlock_bh(&priv->stnid_lock);
+	return stnid;
+}
+
+static inline void utils_free_stnid(struct mwl_priv *priv, u16 stnid)
+{
+	spin_lock_bh(&priv->stnid_lock);
+	if (stnid && (stnid <= priv->stnid_num)) {
+		stnid--;
+		priv->stnid[stnid].macid = 0;
+		priv->stnid[stnid].aid = 0;
+		if (priv->available_stnid > stnid)
+			priv->available_stnid = stnid;
+	}
+	spin_unlock_bh(&priv->stnid_lock);
+}
+
+int utils_get_phy_rate(u8 format, u8 bandwidth, u8 short_gi, u8 mcs_id);
+
+u8 utils_get_rate_id(u8 rate);
+
+u32 utils_get_init_tx_rate(struct mwl_priv *priv, struct ieee80211_conf *conf,
+			   struct ieee80211_sta *sta);
+
+struct mwl_vif *utils_find_vif_bss(struct mwl_priv *priv, u8 *bssid);
+
+struct mwl_sta *utils_find_sta(struct mwl_priv *priv, u8 *addr);
+
+struct mwl_sta *utils_find_sta_by_aid(struct mwl_priv *priv, u16 aid);
+
+struct mwl_sta *utils_find_sta_by_id(struct mwl_priv *priv, u16 stnid);
+
+void utils_dump_data_info(const char *prefix_str, const void *buf, size_t len);
+
+void utils_dump_data_debug(const char *prefix_str, const void *buf, size_t len);
+
+bool utils_is_non_amsdu_packet(const void *packet, bool mac80211);
+
+bool utils_is_arp(const void *packet, bool mac80211, u16 *arp_op);
+
+bool utils_is_icmp_echo(const void *packet, bool mac80211, u8 *type);
+
+bool utils_is_dhcp(const void *packet, bool mac80211, u8 *op, u8 *dhcp_client);
+
+void utils_dump_arp(const void *packet, bool mac80211, size_t len);
+
+void utils_dump_icmp_echo(const void *packet, bool mac80211, size_t len);
+
+void utils_dump_dhcp(const void *packet, bool mac80211, size_t len);
+
+#endif /* _UTILS_H_ */
diff --git a/drivers/net/wireless/marvell/mwlwifi/vendor_cmd.c b/drivers/net/wireless/marvell/mwlwifi/vendor_cmd.c
new file mode 100644
index 000000000000..3e26fc42c225
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/vendor_cmd.c
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file implements vendor spcific functions. */
+
+#include <net/mac80211.h>
+#include <net/netlink.h>
+#include <linux/version.h>
+
+#include "sysadpt.h"
+#include "core.h"
+#include "utils.h"
+#include "hif/fwcmd.h"
+#include "vendor_cmd.h"
+
+static const struct nla_policy mwl_vendor_attr_policy[NUM_MWL_VENDOR_ATTR] = {
+	[MWL_VENDOR_ATTR_BF_TYPE] = { .type = NLA_U8 },
+};
+
+static int mwl_vendor_cmd_set_bf_type(struct wiphy *wiphy,
+				      struct wireless_dev *wdev,
+				      const void *data, int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mwl_priv *priv = hw->priv;
+	struct nlattr *tb[NUM_MWL_VENDOR_ATTR];
+	int rc;
+	u8 val;
+
+	if (priv->chip_type != MWL8964)
+		return -EPERM;
+
+	rc = nla_parse(tb, MWL_VENDOR_ATTR_MAX, data, data_len,
+		       mwl_vendor_attr_policy
+#if (defined(LINUX_BACKPORT) || (LINUX_VERSION_CODE >=KERNEL_VERSION(4,12,0)))
+               , NULL
+#endif
+               );
+	if (rc)
+		return rc;
+
+	if (!tb[MWL_VENDOR_ATTR_BF_TYPE])
+		return -EINVAL;
+
+	val = nla_get_u8(tb[MWL_VENDOR_ATTR_BF_TYPE]);
+	if ((val < TXBF_MODE_OFF) || (val > TXBF_MODE_BFMER_AUTO))
+		return -EINVAL;
+	wiphy_debug(wiphy, "set bf_type: 0x%x\n", val);
+
+	rc = mwl_fwcmd_set_bftype(hw, val);
+	if (!rc)
+		priv->bf_type = val;
+
+	return rc;
+}
+
+static int mwl_vendor_cmd_get_bf_type(struct wiphy *wiphy,
+				      struct wireless_dev *wdev,
+				      const void *data, int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mwl_priv *priv = hw->priv;
+	struct sk_buff *skb;
+
+	if (priv->chip_type != MWL8964)
+		return -EPERM;
+
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, 8);
+	if (!skb)
+		return -ENOMEM;
+
+	nla_put_u8(skb, MWL_VENDOR_ATTR_BF_TYPE, priv->bf_type);
+
+	return cfg80211_vendor_cmd_reply(skb);
+}
+
+static const struct wiphy_vendor_command mwl_vendor_commands[] = {
+	{
+		.info = { .vendor_id = MRVL_OUI,
+			  .subcmd = MWL_VENDOR_CMD_SET_BF_TYPE},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = mwl_vendor_cmd_set_bf_type,
+	},
+	{
+		.info = { .vendor_id = MRVL_OUI,
+			  .subcmd = MWL_VENDOR_CMD_GET_BF_TYPE},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = mwl_vendor_cmd_get_bf_type,
+	}
+};
+
+static const struct nl80211_vendor_cmd_info mwl_vendor_events[] = {
+	{
+		.vendor_id = MRVL_OUI,
+		.subcmd =  MWL_VENDOR_EVENT_DRIVER_READY,
+	},
+	{
+		.vendor_id = MRVL_OUI,
+		.subcmd =  MWL_VENDOR_EVENT_DRIVER_START_REMOVE,
+	},
+	{
+		.vendor_id = MRVL_OUI,
+		.subcmd =  MWL_VENDOR_EVENT_CMD_TIMEOUT,
+	}
+};
+
+void vendor_cmd_register(struct wiphy *wiphy)
+{
+	wiphy->vendor_commands = mwl_vendor_commands;
+	wiphy->n_vendor_commands = ARRAY_SIZE(mwl_vendor_commands);
+	wiphy->vendor_events = mwl_vendor_events;
+	wiphy->n_vendor_events = ARRAY_SIZE(mwl_vendor_events);
+}
+
+void vendor_cmd_basic_event(struct wiphy *wiphy, int event_idx)
+{
+	struct sk_buff *skb;
+
+	skb = cfg80211_vendor_event_alloc(wiphy, NULL, 0,
+					  event_idx, GFP_KERNEL);
+
+	if (skb)
+		cfg80211_vendor_event(skb, GFP_KERNEL);
+}
diff --git a/drivers/net/wireless/marvell/mwlwifi/vendor_cmd.h b/drivers/net/wireless/marvell/mwlwifi/vendor_cmd.h
new file mode 100644
index 000000000000..b6fdf70c22fb
--- /dev/null
+++ b/drivers/net/wireless/marvell/mwlwifi/vendor_cmd.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2006-2018, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ */
+
+/* Description:  This file defines vendor constants and register function. */
+
+#ifndef _VENDOR_CMD_H_
+#define _VENDOR_CMD_H_
+
+#ifdef __KERNEL__
+void vendor_cmd_register(struct wiphy *wiphy);
+void vendor_cmd_basic_event(struct wiphy *wiphy, int event_idx);
+#endif
+
+#define MRVL_OUI        0x005043
+
+enum mwl_vendor_commands {
+	MWL_VENDOR_CMD_SET_BF_TYPE,
+	MWL_VENDOR_CMD_GET_BF_TYPE,
+
+	/* add commands here, update the command in vendor_cmd.c */
+
+	__MWL_VENDOR_CMD_AFTER_LAST,
+	NUM_MWL_VENDOR_CMD = __MWL_VENDOR_CMD_AFTER_LAST,
+	MWL_VENDOR_CMD_MAX = __MWL_VENDOR_CMD_AFTER_LAST - 1
+};
+
+enum mwl_vendor_attributes {
+	MWL_VENDOR_ATTR_NOT_USE,
+	MWL_VENDOR_ATTR_BF_TYPE,
+
+	/* add attributes here, update the policy in vendor_cmd.c */
+
+	__MWL_VENDOR_ATTR_AFTER_LAST,
+	NUM_MWL_VENDOR_ATTR = __MWL_VENDOR_ATTR_AFTER_LAST,
+	MWL_VENDOR_ATTR_MAX = __MWL_VENDOR_ATTR_AFTER_LAST - 1
+};
+
+enum mwl_vendor_events {
+	MWL_VENDOR_EVENT_DRIVER_READY,
+	MWL_VENDOR_EVENT_DRIVER_START_REMOVE,
+	MWL_VENDOR_EVENT_CMD_TIMEOUT,
+
+	__MWL_VENDOR_EVENT_AFTER_LAST,
+	NUM_MWL_VENDOR_EVENT = __MWL_VENDOR_EVENT_AFTER_LAST,
+	MWL_VENDOR_EVENT_MAX = __MWL_VENDOR_EVENT_AFTER_LAST - 1
+};
+
+#endif /* _VENDOR_CMD_H_ */
-- 
2.22.0

